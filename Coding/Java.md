# 📌 Содержание <a id="content"></a>                  

## [📘 Основы Java](#основы-java) <a id="основы-java-2"></a>

   - [🔸 Базовый синтаксис](#базовый-синтаксис) 
   - [🔸 Классы и методы](#классы-и-методы)
   - [🔸 Основы компиляции](#основы-компиляции)
   - [🔸 Структура Java-программы](#структура-java-программы)
   - [🔸 Порядок выполнения кода](#порядок-выполнения-кода)
   - [🔸 Ключевые слова Java](#ключевые-слова-java)

## [📗 Типы данных и переменные](#типы-данных-и-переменные) <a id="типы-данных-и-переменные-2"></a>

   - [🔹 Примитивные и ссылочные типы](#примитивные-и-ссылочные-типы)
   - [🔹 Автоупаковка и распаковка](#автоупаковка-и-распаковка)
   - [🔹 String и пул строк](#string-и-пул-строк)
   - [🔹 Call-by-value vs Call-by-reference](#call-by-value-vs-call-by-reference)
   - [🔹 Мутабельность и иммутабельность](#мутабельность-и-иммутабельность)

## [📙 Управление потоком выполнения](#управление-потоком-выполнения)  <a id="управление-потоком-выполнения-2"></a>

   - [🔸 Условные операторы](#условные-операторы)
   - [🔸 Циклы](#циклы)
   - [🔸 Операторы (+, ==, instanceof, new)](#операторы)
   - [🔸 Управляющие конструкции (break, continue, return)](#управляющие-конструкции)

## [🟨 ООП в Java](#ооп-в-java)  <a id="ооп-в-java-2"></a>

   - [🔹 Принципы ООП](#принципы-ооп)
   - [🔹 Наследование](#наследование)
   - [🔹 Переопределение и перегрузка](#переопределение-и-перегрузка)
   - [🔹 Интерфейсы и абстрактные классы](#интерфейсы-и-абстрактные-классы)
   - [🔹 Множественное наследование](#множественное-наследование)
   - [🔹 Ключевые концепции ООП](#ключевые-концепции-ооп)

## [🔐 Модификаторы и область видимости](#модификаторы-и-область-видимости)   <a id="модификаторы-и-область-видимости-2"></a>

   - [🔸 Модификаторы доступа](#модификаторы-доступа)
   - [🔸 Ключевые слова: final, static, abstract](#ключевые-слова-final-static-abstract)
   - [🔸 Отличие final/finally/finalize](#отличие-final-finally-finalize)
   - [🔸 Область видимости переменных](#область-видимости-переменных)

## [🧨 Исключения и ошибки](#исключения-и-ошибки)  <a id="исключения-и-ошибки-2"></a>

   - [🔹 Иерархия Throwable](#иерархия-throwable)
   - [🔹 Checked vs Unchecked](#checked-vs-unchecked)
   - [🔹 Обработка: try, catch, finally, throws](#обработка-исключений)
   - [🔹 Создание собственных исключений](#создание-собственных-исключений)

## [📚 Коллекции Java](#коллекции-java)  <a id="коллекции-java-2"></a>

   - [🔸 List, Set, Map, Queue](#list-set-map-queue)
   - [🔸 Методы для работы с коллекциями](#методы-коллекции)  
   - [🔸 ArrayList vs LinkedList](#arraylist-vs-linkedlist)
   - [🔸 HashMap, TreeMap](#hashmap-treemap)
   - [🔸 Iterable, Iterator](#iterable-iterator)
   - [🔸 Collections utility methods](#collections-utility-methods)
   - [🔸 Stack, Queue, Deque](#stack-queue-deque)

## [🧮 Структуры данных и алгоритмы](#структуры-данных-и-алгоритмы)  <a id="структуры-данных-и-алгоритмы-2"></a>

   - [🔹 Классы, интерфейсы - обьекты java](#классы-обьекты-java)
   - [🔹 Очереди и стеки](#очереди-и-стеки)
   - [🔹 Хэш-таблицы](#хэш-таблицы)
   - [🔹 Списки](#списки)
   - [🔹 Сортировка (Arrays.sort, Comparator)](#сортировка)
   - [🔹 Поиск, бинарный поиск](#поиск)

## [🌀 Обобщения (Generics)](#обобщения-generics)  <a id="обобщения-generics-2"></a>

   - [🔸 Обобщённые классы и методы](#обобщённые-классы-и-методы)
   - [🔸 Ограничения: extends, super](#ограничения-extends-super)
   - [🔸 Wildcards](#wildcards)
   - [🔸 Raw types](#raw-types)
   - [🔸 Type erasure](#type-erasure)

## [🚀 Современные фичи Java](#современные-фичи-java)  <a id="современные-фичи-java-2"></a>

   - [🔹 Лямбда-выражения](#лямбда-выражения)
   - [🔹 Stream API](#stream-api)
   - [🔹 Optional](#optional)
   - [🔹 Функциональные интерфейсы](#функциональные-интерфейсы)
   - [🔹 Method references](#method-references)

## [🧠 JVM, память и производительность](#jvm-память-и-производительность)  <a id="jvm-память-и-производительность-2"></a>

   - [🔸 JVM и её архитектура](#jvm-и-архитектура)
   - [🔸 Память: Heap, Stack](#heap-stack)
   - [🔸 Сборщик мусора](#сборщик-мусора)
   - [🔸 Finalize](#finalize)
   - [🔸 Оптимизация и утечки](#оптимизация-и-утечки)

## [🧵 Многопоточность и конкурентность](#многопоточность-и-конкурентность)  <a id="многопоточность-и-конкурентность-2"></a>

   - [🔹 Thread, Runnable](#thread-runnable)
   - [🔹 synchronized, volatile](#synchronized-volatile)
   - [🔹 ExecutorService](#executorservice)
   - [🔹 Concurrent коллекции](#concurrent-коллекции)
   - [🔹 Deadlock, race condition](#deadlock-race-condition)

## [🔎 Рефлексия и аннотации](#рефлексия-и-аннотации)  <a id="рефлексия-и-аннотации-2"></a>

   - [🔸 Рефлексия](#рефлексия)
   - [🔸 Аннотации](#аннотации)
   - [🔸 Создание кастомных аннотаций](#кастомные-аннотации)
   - [🔸 Использование в библиотеках](#использование-в-библиотеках)

## [🗃️ Работа с файлами и I/O](#работа-с-файлами-и-io)  <a id="работа-с-файлами-и-io-2"></a>

   - [🔹 File, Path, Files](#file-path-files)
   - [🔹 Reader, Writer](#reader-writer)
   - [🔹 BufferedReader, Scanner](#bufferedreader-scanner)
   - [🔹 NIO2](#nio2)
   - [🔹 Channels](#channels)

## [🌐 Сетевое взаимодействие](#сетевое-взаимодействие)  <a id="сетевое-взаимодействие-2"></a>

   - [🔸 HttpClient](#httpclient)
   - [🔸 HttpURLConnection](#httpurlconnection)
   - [🔸 TCP/UDP сокеты](#tcp-udp-сокеты)
   - [🔸 Простейшие REST-клиенты](#rest-клиенты)

## [🛠 Инструменты и экосистема](#инструменты-и-экосистема)  <a id="инструменты-и-экосистема-2"></a>

   - [🔹 Gradle и Maven](#gradle-и-maven)
   - [🔹 Unit-тестирование (JUnit 5, Mockito)](#unit-тестирование)
   - [🔹 Логгирование: SLF4J, Log4j, Logback](#логгирование)
   - [🔹 CI/CD основы](#ci-cd-основы)

## [🏗 Архитектура и паттерны](#архитектура-и-паттерны)  <a id="архитектура-и-паттерны-2"></a>

   - [🔸 Порождающие, структурные, поведенческие](#группы-паттернов)
   - [🔸 Принципы SOLID, DRY, KISS](#принципы-solid-dry-kiss)
   - [🔸 DDD, MVC и архитектурные подходы](#ddd-mvc)

## [📈 Версии Java](#версии-java)  <a id="версии-java-2"></a>

   - [🔹 Java 8: Stream, Optional, Lambda](#java-8)
   - [🔹 Java 9–17: JPMS, Records, Text Blocks](#java-9-17)
   - [🔹 Java 21+: Pattern Matching, Virtual Threads](#java-21)
   - [🔹 LTS и поддержка](#lts-и-поддержка)

## [🧮 Сортировки в Java](#сортировки-в-java)  <a id="сортировки-в-java-2"></a>

   - [🔸 Arrays.sort](#arrays-sort)
   - [🔸 Collections.sort](#collections-sort)
   - [🔸 Comparator и Comparable](#comparator-и-comparable)
   - [🔸 Стабильность сортировки](#стабильность-сортировки)
   - [🔸 Пользовательские реализации сортировок](#пользовательские-реализации-сортировок)
   - [🔸 Сложность алгоритмов сортировки](#сложность-алгоритмов-сортировки)

---

## 📘 Основы Java <a id="основы-java"></a>

### 🔹 Базовый синтаксис <a id="базовый-синтаксис"></a>

#### Что такое синтаксис в Java?

Синтаксис — это набор правил, по которым пишется код на языке Java. Он определяет структуру программ, способы объявления переменных, написания выражений, операторов, методов и классов. Правильное соблюдение синтаксиса обязательно для успешной компиляции и выполнения программы.

#### Основные элементы базового синтаксиса Java

- **Классы и методы:** Основная структура программы. Выполнение начинается с метода main.
- **Точки с запятой:** Каждое утверждение заканчивается точкой с запятой.
- **Идентификаторы:** Имена классов, методов и переменных с определёнными правилами именования.
- **Комментарии:** Однострочные и многострочные, для документирования и временного отключения кода.
- **Ключевые слова:** Зарезервированные слова, которые нельзя использовать как имена.
- **Блоки кода:** Группировка операторов в фигурных скобках.

#### Пример минимальной Java-программы

```java
// Объявление публичного класса с именем HelloWorld
public class HelloWorld {
    
    // Точка входа в программу — главный метод main
    public static void main(String[] args) {
        
        // Вывод текста "Hello, World!" в консоль
        System.out.println("Hello, World!");
    }
}
```

[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Классы и методы <a id="классы-и-методы"></a>

#### Виды классов в Java и их описание

| Вид класса                | Описание                                                                                              |
|--------------------------|-----------------------------------------------------------------------------------------------------|
| **Обычный класс**         | Стандартный класс, который можно создавать, наследовать, использовать для описания объектов          |
| **Абстрактный класс**     | Класс, который нельзя создать напрямую (нельзя вызвать `new`), может содержать абстрактные методы (без реализации), предназначен для наследования |
| **Вложенный класс**       | Класс, объявленный внутри другого класса. Может быть обычным или статическим                         |
| **Статический вложенный класс** | Вложенный класс с ключевым словом `static`. Не связан с экземпляром внешнего класса, может использоваться отдельно |
| **Локальный класс**       | Класс, объявленный внутри метода. Область видимости — только в этом методе                          |
| **Анонимный класс**       | Безымянный класс, который создаётся для реализации интерфейса или наследования класса один раз прямо при создании объекта |


#### Классы и методы: примеры и реализуемые методы

| Тип класса             | Назначение                                                                 | Примеры использования                                      | Особенности                                                                 |
|------------------------|----------------------------------------------------------------------------|------------------------------------------------------------|------------------------------------------------------------------------------|
| **POJO**               | Простой Java-объект без аннотаций и логики                                 | `User`, `Product`, `Address`                               | Без зависимостей, легко сериализуется                                        |
| **DTO (Data Transfer Object)** | Передача данных между слоями, особенно в API                          | `UserDTO`, `OrderDTO`, `LoginRequestDTO`                   | Часто используется с `@JsonProperty`, `@Builder`, `@Data`                   |
| **Entity**             | Отображение на таблицу БД, используется в ORM                              | `@Entity class User`, `@Entity class Order`                | Аннотации: `@Entity`, `@Id`, `@Column`, `@Table`                            |
| **VO (Value Object)**  | Представляет неизменяемые значения                                          | `MoneyVO`, `CoordinatesVO`, `DateRangeVO`                  | `final`, без сеттеров, с `equals()` и `hashCode()`                         |
| **Model**              | Общий термин, может включать POJO, Entity, DTO                             | `UserModel`, `ProductModel`                                | Часто используется в MVC или MVVM                                           |
| **Request/Response**   | Классы для REST-запросов и ответов                                         | `LoginRequest`, `LoginResponse`, `RegisterRequest`         | Удобны для сериализации JSON, часто с валидацией                            |
| **Service**            | Бизнес-логика приложения                                                    | `UserService`, `PaymentService`                            | Аннотация `@Service`, содержит методы обработки                             |
| **Controller**         | Обработка HTTP-запросов, точка входа API                                   | `UserController`, `AuthController`                         | Аннотация `@RestController`, `@RequestMapping`                              |
| **Repository**         | Доступ к данным, интерфейс для работы с БД                                 | `UserRepository extends JpaRepository<User, Long>`         | Аннотация `@Repository`, часто используется с Spring Data JPA               |
| **Mapper**             | Преобразование между DTO и Entity                                          | `UserMapper`, `OrderMapper`                                | Используется с MapStruct или вручную                                        |
| **Exception**          | Кастомные исключения                                                       | `UserNotFoundException`, `InvalidRequestException`         | Наследуются от `RuntimeException`, можно аннотировать `@ResponseStatus`    |
| **Utility / Helper**   | Вспомогательные методы, утилиты                                            | `DateUtils`, `ValidationHelper`, `JsonConverter`           | Статические методы, `final` класс, приватный конструктор                   |
| **Config**             | Конфигурационные классы                                                     | `WebSecurityConfig`, `SwaggerConfig`                       | Аннотация `@Configuration`, содержит `@Bean`                                |
| **Test Class**         | Классы для юнит- и интеграционных тестов                                   | `UserServiceTest`, `LoginControllerTest`                   | Используются с JUnit, Mockito, Espresso, Appium                             |

| Класс                 | Пример методов                            | Описание методов                                                |
|-----------------------|------------------------------------------|----------------------------------------------------------------|
| **`Object`**          | `equals()`, `hashCode()`, `toString()`, `clone()`, `finalize()` | Базовые методы, унаследованные всеми классами в Java. Отвечают за сравнение, хеширование, строковое представление, клонирование и очистку объектов. |
| **Пользовательский класс** | Геттеры и сеттеры (`getX()`, `setX()`), бизнес-логика, переопределение методов `toString()`, `equals()` и т.п. | Методы для управления состоянием объекта и реализации его поведения. |
| **Абстрактный класс**  | Абстрактные методы (без тела), например `abstract void move();`, и конкретные методы с реализацией | Определяют обязательные методы для подклассов и могут содержать общую логику. |
| **Вложенный класс**    | Методы, связанные с логикой внешнего класса, могут иметь доступ к его приватным полям               | Используются для группировки логически связанных классов, улучшая инкапсуляцию. |
| **Статический вложенный класс** | Методы и поля, которые не требуют экземпляра внешнего класса                                 | Могут использоваться без создания объекта внешнего класса, например вспомогательные утилиты. |
| **Локальный класс**    | Методы, работающие только внутри метода, где объявлен класс                                      | Используется для вспомогательной логики, ограниченной контекстом метода. |
| **Анонимный класс**    | Реализация интерфейсов или абстрактных классов с одним методом                                   | Используется для кратковременной реализации функциональности, часто в обработчиках событий или потоках. |


[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Основы компиляции <a id="основы-компиляции"></a>

**Что такое компиляция?**

Преобразование исходного кода Java в байт-код, исполняемый JVM.

**Основные этапы**

- Написание кода
- Компиляция через javac
- Запуск байт-кода на JVM

**Зачем нужна компиляция?**

Обеспечивает переносимость и безопасность программ.

**Инструменты**

- javac
- IDE (IntelliJ, Eclipse)
- Сборщики (Gradle, Maven)

**Ошибки компиляции**

Синтаксис, типы, отсутствие классов, видимость.

[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Структура Java-программы <a id="структура-java-программы"></a>

Основные элементы программы на Java:

- **Пакет (package)** — определяет пространство имён для класса.
- **Импорты (import)** — подключение внешних классов и библиотек.
- **Объявление класса** — основная единица кода, содержащая поля и методы.
- **Поля (переменные класса)** — хранят состояние объекта.
- **Методы** — описывают поведение класса.
- **Метод main** — точка входа, с которого начинается выполнение программы.
- **Комментарии** — пояснения в коде для разработчиков.

Структура строго регламентирована, с использованием фигурных скобок для блоков кода и правил оформления.

[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Порядок выполнения кода <a id="порядок-выполнения-кода"></a>

- JVM начинает выполнение с метода `main`.
- Сначала инициализируются статические блоки и статические поля класса.
- Затем создаются объекты, вызываются конструкторы.
- Методы выполняются в том порядке, в котором они вызываются.
- В процессе могут выполняться вложенные вызовы методов.
- По завершении работы программы JVM освобождает ресурсы.

[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Ключевые слова Java  <a id="ключевые-слова-java"></a>

| Ключевое слово | Категория             | Описание                                                                 |
|----------------|-----------------------|-------------------------------------------------------------------------|
| `abstract`     | ООП                   | Для абстрактных классов и методов                                      |
| `assert`       | Ошибки                | Проверка условий (обычно в тестах)                                     |
| `boolean`      | Типы данных           | Примитивный тип true/false                                             |
| `break`        | Управление потоком    | Выход из цикла/switch                                                  |
| `byte`         | Типы данных           | 8-битное целое число                                                   |
| `case`         | Управление потоком    | Вариант в switch                                                       |
| `catch`        | Исключения            | Обработка исключений                                                   |
| `char`         | Типы данных           | 16-битный Unicode-символ                                               |
| `class`        | ООП                   | Объявление класса                                                      |
| `const`        | (не используется)     | Зарезервировано                                                        |
| `continue`     | Управление потоком    | Переход к следующей итерации цикла                                     |
| `default`      | Управление потоком    | Дефолтный вариант в switch/interfaces                                  |
| `do`           | Управление потоком    | Цикл do-while                                                          |
| `double`       | Типы данных           | 64-битное число с плавающей точкой                                     |
| `else`         | Управление потоком    | Альтернативное условие в if                                            |
| `enum`         | ООП                   | Перечисляемый тип                                                      |
| `extends`      | ООП                   | Наследование класса                                                    |
| `final`        | Модификаторы          | Неизменяемые классы/методы/переменные                                  |
| `finally`      | Исключения            | Блок, выполняемый всегда после try-catch                               |
| `float`        | Типы данных           | 32-битное число с плавающей точкой                                     |
| `for`          | Управление потоком    | Цикл for                                                               |
| `goto`         | (не используется)     | Зарезервировано                                                        |
| `if`           | Управление потоком    | Условное выполнение                                                    |
| `implements`   | ООП                   | Реализация интерфейса                                                  |
| `import`       | Организация кода      | Импорт пакетов                                                         |
| `instanceof`   | ООП                   | Проверка типа объекта                                                  |
| `int`          | Типы данных           | 32-битное целое число                                                  |
| `interface`    | ООП                   | Объявление интерфейса                                                  |
| `long`         | Типы данных           | 64-битное целое число                                                  |
| `native`       | JVM                   | Метод, реализованный не на Java                                        |
| `new`          | ООП                   | Создание объекта                                                       |
| `package`      | Организация кода      | Объявление пакета                                                      |
| `private`      | Модификаторы доступа  | Доступ только внутри класса                                            |
| `protected`    | Модификаторы доступа  | Доступ внутри пакета + наследники                                      |
| `public`       | Модификаторы доступа  | Доступ отовсюду                                                        |
| `return`       | Управление потоком    | Возврат значения из метода                                             |
| `short`        | Типы данных           | 16-битное целое число                                                  |
| `static`       | Модификаторы          | Принадлежность классу (не объекту)                                     |
| `strictfp`     | Числа                 | Строгая арифметика с плавающей точкой                                  |
| `super`        | ООП                   | Ссылка на родительский класс                                           |
| `switch`       | Управление потоком    | Множественное ветвление                                                |
| `synchronized` | Многопоточность       | Потокобезопасный блок/метод                                            |
| `this`         | ООП                   | Ссылка на текущий объект                                               |
| `throw`        | Исключения            | Генерация исключения                                                   |
| `throws`       | Исключения            | Объявление возможных исключений                                        |
| `transient`    | Сериализация          | Поле не сериализуется                                                  |
| `try`          | Исключения            | Блок для перехвата исключений                                          |
| `var`          | Типы (Java 10+)       | Локальная переменная с выводом типа                                    |
| `void`         | Типы                  | Отсутствие возвращаемого значения                                      |
| `volatile`     | Многопоточность       | Гарантирует видимость изменений между потоками                         |
| `while`        | Управление потоком    | Цикл while                                                             |
| `_` (Java 9+)  | (запрещено)           | Зарезервировано для будущего использования                             |
| `yield`        | Управление (Java 13+) | Возврат значения в switch-expression                                   |
| `sealed`       | ООП (Java 17+)        | Ограниченное наследование (`permits`)                                  |
| `non-sealed`   | ООП (Java 17+)        | Снятие ограничений `sealed`                                            |
| `record`       | ООП (Java 16+)        | Неизменяемый класс данных                                              |
| `when`         | (в разработке)        | Возможное будущее ключевое слово для pattern matching                  |

[🔄 К содержанию - главы](#основы-java-2)  
[▶️ К содержанию](#content)

---

## 📗 Типы данных и переменные <a id="типы-данных-и-переменные"></a>

### 🔹 Примитивные и ссылочные типы <a id="примитивные-и-ссылочные-типы"></a>

- **Примитивные типы данных** - это базовые типы, которые хранят непосредственные значения. Они занимают фиксированный объем памяти и не имеют методов или свойств.

- **Ссылочные типы данных** - это типы, которые хранят ссылку на объект в памяти (в куче). Они позволяют работать с более сложными структурами данных, такими как классы, массивы, строки и интерфейсы.

#### Таблица основных типов

| Тип                 | Категория       | Размер (бит) | Диапазон/Описание                              |
|---------------------|-----------------|--------------|-----------------------------------------------|
| byte                | Примитивный     | 8            | -128 до 127                                   |
| short               | Примитивный     | 16           | -32768 до 32767                               |
| int                 | Примитивный     | 32           | -2^31 до 2^31-1                               |
| long                | Примитивный     | 64           | -2^63 до 2^63-1                               |
| float               | Примитивный     | 32           | Число с плавающей точкой                      |
| double              | Примитивный     | 64           | Число с плавающей точкой                      |
| char                | Примитивный     | 16           | Символ Unicode                                |
| boolean             | Примитивный     | -            | true или false                                |
| String              | Ссылочный      | -            | Последовательность символов                   |
| Классы              | Ссылочный      | -            | Пользовательские типы                         |
| Массивы             | Ссылочный      | -            | Коллекции элементов одного типа               |
| Интерфейсы          | Ссылочный      | -            | Абстрактные типы                              |

#### Характеристики примитивных и ссылочных типов

#### Примитивные типы:
- Занимают фиксированный объем памяти.
- Не имеют методов и свойств.
- Копируются по значению: при передаче переменной создается новая копия значения.
- Пример использования:
```java
int number = 10;
float pi = 3.14f;
char symbol = 'A';
boolean isTrue = true;
```

#### Ссылочные типы:
- Хранят ссылку на объект в куче (heap).
- Объекты могут быть изменены после создания.
- Копируются по ссылке: две переменные могут ссылаться на один и тот же объект.
- Пример использования:
```java
String message = "Hello, World!";
int[] numbers = {1, 2, 3, 4, 5};
List<String> list = new ArrayList<>();
list.add("Java");
```

#### Сравнение примитивных и ссылочных типов

| Характеристика         | Примитивные типы                     | Ссылочные типы                     |
|------------------------|--------------------------------------|------------------------------------|
| Хранение               | Значение хранится напрямую           | Хранится ссылка на объект          |
| Размер                 | Фиксированный                       | Может варьироваться               |
| Методы и свойства      | Отсутствуют                         | Наличие методов и свойств          |
| Копирование            | По значению                         | По ссылке                         |
| Пример                 | int, float, boolean                 | String, массивы, классы            |


[🔄 К содержанию - главы](#типы-данных-и-переменные-2)  
[▶️ К содержанию](#content)

---

### 🔹 Автоупаковка и распаковка <a id="автоупаковка-и-распаковка"></a>

1. **Автоупаковка (Autoboxing)**:
   - Процесс автоматического преобразования примитивных типов данных (например, `int`, `double`) в их обертки (например, `Integer`, `Double`).
   - Пример:
     ```java
     int primitive = 10;
     Integer wrapper = primitive; // Автоупаковка
     ```

2. **Распаковка (Unboxing)**:
   - Процесс автоматического преобразования оберток обратно в примитивные типы.
   - Пример:
     ```java
     Integer wrapper = 10;
     int primitive = wrapper; // Распаковка
     ```

3. **Преимущества**:
   - Упрощает работу с коллекциями, так как они принимают только объекты, а не примитивные типы.
   - Сокращает необходимость ручного преобразования между примитивами и их обертками.

4. **Ограничения**:
   - Может привести к непредвиденным ошибкам при работе с `null` значениями, например:
     ```java
     Integer value = null;
     int result = value; // NullPointerException
     ```

[🔄 К содержанию - главы](#типы-данных-и-переменные-2)  
[▶️ К содержанию](#content)

---

### 🔹 String и пул строк <a id="string-и-пул-строк"></a>

Строки в Java — объекты класса `String`, которые являются **неизменяемыми (immutable)**. После создания содержимое строки изменить нельзя.

#### Как создаётся строка

- **Через строковый литерал:**  
  `String s = "hello";`  
  Строка помещается в **пул строк**. Если такой литерал уже есть в пуле, ссылка будет на уже существующий объект.

- **Через конструктор:**  
  `String s = new String("hello");`  
  Создаётся новый объект в куче, **обходя пул строк**, даже если такой литерал уже есть.

#### Где хранятся строки и как устроена память

- **Пул строк** — специальная область памяти в **Metaspace** (с Java 8), где хранятся строковые литералы.  
- **Объекты `String`**, созданные через `new`, располагаются в куче (heap).  
- **Immutable** свойство позволяет безопасно использовать строки из пула в нескольких местах без копирования.

#### Почему важно это знать

- Использование строковых литералов экономит память за счёт переиспользования объектов.  
- Создание строк через **`new`** приводит к дополнительным расходам памяти и снижению производительности.  
- Для явного добавления строки в пул можно использовать метод **`intern()`**.

[🔄 К содержанию - главы](#типы-данных-и-переменные-2)  
[▶️ К содержанию](#content)

---

### 🔹 Call-by-value vs Call-by-reference <a id="call-by-value-vs-call-by-reference"></a>

В Java используется только **передача параметров по значению (call-by-value)**.

- Для **примитивных типов** передаётся копия значения. Изменения внутри метода не влияют на оригинал.
- Для **ссылочных типов** передаётся копия ссылки на объект, а не сам объект. Это значит, что внутри метода можно изменить состояние объекта по этой ссылке, но нельзя изменить саму ссылку, чтобы она указывала на другой объект.

В отличие от call-by-reference (передача ссылки на переменную), Java не позволяет менять ссылки на объекты в вызывающем коде.

[🔄 К содержанию - главы](#типы-данных-и-переменные-2)  
[▶️ К содержанию](#content)

---

### 🔹 Мутабельность и иммутабельность <a id="мутабельность-и-иммутабельность"></a>

#### 1. Мутабельные классы
#### Описание
**Мутабельные классы** — это классы, объекты которых можно изменять после их создания. То есть состояние объекта может меняться через методы класса.

#### Преимущества:
- Эффективное использование памяти, так как объект можно переиспользовать.
- Подходит для сценариев, где требуется частое изменение данных.

#### Недостатки:
- Может привести к ошибкам, если объект используется несколькими потоками одновременно.
- Сложнее использовать в многопоточных приложениях.

#### Пример мутабельного класса:
```java
// Класс StringBuilder является мутабельным
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World!"); // Изменяет исходный объект
System.out.println(sb); // Вывод: Hello World!
```
#### Таблица мутабельных классов в Java

| Класс                | Описание                                                                 |
|----------------------|--------------------------------------------------------------------------|
| `StringBuilder`      | Класс для создания и изменения строк. Позволяет добавлять, удалять и изменять символы без создания нового объекта. |
| `ArrayList`          | Динамический массив, который позволяет изменять размер коллекции и элементы внутри нее.                           |
| `HashMap`            | Коллекция, хранящая пары ключ-значение. Ключи и значения могут быть изменены после создания объекта.              |
| `HashSet`            | Коллекция, хранящая уникальные элементы. Элементы можно добавлять, удалять или заменять.                         |
| `LinkedList`         | Двусвязный список, поддерживающий динамическое изменение элементов и их порядка.                                |
| `Vector`             | Устаревший аналог `ArrayList`, но с синхронизированными методами. Разрешает изменения содержимого.               |
| `Stack`              | Реализация стека на основе `Vector`. Поддерживает операции добавления и удаления элементов.                     |
| `Properties`         | Подкласс `Hashtable`, используемый для работы с набором свойств. Может быть изменен во время выполнения.          |
| `GregorianCalendar`   | Класс для представления календарной даты и времени. Позволяет изменять поля даты и времени.                      |
| `DateFormat`         | Абстрактный класс для форматирования и анализа дат. Некоторые реализации (например, `SimpleDateFormat`) мутабельны.|
| `AtomicInteger`      | Класс для работы с целыми числами с поддержкой атомарных операций. Его значение может быть изменено.             |
| `AtomicLong`         | Аналогично `AtomicInteger`, но для длинных чисел. Значение объекта может меняться.                              |
| `ThreadLocalRandom`  | Генератор случайных чисел, который может изменять свое внутреннее состояние при каждом вызове методов.           |

#### 2. Иммутабельные классы
#### Описание
Иммутабельные классы — это классы, объекты которых нельзя изменить после их создания. Любое изменение создает новый объект.

#### Преимущества:
- Безопасность в многопоточных средах, так как объекты неизменяемы.
- Упрощение логики программы, так как состояние объекта известно заранее.
- Защита от несанкционированного изменения данных.

#### Недостатки:
- Может потреблять больше памяти, так как при каждом изменении создается новый объект.
- Меньшая производительность при частых изменениях.

#### Пример иммутабельного класса:
```java
// Класс String является иммутабельным
String str = "Hello";
str += " World!"; // Создает новый объект
System.out.println(str); // Вывод: Hello World!
```
#### Таблица иммутабельных классов в Java

| Класс                | Описание                                                                 |
|----------------------|--------------------------------------------------------------------------|
| `String`             | Класс для представления неизменяемых строк. Любая операция над строкой создает новый объект. |
| `Integer`            | Обертка над примитивным типом `int`. Значение объекта не может быть изменено после создания. |
| `Long`               | Обертка над примитивным типом `long`. Имеет фиксированное значение, которое нельзя изменить. |
| `Double`             | Обертка над примитивным типом `double`. После инициализации значение остается неизменным.   |
| `Float`              | Обертка над примитивным типом `float`. Является иммутабельной оболочкой для чисел с плавающей точкой. |
| `Character`          | Обертка над примитивным типом `char`. Значение символа не может быть изменено.              |
| `Boolean`            | Обертка над примитивным типом `boolean`. Состояние объекта (true/false) фиксировано.        |
| `BigDecimal`         | Класс для работы с десятичными числами высокой точности. Все операции создают новые объекты. |
| `BigInteger`         | Класс для работы с целыми числами произвольной длины. Неизменяемость гарантирует безопасность данных. |
| `UUID`               | Класс для уникальных идентификаторов. После создания UUID его значение остается постоянным.  |
| `Enum`               | Все перечисления (`enum`) в Java являются иммутабельными по умолчанию.                       |
| `ImmutableList`      | Коллекция из библиотеки Guava или других фреймворков, которая не позволяет модификацию содержимого. |
| `ImmutableMap`       | Иммутабельная реализация словаря, где пары ключ-значение остаются неизменными после создания.   |
| `ImmutableSet`       | Иммутабельная коллекция множеств, которая запрещает добавление, удаление или изменение элементов. |

#### Сравнение мутабельных и иммутабельных классов

| **Характеристика**         | **Мутабельные классы**                     | **Иммутабельные классы**                 |
|----------------------------|--------------------------------------------|------------------------------------------|
| **Изменяемость**           | Объект можно изменять                     | Объект нельзя изменять                   |
| **Память**                 | Более эффективное использование          | Может потреблять больше памяти           |
| **Безопасность потоков**   | Требует дополнительной синхронизации       | Безопасны для многопоточности             |
| **Примеры**                | `StringBuilder`, `ArrayList`              | `String`, `Integer`                      |

[🔄 К содержанию - главы](#типы-данных-и-переменные-2)  
[▶️ К содержанию](#content)

---

## 📙 Управление потоком выполнения <a id="управление-потоком-выполнения"></a>

### 🔸 Условные операторы <a id="условные-операторы"></a>

Условные операторы используются для выполнения различных блоков кода в зависимости от условия.

1. **if**:
   - Выполняет блок кода, если условие истинно.
   - Синтаксис:
     ```java
     if (условие) {
         // Код, который выполняется, если условие истинно
     }
     ```

2. **if-else**:
   - Выполняет один блок кода, если условие истинно, и другой блок, если ложно.
   - Синтаксис:
     ```java
     if (условие) {
         // Код, который выполняется, если условие истинно
     } else {
         // Код, который выполняется, если условие ложно
     }
     ```

3. **if-else if-else**:
   - Позволяет проверить несколько условий последовательно.
   - Синтаксис:
     ```java
     if (условие1) {
         // Код для условия1
     } else if (условие2) {
         // Код для условия2
     } else {
         // Код для остальных случаев
     }
     ```

4. **switch**:
   - Используется для выбора одного из нескольких вариантов на основе значения выражения.
   - Синтаксис:
     ```java
     switch (выражение) {
         case значение1:
             // Код для значения1
             break;
         case значение2:
             // Код для значения2
             break;
         default: // Блок default выполняется, если значение выражения не совпало ни с одним из case.
             // Код для остальных случаев
     }
     ```

[🔄 К содержанию - главы](#управление-потоком-выполнения-2)  
[▶️ К содержанию](#content)

---

### 🔸 Циклы <a id="циклы"></a>

Циклы используются для повторного выполнения блока кода несколько раз.

1. **for**:
   - Используется, когда известно количество итераций.
   - Синтаксис:
     ```java
     for (инициализация; условие; обновление) {
         // Код для выполнения
     }
     ```
   - Пример:
     ```java
     for (int i = 0; i < 5; i++) {
         System.out.println(i);
     }
     ```

2. **while**:
   - Выполняет блок кода, пока условие истинно.
   - Синтаксис:
     ```java
     while (условие) {
         // Код для выполнения
     }
     ```
   - Пример:
     ```java
     int i = 0;
     while (i < 5) {
         System.out.println(i);
         i++;
     }
     ```

3. **do-while**:
   - Похож на `while`, но гарантирует выполнение блока кода хотя бы один раз.
   - Синтаксис:
     ```java
     do {
         // Код для выполнения
     } while (условие);
     ```
   - Пример:
     ```java
     int i = 0;
     do {
         System.out.println(i);
         i++;
     } while (i < 5);
     ```

4. **for-each**:
   - Упрощенный вариант цикла `for` для перебора элементов коллекций или массивов.
   - Синтаксис:
     ```java
     for (тип элемента : коллекция) {
         // Код для выполнения
     }
     ```
   - Пример:
     ```java
     int[] numbers = {1, 2, 3, 4, 5};
     for (int number : numbers) {
         System.out.println(number);
     }
     ```

[🔄 К содержанию - главы](#управление-потоком-выполнения-2)  
[▶️ К содержанию](#content)

---

### 🔸 Операторы (+, ==, instanceof, new) <a id="операторы"></a>

- **+** — арифметический оператор сложения и конкатенации строк.
- **==** — оператор сравнения примитивов по значению и сравнения ссылок для объектов.
- **instanceof** — проверяет, является ли объект экземпляром указанного класса или его подкласса.
- **new** — оператор создания нового объекта в памяти (куче).

[🔄 К содержанию - главы](#управление-потоком-выполнения-2)  
[▶️ К содержанию](#content)

---

### 🔸 Управляющие конструкции (break, continue, return) <a id="управляющие-конструкции"></a>

- **break** — прерывает выполнение ближайшего цикла или оператора switch.
- **continue** — пропускает оставшуюся часть текущей итерации цикла и переходит к следующей.
- **return** — завершает выполнение метода и возвращает управление вызывающему коду (с возможным значением).

[🔄 К содержанию - главы](#управление-потоком-выполнения-2)  
[▶️ К содержанию](#content)

---

## 🟨 ООП в Java <a id="ооп-в-java"></a>

### 🔹 Принципы ООП <a id="принципы-ооп"></a>

**Принципы ООП (Объектно-Ориентированного Программирования)**

1. **Наследование**  
Позволяет создавать новый класс на основе уже существующего, наследуя его свойства и методы.  
(Пример: есть класс "Человек" с полом, возрастом и здоровьем. От него наследуется класс "Маг", который получает все характеристики человека и добавляет уникальные — магию.)  
В Java реализуется через ключевое слово `extends`.

2. **Инкапсуляция**  
Скрывает внутренние детали реализации объекта и предоставляет доступ только через методы.  
(Пример: у человека есть медицинская карта, но прямой доступ к ней закрыт — можно получить информацию только через врача.)  
В Java — использование модификаторов доступа `private`, `public`, геттеров и сеттеров.

3. **Полиморфизм**  
Один интерфейс — множество реализаций. Позволяет объектам разных классов обрабатываться одинаково.  
(Пример: разные виды транспорта — машина, велосипед, самолет — все могут ехать, но делают это по-своему.)  
В Java достигается через переопределение методов (`@Override`) и перегрузкой, интерфейсы.

4. **Абстракция**  
Выделение важных характеристик и сокрытие сложностей. Работает с абстрактными понятиями.  
(Пример: водитель знает, что нужно нажать на педаль газа, не вникая, как именно работает двигатель.)  
В Java — через абстрактные классы и интерфейсы.


[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Наследование <a id="наследование"></a>

Наследование — это механизм, при котором один класс (наследник) получает свойства и методы другого класса (родителя). Это позволяет создавать новые классы на основе уже существующих, повторно используя код и расширяя функциональность.

Пример из жизни: есть класс "Человек" с характеристиками пол, здоровье, возраст. От него наследуется класс "Маг", который получает все свойства человека и добавляет уникальные — например, способность к волшебству.

В Java наследование реализуется с помощью ключевого слова extends. Класс-наследник может использовать и переопределять методы родительского класса.

[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Переопределение и перегрузка <a id="переопределение-и-перегрузка"></a>

#### Переопределение (Override):
- **Определение**: Переопределение метода происходит, когда дочерний класс предоставляет свою реализацию метода, который уже определен в родительском классе.
- **Цель**: Позволяет изменить поведение метода для конкретного типа данных или класса.
- **Правила**:
  - Метод в дочернем классе должен иметь ту же сигнатуру (имя, типы параметров) и уровень доступа, что и в родительском классе.
  - Аннотация `@Override` используется для явного указания переопределения метода (рекомендуется для избежания ошибок).
- **Пример**: Если в родительском классе есть метод `display()`, то дочерний класс может переопределить его для вывода другой информации.

#### Перегрузка (Overload):
- **Определение**: Перегрузка метода означает создание нескольких методов с одним и тем же именем, но с разными параметрами (количеством, типами или порядком).
- **Цель**: Позволяет использовать одинаковое имя метода для выполнения разных операций в зависимости от входных параметров.
- **Правила**:
  - Сигнатуры методов должны различаться (разные типы или количество параметров).
  - Перегрузка может происходить как внутри одного класса, так и между родительским и дочерним классами.
- **Пример**: Метод `calculate(int a, int b)` может быть перегружен как `calculate(double a, double b)`.

**Сравнительная таблица: Переопределение vs Перегрузка**

| Критерий                | Переопределение (Override)                                           | Перегрузка (Overload)                                         |
|-------------------------|---------------------------------------------------------------------|--------------------------------------------------------------|
| **Определение**          | Изменение реализации метода в дочернем классе, сохраняя ту же сигнатуру. | Создание нескольких методов с одним и тем же именем, но разными параметрами. |
| **Цель**                | Изменить поведение метода для конкретного типа данных или класса.   | Предоставить разные варианты использования одного имени метода. |
| **Сигнатура метода**     | Должна быть одинаковой (имя и типы параметров).                      | Должна различаться (количество, типы или порядок параметров).  |
| **Уровень доступа**      | Уровень доступа в дочернем классе не может быть более строгим.       | Не влияет на перегрузку.                                      |
| **Аннотация**            | Используется аннотация `@Override` для явного указания переопределения. | Аннотация не требуется.                                       |
| **Место применения**     | Только между родительским и дочерним классами.                       | В пределах одного класса или между классами.                  |
| **Возвращаемый тип**     | Должен совпадать с типом возвращаемого значения родительского метода или быть его подтипом (covariant return type). | Может быть любым, так как это не влияет на перегрузку.        |
| **Пример**               | `class Parent { void display() {} }`<br>`class Child extends Parent { @Override void display() {} }` | `void calculate(int a, int b) {}`<br>`void calculate(double a, double b) {}` |

[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Интерфейсы и абстрактные классы <a id="интерфейсы-и-абстрактные-классы"></a>

#### Абстрактный класс:
- **Определение**: Абстрактный класс — это класс, который не предназначен для создания экземпляров напрямую. Он содержит абстрактные методы (без реализации) и/или обычные методы (с реализацией).
- **Использование**: Используется, когда нужно предоставить общую базовую функциональность для подклассов, а также задать контракт для обязательной реализации некоторых методов.
- **Особенности**:
  - Может содержать как абстрактные, так и конкретные методы.
  - Поддерживает наследование (одиночное наследование).
  - Может иметь состояния (поля), которые могут быть использованы подклассами.
- **Пример**: Базовый класс `Vehicle` может быть абстрактным, а подклассы `Car` и `Truck` будут реализовывать специфические методы.
    
**Мы можем создать объект абстрактного класса?**  
Нет  
  
#### Интерфейс:
- **Определение**: Интерфейс представляет собой полностью абстрактный тип, содержащий только объявления методов (до Java 8) или методы по умолчанию и статические методы (начиная с Java 8).  
**Методы по умолчанию**:  
Методы по умолчанию (default methods) появились в Java 8. Они позволяют добавлять реализацию методов в интерфейс без необходимости изменять классы, которые уже этот интерфейс реализуют. Такие методы определяются с помощью ключевого слова "default". Это позволяет добавлять новые методы в интерфейсы, сохраняя обратную совместимость.  
**Статические методы**:  
Статические методы в интерфейсах также появились в Java 8. Эти методы принадлежат самому интерфейсу, а не его экземплярам. Они определяются с использованием ключевого слова "static". Такие методы можно вызывать напрямую через имя интерфейса, и они используются для предоставления утилитарной функциональности, связанной с интерфейсом.  

- **Использование**: Используется для определения контракта, который должны реализовать классы. Это позволяет обеспечить полиморфизм без наследования.
- **Особенности**:
  - Начиная с Java 8, интерфейсы могут содержать методы по умолчанию (`default`) и статические методы.
  - Класс может реализовывать несколько интерфейсов (множественная "реализация").
  - Не может содержать состояния (поля), за исключением `final static` переменных.
- **Пример**: Интерфейс `Runnable` определяет метод `run()`, который должен быть реализован классами для выполнения потока.

| Характеристика   | Абстрактный класс                        | Интерфейс                                                |
|------------------|-----------------------------------------|---------------------------------------------------------|
| **Наследование**  | Одиночное наследование (`extends`)      | Множественная реализация (`implements`)                 |
| **Состояние**     | Может иметь обычные и статические поля  | Только `public static final` поля (константы)           |
| **Методы**        | Абстрактные и конкретные методы         | До Java 8: Только абстрактные методы. <br> Начиная с Java 8: Можно добавлять `default` и `static` методы. <br> Начиная с Java 9: Можно добавлять `private` методы. |
| **Конструкторы**  | Может иметь конструкторы                | Не может иметь конструкторов                             |
| **Когда использовать** | Когда требуется частичная реализация с возможностью переопределения в наследниках | Когда нужен только контракт (спецификация поведения)    |
| **Применение**    | Основные классы и структуры, требующие общего функционала | API, плагины, колбэки, стратегии (где важна гибкость и совместимость) |
| **Связанность**    | Сильная связанность (наследование) | Слабая связанность (разные реализации). |


[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Множественное наследование <a id="множественное-наследование"></a>

[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Ключевые концепции ООП <a id="ключевые-концепции-ооп"></a>

[🔄 К содержанию - главы](#ооп-в-java-2)  
[▶️ К содержанию](#content)

---

## 🔐 Модификаторы и область видимости <a id="модификаторы-и-область-видимости"></a>

### 🔸 Модификаторы доступа <a id="модификаторы-доступа"></a>

Модификаторы доступа в Java определяют, какой код может получить доступ к классам, методам, полям или конструкторам.

| Модификатор доступа | Уровень доступа                                                                                   |
|---------------------|---------------------------------------------------------------------------------------------------|
| **private**         |  Видно только внутри класса.           |
| **default**         | Видно только внутри пакета.                                        |
| **protected**       | Видно внутри класса + у наследников (extends). |
| **public**          | Видно всем, даже тебе🤭        |


1. **private**:
   - Доступен только внутри того же класса.
   - Используется для скрытия данных (инкапсуляция).

2. **default** (без модификатора):
   - Доступен только внутри пакета.
   - Не требует явного указания.

3. **protected**:
   - Доступен внутри пакета и во всех подклассах вне пакета.
   - Часто используется для методов, которые должны быть доступны дочерним классам.

4. **public**:
   - Доступен из любого места в программе.
   - Используется для открытых API и основных точек входа.

[🔄 К содержанию - главы](#модификаторы-и-область-видимости-2)  
[▶️ К содержанию](#content)

---

### 🔸 Ключевые слова: final, static, abstract <a id="ключевые-слова-final-static-abstract"></a>

**final**

| Применение | Описание                                                                 |
|------------|--------------------------------------------------------------------------|
| Поле       | Значение нельзя изменить после инициализации (константа).               |
| Метод      | Метод нельзя переопределить в подклассе.                                |
| Класс      | Класс нельзя наследовать.                                               |
| Локальная переменная | Нельзя изменить внутри метода после первого присваивания.    |

**static**

| Применение | Описание                                                                 |
|------------|--------------------------------------------------------------------------|
| Поле       | Общая переменная для всех экземпляров класса.                           |
| Метод      | Метод можно вызвать без создания объекта; не имеет доступа к this.      |
| Блок       | Статический блок инициализации выполняется при загрузке класса.         |
| Вложенный класс | Может существовать без экземпляра внешнего класса.               |

**abstract**

| Применение | Описание                                                                 |
|------------|--------------------------------------------------------------------------|
| Класс      | Не может быть создан напрямую; может содержать абстрактные методы.      |
| Метод      | Объявляется без тела; должен быть реализован в подклассе.               |
| Интерфейс  | Все методы интерфейса неявно абстрактные (до Java 8).                   |

[🔄 К содержанию - главы](#модификаторы-и-область-видимости-2)  
[▶️ К содержанию](#content)

---

### 🔸 Отличие final/finally/finalize <a id="отличие-final-finally-finalize"></a>

| Ключевое слово | Описание                                                                                   |
|----------------|--------------------------------------------------------------------------------------------|
| **`final`**    | - **Класс**: Запрещает наследование от этого класса.<br>                                   |
|                | - **Метод**: Запрещает переопределение метода в подклассах.<br>                           |
|                | - **Переменная**: Значение переменной становится неизменяемым после инициализации.         |
| **`finally`**  | Блок `finally` используется вместе с блоком `try-catch` для выполнения важного кода, который должен выполняться независимо от того, произошло исключение или нет. Пример: закрытие файлов, соединений с базами данных. |
| **`finalize`** | Метод `finalize()` вызывается перед сборкой мусора для выполнения очистки ресурсов. Не рекомендуется использовать, так как его поведение не гарантировано, и он был объявлен устаревшим начиная с Java 9. |


### `final`:
- **Класс**: Запрещает наследование от этого класса.
- **Метод**: Запрещает переопределение метода в подклассах.
- **Переменная**: Значение переменной становится неизменяемым после инициализации.

### `finally`:
- Блок `finally` используется вместе с блоком `try-catch` для выполнения важного кода, который должен выполняться независимо от того, произошло исключение или нет.
- Пример: закрытие файлов, соединений с базами данных.

### `finalize` (устаревший):
- Метод `finalize()` вызывается перед сборкой мусора для выполнения очистки ресурсов.
- Не рекомендуется использовать, так как его поведение не гарантировано, и он был объявлен устаревшим начиная с Java 9.

[🔄 К содержанию - главы](#модификаторы-и-область-видимости-2)  
[▶️ К содержанию](#content)

---

### 🔸 Область видимости переменных <a id="область-видимости-переменных"></a>

Область видимости определяет, где в программе переменная доступна.

| Тип переменной         | Где объявляется                        | Где доступна                                       |
|------------------------|----------------------------------------|----------------------------------------------------|
| **Локальная**          | Внутри метода или блока кода           | Только в пределах этого метода или блока           |
| **Параметр метода**    | В сигнатуре метода                     | Только внутри тела метода                          |
| **Поле экземпляра**    | Внутри класса, вне методов             | Доступно во всех нестатических методах класса      |
| **Статическое поле**   | Внутри класса с `static`               | Доступно в статических и нестатических методах     |
| **Блоковая (в for/if)**| Внутри блока `if`, `for`, `while` и т.п.| Только внутри этого блока                          |

[🔄 К содержанию - главы](#модификаторы-и-область-видимости-2)  
[▶️ К содержанию](#content)

---

## 🧨 Исключения и ошибки <a id="исключения-и-ошибки"></a>

### 🔹 Иерархия Throwable <a id="иерархия-throwable"></a>

[🔄 К содержанию - главы](#исключения-и-ошибки-2)  
[▶️ К содержанию](#content)

---

### 🔹 Checked vs Unchecked <a id="checked-vs-unchecked"></a>

[🔄 К содержанию - главы](#исключения-и-ошибки-2)  
[▶️ К содержанию](#content)

---

### 🔹 Обработка: try, catch, finally, throws <a id="обработка-исключений"></a>

#### 🔑 Ключевые слова

| Ключевое слово | Назначение                                                                                         |
|----------------|-----------------------------------------------------------------------------------------------------|
| `try`          | Определяет блок кода, в котором может возникнуть исключение                                        |
| `catch`        | Обрабатывает исключение, возникшее в `try`                                                         |
| `finally`      | Выполняется всегда после `try`/`catch`, независимо от наличия исключения                          |
| `throw`        | Явно выбрасывает исключение (одиночное использование внутри метода)                                |
| `throws`       | Объявляет, что метод может выбрасывать исключение — требует обработки на уровне вызова метода      |

#### 🔁 Комбинации использования

| Комбинация               | Описание                                                                                  |
|--------------------------|-------------------------------------------------------------------------------------------|
| `try` + `catch`          | Стандартная обработка исключений                                                         |
| `try` + `finally`        | Гарантированное выполнение финального кода (даже без `catch`)                            |
| `try` + `catch` + `finally` | Обработка + финальный блок, безопасный и гибкий способ                                   |
| `throw` внутри `try`     | Явная генерация исключения                                                               |
| `throws` в сигнатуре     | Указывает, что метод может выбросить исключение                                          |
| `throw` + `throws`       | Часто используются вместе: `throws` — в методе, `throw` — при генерации исключения       |

#### 🔄 Обработка нескольких исключений

1. **Множественные `catch` блоки:**

```java
try {
    // код
} catch (IOException e) {
    // обработка IO
} catch (SQLException e) {
    // обработка SQL
}
```

2. **Множественное исключение в одном `catch`:**

```java
try {
    // код
} catch (IOException | SQLException e) {
    // общая обработка
}
```
>При объединённом `catch`, переменная `e` будет `final` по умолчанию.

📌 Полезные замечания:

 - Используйте `finally` для закрытия ресурсов или освобождения памяти.
 - `throw` используется один раз для генерации конкретного исключения.
 - `throws` применяется в сигнатуре метода и может содержать список исключений через запятую.
 - `Checked` исключения (например, `IOException`) требуют `throws` или `try/catch`.
 - `Unchecked` (`RuntimeException`) — не требуют обязательной обработки, но могут быть перехвачены.

[🔄 К содержанию - главы](#исключения-и-ошибки-2)  
[▶️ К содержанию](#content)

---

### 🔹 Создание собственных исключений <a id="создание-собственных-исключений"></a>

| Шаг                    | Описание                                                                                   |
|------------------------|--------------------------------------------------------------------------------------------|
| 1. Наследование        | Создайте класс, унаследованный от `Exception` (checked) или `RuntimeException` (unchecked) |
| 2. Конструкторы        | Добавьте конструкторы: по умолчанию, с сообщением, с причиной (cause) и т.д.               |
| 3. Использование       | Генерируйте исключение через `throw new MyException(...)`                                  |
| 4. Обработка           | Обрабатывайте с помощью `try-catch` (если checked)                                         |

📌 Советы:
- Checked исключения заставляют явно обрабатывать ошибки (`throws`), подходят для контролируемых ситуаций.
- Unchecked (наследники `RuntimeException`) применяются для ошибок времени выполнения.
- Желательно добавлять в название класса суффикс `Exception` для читаемости (например, `InvalidInputException`).

Итог:  
Создание своих исключений улучшает читаемость и управление ошибками в коде.

[🔄 К содержанию - главы](#исключения-и-ошибки-2)  
[▶️ К содержанию](#content)

---

## 📚 Коллекции Java <a id="коллекции-java"></a>

### 🔸 List, Set, Map, Queue <a id="list-set-map-queue"></a>

 <img src="https://avatars.mds.yandex.net/i?id=c1caf0644d08d30c3ced60119f328f1e_l-5516535-images-thumbs&n=13" alt="Описание изображения" style="width: 75%; height: auto;">

#### Таблица иерархии коллекций в Java

| Интерфейс/Класс         | Описание                                                                 | Реализации / Примечания                                      |
|-------------------------|--------------------------------------------------------------------------|-------------------------------------------------------------|
| `Collection`            | Корневой интерфейс для всех коллекций (кроме `Map`).                     | Включает методы общего назначения: `add()`, `remove()`, `size()`. |
| **`List`**              | Упорядоченная коллекция с возможностью дублирования элементов.           |                                                              |
|   - `ArrayList`         | Базируется на массиве, быстрый доступ по индексу.                        | Не потокобезопасен.                                          |
|   - `LinkedList`        | Базируется на двусвязном списке, эффективен для вставки/удаления.        | Поддерживает работу как `Deque`.                             |
|   - `Vector`            | Синхронизированная версия `ArrayList`.                                  | Устаревшая, менее эффективна.                               |
|   - `Stack`             | Наследник `Vector`, реализует стек (LIFO).                              | Устаревшая, рекомендуется использовать `Deque`.             |
| **`Set`**               | Коллекция без дубликатов, не гарантирует порядок хранения.              |                                                              |
|   - `HashSet`           | Базируется на хеш-таблице, не сохраняет порядок.                         | Потоки могут вызывать неопределённое поведение.             |
|   - `LinkedHashSet`     | Сохраняет порядок вставки элементов.                                    | Использует связанный список внутри `HashSet`.               |
|   - `TreeSet`           | Автоматически сортирует элементы по их натуральному порядку или компаратору. | Реализовано на основе красно-черного дерева.                |
| **`Queue`**             | Коллекция для очередей, обычно работает по принципу FIFO (First In, First Out). |                                                              |
|   - `PriorityQueue`     | Хранит элементы в порядке их приоритета.                                 | Не поддерживает `null` и не гарантирует потокобезопасность. |
|   - `LinkedList`        | Может использоваться как очередь.                                        | Поддерживает работу как `Deque`.                             |
| **`Deque`**             | Двусторонняя очередь, позволяет добавление/удаление с обоих концов.       |                                                              |
|   - `ArrayDeque`        | Более эффективная реализация, основанная на массиве.                     | Рекомендуется вместо `LinkedList`.                          |
|   - `LinkedList`        | Также может использоваться как `Deque`.                                  | Менее эффективен, чем `ArrayDeque`.                         |
| **`Map`**               | Отображение ключ-значение, где ключи уникальны.                         |                                                              |
|   - `HashMap`           | Базируется на хеш-таблице, не гарантирует порядок.                      | Не потокобезопасен.                                          |
|   - `LinkedHashMap`     | Сохраняет порядок вставки пар ключ-значение.                            | Использует связанный список внутри `HashMap`.               |
|   - `TreeMap`           | Автоматически сортирует ключи по их натуральному порядку или компаратору.| Реализовано на основе красно-чёрного дерева.                 |
|   - `EnumMap`           | Специализированный `Map`, где ключи ограничены набором значений `enum`.  | Очень эффективен для работы с перечислениями.               |
| **Сортированные коллекции** | Расширения для автоматической сортировки.                              |                                                              |
|   - `SortedSet`         | Расширение `Set`, автоматически сортирует элементы.                     | Реализация: `TreeSet`.                                       |
|   - `NavigableSet`      | Расширение `SortedSet`, предоставляет дополнительные методы навигации.  | Реализация: `TreeSet`.                                       |
|   - `SortedMap`         | Расширение `Map`, автоматически сортирует ключи.                        | Реализация: `TreeMap`.                                       |
|   - `NavigableMap`      | Расширение `SortedMap`, предоставляет дополнительные методы навигации.  | Реализация: `TreeMap`.                                       |
| **Потокобезопасные коллекции** | Коллекции, безопасные для работы в многопоточной среде.               |                                                              |
|   - `Vector`            | Синхронизированная версия `ArrayList`.                                  | Устаревшая, менее эффективна.                               |
|   - `Stack`             | Синхронизированная версия стека.                                        | Устаревшая, рекомендуется использовать `Deque`.             |
|   - `ConcurrentHashMap` | Потокобезопасная реализация `Map`, более эффективная, чем синхронизация. | Используется в многопоточных приложениях.                   |
 
Java Collections Framework предоставляет набор интерфейсов и классов для работы с коллекциями данных

#### Основные интерфейсы:

- **Collection**: Базовый интерфейс для всех коллекций

- **List**: Упорядоченная коллекция с возможностью дублирования элементов
  ```java
  List<String> list = new ArrayList<>
  ```
- **Set**: Коллекция без дубликатов
  ```java
  Set<String> set = new HashSet<>
  ```
- **Queue**: Коллекция для очередей (FIFO)
  ```java
  Queue<String> queue = new LinkedList<>
  ```
#### Map:
Представляет набор ключ-значение

##### Основные реализации:

- **HashMap**: Хэш-таблица без гарантии порядка
  ```java
  Map<String, Integer> map = new HashMap<>
  ```
  
- **LinkedHashMap**: Сохраняет порядок вставки
  ```java
  Map<String, Integer> linkedMap = new LinkedHashMap<>
  ```
  
- **TreeMap**: Отсортированная по ключам коллекция
  ```java
  Map<String, Integer> treeMap = new TreeMap<>
  ```
  
#### Преимущества:
- Единый интерфейс для различных типов коллекций
- Гибкость выбора реализации в зависимости от задачи
- Поддержка потокобезопасных коллекций через Collections.synchronizedXXX()

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Методы для работы с коллекциями  <a id="методы-коллекции"></a>

#### 🧩 List, ArrayList, LinkedList

| Коллекция    | Метод                             | Описание                                 |
|--------------|-----------------------------------|------------------------------------------|
| List         | `get(int index)`                  | Получает элемент по индексу              |
|              | `set(int index, E element)`       | Заменяет элемент по индексу              |
|              | `indexOf(Object o)`               | Индекс первого вхождения                 |
|              | `lastIndexOf(Object o)`           | Индекс последнего вхождения              |
|              | `subList(int from, int to)`       | Возвращает подсписок                     |
| ArrayList    | `ensureCapacity(int minCap)`      | Увеличивает ёмкость списка               |
| LinkedList   | `addFirst(E e)`                   | Добавляет элемент в начало               |
|              | `addLast(E e)`                    | Добавляет элемент в конец                |
|              | `getFirst()`                      | Получает первый элемент                  |
|              | `getLast()`                       | Получает последний элемент               |

#### 🧮 Set, HashSet, TreeSet

| Коллекция    | Метод                             | Описание                                 |
|--------------|-----------------------------------|------------------------------------------|
| Set          | `add(E e)`                        | Добавляет элемент, если его нет          |
|              | `remove(Object o)`                | Удаляет элемент                          |
|              | `contains(Object o)`              | Проверяет наличие элемента               |
| HashSet      | `clone()`                         | Создаёт копию множества                  |
| TreeSet      | `first()`                         | Первый (наименьший) элемент              |
|              | `last()`                          | Последний (наибольший) элемент           |
|              | `higher(E e)`                     | Элемент строго больше заданного          |
|              | `lower(E e)`                      | Элемент строго меньше заданного          |

#### 🗂️ Map, HashMap, TreeMap

| Коллекция    | Метод                             | Описание                                 |
|--------------|-----------------------------------|------------------------------------------|
| Map          | `put(K key, V value)`             | Добавляет пару ключ-значение             |
|              | `get(Object key)`                 | Получает значение по ключу               |
|              | `remove(Object key)`              | Удаляет пару по ключу                    |
|              | `containsKey(Object key)`         | Проверяет наличие ключа                  |
|              | `containsValue(Object value)`     | Проверяет наличие значения               |
|              | `keySet()`                        | Возвращает множество ключей              |
|              | `values()`                        | Возвращает коллекцию значений            |
|              | `entrySet()`                      | Возвращает пары ключ-значение            |
| HashMap      | `compute(K key, BiFunction)`      | Обновляет значение по ключу              |
| TreeMap      | `firstEntry()`                    | Первая пара ключ-значение                |
|              | `lastEntry()`                     | Последняя пара ключ-значение             |

#### 🔁 Queue, Deque

| Коллекция    | Метод                             | Описание                                 |
|--------------|-----------------------------------|------------------------------------------|
| Queue        | `offer(E e)`                      | Добавляет элемент без исключения         |
|              | `poll()`                          | Удаляет и возвращает голову очереди      |
|              | `peek()`                          | Возвращает голову без удаления           |
| Deque        | `push(E e)`                       | Добавляет элемент в начало               |
|              | `pop()`                           | Удаляет и возвращает элемент из начала   |
|              | `descendingIterator()`            | Итератор в обратном порядке              |

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 ArrayList vs LinkedList <a id="arraylist-vs-linkedlist"></a>

| Свойство                  | ArrayList                                   | LinkedList                                  |
|---------------------------|---------------------------------------------|---------------------------------------------|
| **Структура**             | На основе массива                           | На основе двусвязного списка                |
| **Доступ по индексу**     | Быстрый (O(1))                              | Медленный (O(n))                            |
| **Вставка/удаление в середине** | Медленная (сдвиг элементов)              | Быстрая (перестройка ссылок)               |
| **Добавление в конец**    | Быстрое (если не требуется расширение)     | Быстрое                                     |
| **Память**                | Использует меньше памяти                    | Требует больше памяти (хранит ссылки)       |
| **Идеальное применение**  | Частый доступ по индексу                    | Частые вставки и удаления не в конце        |

Итог:  
`ArrayList` подходит для частого чтения и случайного доступа,  
`LinkedList` — для частых вставок/удалений в середине коллекции.

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 HashMap, TreeMap <a id="hashmap-treemap"></a>

| Свойство              | HashMap                                     | TreeMap                                        |
|-----------------------|----------------------------------------------|------------------------------------------------|
| **Структура**         | Хэш-таблица                                  | Красно-чёрное дерево                           |
| **Порядок элементов** | Не гарантируется                             | Сортировка по ключу (естественный порядок или Comparator) |
| **Скорость операций** | Быстрая: O(1) для `get()` и `put()`         | Медленнее: O(log n)                            |
| **Null-ключ**         | Допускается один `null`-ключ                 | `null`-ключ не допускается                     |
| **Применение**        | Когда важна скорость                         | Когда нужен упорядоченный доступ               |

Итог:  
`HashMap` — для быстрого доступа без порядка,  
`TreeMap` — для сортированных коллекций с упорядоченным обходом ключей.

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Iterable, Iterator <a id="iterable-iterator"></a>

| Интерфейс   | Назначение                                              |
|-------------|----------------------------------------------------------|
| **Iterable** | Обозначает, что коллекция может быть пройдена в цикле `for-each`. Содержит метод `iterator()` |
| **Iterator** | Позволяет последовательно перебирать элементы. Методы: `hasNext()`, `next()`, `remove()` |

**Использование:**
- `Iterable` — реализуется коллекциями (`List`, `Set`, `Queue`), чтобы поддерживать `for-each`.
- `Iterator` — создаётся вызовом `iterator()` и используется для ручного перебора элементов, в том числе с возможностью удаления.

Итог:  
`Iterable` — интерфейс для итерации,  
`Iterator` — инструмент пошагового перебора коллекций.

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Collections utility methods <a id="collections-utility-methods"></a>

Класс `java.util.Collections` предоставляет статические методы для работы с коллекциями.

| Метод                         | Назначение                                                        |
|------------------------------|-------------------------------------------------------------------|
| `sort(List)`                 | Сортировка списка по естественному порядку                        |
| `reverse(List)`              | Обратный порядок элементов списка                                 |
| `shuffle(List)`              | Перемешивает элементы случайным образом                           |
| `min(Collection)`            | Возвращает минимальный элемент                                    |
| `max(Collection)`            | Возвращает максимальный элемент                                   |
| `frequency(Collection, obj)`| Подсчитывает количество вхождений объекта                         |
| `singletonList(obj)`        | Возвращает неизменяемый список с одним элементом                  |
| `unmodifiableList(List)`    | Создаёт неизменяемый список                                       |
| `synchronizedList(List)`    | Возвращает потокобезопасную версию списка                         |

Итог:  
Методы `Collections` удобны для повседневных операций с коллекциями: сортировки, преобразования и безопасного доступа.

#### Базовые методы коллекций

| Метод             | Интерфейс       | Назначение                                                                 |
|------------------|------------------|----------------------------------------------------------------------------|
| `add(E e)`       | Collection       | Добавить элемент                                                           |
| `remove(Object o)` | Collection     | Удалить элемент (первое вхождение)                                         |
| `clear()`         | Collection       | Удалить все элементы                                                       |
| `contains(Object o)` | Collection   | Проверка, содержит ли коллекция элемент                                    |
| `size()`          | Collection       | Возвращает количество элементов                                            |
| `isEmpty()`       | Collection       | Проверяет, пуста ли коллекция                                              |
| `get(int index)`  | List             | Получить элемент по индексу                                                |
| `set(int index, E e)` | List        | Заменить элемент по индексу                                                |
| `put(K key, V val)` | Map            | Добавить/обновить пару ключ-значение                                       |
| `remove(K key)`   | Map              | Удалить по ключу                                                           |
| `keySet()`        | Map              | Получить множество всех ключей                                             |
| `values()`        | Map              | Получить коллекцию всех значений                                           |

Итог:  
Эти методы определяются в интерфейсах коллекций (`Collection`, `List`, `Map`, `Set`, и др.) и используются для прямого управления содержимым коллекций.

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Stack, Queue, Deque <a id="stack-queue-deque"></a>

| Структура | Метод                  | Что делает                                                            |  
|-----------|------------------------|------------------------------------------------------------------------|  
| **Stack** | `push(E item)`         | Помещает элемент на вершину стека                                     |  
|           | `pop()`                | Удаляет и возвращает верхний элемент стека                            |  
|           | `peek()`               | Возвращает верхний элемент, не удаляя его                             |  
|           | `empty()`              | Проверяет, пуст ли стек                                               |  
| **Queue** | `offer(E item)`        | Добавляет элемент в очередь (предпочтительнее `add()`, не бросает исключение при неудаче) |  
|           | `poll()`               | Удаляет и возвращает первый элемент очереди; возвращает `null`, если очередь пуста        |  
|           | `peek()`               | Возвращает первый элемент без удаления; `null`, если очередь пуста                        |  
| **Deque** | `addFirst(E e)`        | Добавляет элемент в начало двусторонней очереди                                            |  
|           | `addLast(E e)`         | Добавляет элемент в конец                                                                  |  
|           | `removeFirst()`        | Удаляет и возвращает первый элемент                                                        |  
|           | `removeLast()`         | Удаляет и возвращает последний элемент                                                     |  
|           | `peekFirst()`          | Возвращает первый элемент без удаления                                                     |  
|           | `peekLast()`           | Возвращает последний элемент без удаления                                                  |  
|           | `offerFirst(E e)`      | Безопасно добавляет в начало (не бросает исключение при переполнении)                     |  
|           | `offerLast(E e)`       | Безопасно добавляет в конец                                                                |  
|           | `pollFirst()`          | Безопасно удаляет и возвращает первый элемент (или `null`, если пусто)                     |  
|           | `pollLast()`           | Безопасно удаляет и возвращает последний элемент                                           |  

📌 **Примечания:**
- `Stack` — старый класс, реализует LIFO, но в современных проектах предпочтительнее `Deque`.
- `Queue` — для FIFO логики, используется в задачах обработки событий, очередей задач.
- `Deque` — универсальная структура: может работать как `Stack` (LIFO) или как `Queue` (FIFO).

Итог:  
- Если нужно использовать стек — выбирай `Deque` (`ArrayDeque`).
- Для очередей — `Queue` (`LinkedList`, `ArrayDeque`, `PriorityQueue`).
- `Deque` удобен при работе с двумя концами коллекции.

[🔄 К содержанию - главы](#коллекции-java-2)  
[▶️ К содержанию](#content)

---

## 🧮 Структуры данных и алгоритмы <a id="структуры-данных-и-алгоритмы"></a>

### 🔹 Очереди и стеки <a id="очереди-и-стеки"></a>

| Структура данных | Принцип работы | Описание                                                         | Примеры использования                       |
|------------------|----------------|------------------------------------------------------------------|---------------------------------------------|
| **Стек (Stack)** | LIFO           | Последний пришёл — первый ушёл. Добавление и удаление с одного конца | Обработка вызовов методов (Call Stack), отмена действий |
| **Очередь (Queue)** | FIFO         | Первый пришёл — первый ушёл. Добавление в конец, удаление из начала | Очереди задач, буферы сообщений             |
| **Дек (Deque)**  | Обе стороны     | Двусторонняя очередь. Элементы можно добавлять и удалять с обоих концов | Стек или очередь в одной структуре         |

| Класс/Интерфейс     | Особенности                                                    |
|---------------------|----------------------------------------------------------------|
| `Stack`             | Устаревший класс. Использует методы `push`, `pop`, `peek`     |
| `Queue`             | Интерфейс. Реализации: `LinkedList`, `PriorityQueue` и др.    |
| `Deque`             | Универсален. Рекомендуется вместо `Stack`. Реализации: `ArrayDeque`, `LinkedList` |

Итог:  
- **Stack** — не рекомендуется, лучше использовать `Deque`.
- **Queue** — основа для FIFO-структур.
- **Deque** — гибкое решение для обеих логик: FIFO и LIFO.

[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

### 🔹 Классы, интерфейсы - обьекты java  <a id="классы-обьекты-java"></a>

#### Класс  
Класс — шаблон для создания объектов, описывает состояние и поведение.  

**Виды классов:**  
- Обычный (`class`) - Базовый класс, который может быть унаследован (если не `final`) и инстанцирован.
- Абстрактный (`abstract`) - Нельзя создать объект напрямую, только через наследников. Может содержать абстрактные методы (без реализации).
- Финальный (`final`) - Запрещает наследование. Все методы неявно `final` (нельзя переопределить).
- Запечатанный (`sealed`, - `sealed` — класс, который явно разрешает наследование определенным классам.
               `non-sealed`) - `non-sealed` — потомок `sealed`, который снимает ограничения на наследование.
- Вложенный (`static nested`) - Статический класс внутри другого класса. Не имеет доступа к нестатическим полям внешнего класса.
- Внутренний (`inner`) - Нестатический класс внутри другого класса. Имеет доступ к полям внешнего класса, даже приватным.
- Локальный (`local`) - Класс, объявленный внутри метода или блока кода. Виден только в этой области. 
- Анонимный (`anonymous`) - Класс без имени, создается "на лету" при объявлении (часто для переопределения методов интерфейса или абстрактного класса).

#### Интерфейс  
Интерфейс — контракт, определяющий методы и константы, которые должны быть реализованы.  

**Виды интерфейсов:**  
- Обычный (`interface`) -  Контракт с методами (абстрактными, `default`, `static`) и константами.
- Функциональный (`@FunctionalInterface`) -  Только один абстрактный метод, работает с лямбдами.  
- Маркерный - Пустой интерфейс, указывает на особенность класса (например, `Serializable`).
- Запечатанный (`sealed`) - Ограничивает реализацию указанными классами (`permits`).

#### Метод  
Метод — функция внутри класса или интерфейса, описывающая поведение.  

**Виды методов:**  
- Экземплярный - Обычный метод, вызывается у объекта, имеет доступ к его полям.
- Статический (`static`) - Принадлежит классу, а не объекту, вызывается через `ClassName.method()`. 
- Абстрактный (`abstract`) -  Без реализации, должен быть переопределён в наследнике. 
- Финальный (`final`) -  Нельзя переопределить в подклассах.
- Синхронизированный (`synchronized`) - Гарантирует потокобезопасность (блокировка на объекте/классе).
- Дефолтный (`default`) - Реализация в интерфейсе (с Java 8), чтобы не ломать старый код.
- Приватный в интерфейсе (`private`) - Вспомогательный метод внутри интерфейса (с Java 9).  
- Перегруженный (Overloading) - Несколько методов с одним именем, но разными параметрами.
- Переопределённый (Overriding) - Подкласс изменяет логику метода родителя (`@Override`). 

#### Поле  
Поле — переменная, принадлежащая классу или объекту.  

**Виды полей:**  
- Экземплярное - Принадлежит объекту класса, существует пока жив объект, у каждого экземпляра — своя копия.  
- Статическое (`static`) - Принадлежит самому классу, общее для всех экземпляров, существует с момента загрузки класса.  
- Константа (`static final`) - Неизменяемое статическое поле, объявляется с обязательной инициализацией (например, `public static final int MAX_SIZE = 100`) 
- Транзиентное (`transient`) - Исключается из сериализации (не сохраняется при записи объекта в поток).  
- Волатильное (`volatile`) - Гарантирует видимость изменений между потоками (чтение/запись идет напрямую в основную память, минуя кэш CPU).

#### Конструктор  
Конструктор — специальный метод для инициализации объекта.  

**Виды конструкторов:**  
- Обычный - Базовый конструктор класса, имеет то же имя, что и класс, может принимать параметры.  
- Перегруженный - Несколько конструкторов с разными параметрами в одном классе (разная сигнатура).
- Приватный - Запрещает создание объектов извне (используется в Singleton или утилитных классах).  
- С вызовом `this()` - Вызывает другой конструктор **этого же класса** (должен быть первой инструкцией). 
- С вызовом `super()` - Вызывает конструктор **родительского класса** (неявно добавляется, если нет явного вызова).  

#### Блоки инициализации  
Блоки кода, выполняемые до использования класса или объекта.  

**Виды:**  
- Экземплярный - Выполняется **при каждом создании** объекта перед конструктором, используется для общей инициализации экземпляров.
- Статический (`static`) - Выполняется **один раз при загрузке класса**, используется для инициализации статических полей.  

#### Перечисление  
Перечисление (`enum`) — тип с фиксированным набором значений.  

#### Запись  
Запись (`record`) — неизменяемый класс-носитель данных.  

#### Пакет  
Пакет (`package`) — пространство имён для группировки классов и интерфейсов.  

#### Модуль  
Модуль (`module`) — единица модульной системы Java (Java 9+), описывает зависимости и экспортируемые пакеты.  

#### Аннотация  
Аннотация (`@Annotation`) — метаданные для классов, методов, полей и других элементов.  

**Виды аннотаций:**  
- Маркерная  
- С параметрами  
- Повторяемая (`@Repeatable`)  
- Мета-аннотации (`@Retention`, `@Target`, `@Inherited`, `@Documented`)  

#### Обобщения  
Обобщения (Generics) — механизм параметризации типов.  

#### Исключения  
Исключения — механизм обработки ошибок во время выполнения.  

**Виды:**  
- Проверяемые (`checked`)  
- Непроверяемые (`unchecked`)  
- Ошибки (`Error`)  

#### Лямбда-выражения  
Лямбда-выражения — краткая форма записи анонимных функций.  

#### Ссылки на методы  
Ссылки на методы — передача ссылки на существующий метод или конструктор.  

#### Объекты Java (дополнительно)  
- Массивы (`[]`)  
- Класс-обёртка (`Integer`, `Double`, и т.д.)  
- Строки (`String`)  
- Коллекции (`List`, `Set`, `Map`)  
- Потоки (`Stream`)  
- Пакеты `java.lang`, `java.util`, `java.io`, `java.net`, `java.time` и др.  


[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

### 🔹 Хэш-таблицы <a id="хэш-таблицы"></a>

| Понятие            | Описание                                                                 |
|--------------------|--------------------------------------------------------------------------|
| **Хэш-таблица**     | Структура данных, где пары ключ–значение хранятся в виде массива "бакетов" |
| **Хэш-функция**     | Преобразует ключ в индекс бакета, где будет храниться значение           |
| **Коллизия**        | Когда два ключа дают одинаковый хэш — решается цепочками или открытой адресацией |
| **Бакет (bucket)**  | Слот (ячейка) в массиве, в котором могут храниться одна или несколько записей |
| **Load factor**     | Коэффициент заполнения, после которого происходит расширение таблицы     |

| Класс       | Особенности                                                           |
|-------------|------------------------------------------------------------------------|
| `HashMap`   | Основан на хэш-таблице, допускает `null`-ключ, не гарантирует порядок |
| `Hashtable` | Потокобезопасный, но устаревший                                        |
| `LinkedHashMap` | Сохраняет порядок вставки                                         |
| `ConcurrentHashMap` | Потокобезопасный и производительный                           |

📌 Примечания:
- В `HashMap` используется метод `hashCode()` для расчёта индекса и `equals()` для сравнения ключей.
- Коллизии в `HashMap` обрабатываются с помощью связного списка или дерева (`TreeNode` при глубине > 8).
- Размер таблицы автоматически увеличивается при превышении load factor (по умолчанию 0.75).

Итог:  
`HashMap` — основной выбор для хранения ключ–значение, если не требуется порядок или потокобезопасность.

[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

### 🔹 Списки <a id="списки"></a>

| Тип списка        | Описание                                                                 | Особенности                                          |
|-------------------|--------------------------------------------------------------------------|------------------------------------------------------|
| **ArrayList**     | Основан на массиве. Быстрый доступ по индексу, но медленное добавление/удаление в середине | Подходит для чтения и редкого изменения             |
| **LinkedList**    | Двусвязный список. Быстро вставляет/удаляет элементы в любом месте, но медленный доступ по индексу | Эффективен при частых изменениях структуры списка   |
| **Vector**        | Устаревший потокобезопасный список                                       | Используется редко, замена — `Collections.synchronizedList()` |
| **CopyOnWriteArrayList** | Потокобезопасный, но ресурсоёмкий. Каждый раз создаёт копию массива | Подходит для многопоточности при преобладании чтения |

| Интерфейс     | Назначение                                                 |
|---------------|------------------------------------------------------------|
| `List`        | Основной интерфейс для работы с упорядоченными коллекциями |
| `RandomAccess`| Интерфейс-маркер, указывающий, что коллекция поддерживает быстрый доступ по индексу |

📌 Примечания:
- Методы `add()`, `remove()`, `get(int index)` и `set()` — основные при работе со списками.
- `ArrayList` имеет амортизированную сложность вставки — `O(1)` при добавлении в конец.
- `LinkedList` экономит на перемещении данных, но требует больше памяти из-за хранения связей.

Итог:  
Выбор между `ArrayList` и `LinkedList` зависит от частоты доступа к элементам и частоты изменений.

[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

### 🔹 Сортировка (Arrays.sort, Comparator) <a id="сортировка"></a>

| Метод                  | Описание                                                                                   |
|------------------------|--------------------------------------------------------------------------------------------|
| `Arrays.sort()`        | Статический метод для сортировки массивов примитивов и объектов (через `Comparable`)       |
| `Collections.sort()`   | Для сортировки списков, использует `Comparable` или `Comparator`                           |
| `Comparable<T>`        | Интерфейс, реализующий естественный порядок объектов. Метод `compareTo(T o)`               |
| `Comparator<T>`        | Интерфейс для задания внешнего порядка. Метод `compare(T o1, T o2)`                        |

📌 Основные моменты:  
- Объекты должны реализовывать `Comparable` для естественного порядка.  
- `Comparator` позволяет создавать разные варианты сортировки без изменения класса.  
- Java 8+ поддерживает лямбды для краткой записи компараторов.  
- Алгоритмы сортировки оптимизированы, обычно используют модифицированный Timsort.

Итог:  
Используйте `Comparable` для естественного порядка, `Comparator` — для гибкой сортировки по разным критериям.

[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

### 🔹 Поиск, бинарный поиск <a id="поиск"></a>

#### 🔍 Виды поиска

| Метод поиска        | Описание                                                                 |
|---------------------|--------------------------------------------------------------------------|
| Последовательный    | Поиск по массиву/списку от начала до конца. Работает с неотсортированными данными. |
| Бинарный поиск      | Эффективный поиск **в отсортированном массиве** — деление пополам и отбрасывание лишнего. |
| Поиск по ключу      | Используется в `Map`, где элементы доступны по ключу. Быстрое извлечение через хэш или дерево. |

#### 📐 Особенности бинарного поиска

- Работает **только с отсортированными** структурами (`int[]`, `List`, `ArrayList` и т.д.).
- Сложность: **O(log n)**.
- Делит массив пополам, сравнивает значение, сужает диапазон поиска.
- В Java есть метод: `Arrays.binarySearch(array, value)`.

#### 🔧 Когда использовать

| Условие                                      | Подходящий метод       |
|----------------------------------------------|-------------------------|
| Дан отсортированный массив                   | Бинарный поиск          |
| Неотсортированный небольшой список           | Последовательный поиск  |
| Частые операции `put/get` по ключу           | `HashMap` или `TreeMap` |

📌 Итого:  
Бинарный поиск — мощный инструмент, но требует предварительной сортировки. В коллекциях типа `Map` поиск реализован через хеширование или деревья.

[🔄 К содержанию - главы](#структуры-данных-и-алгоритмы-2)  
[▶️ К содержанию](#content)

---

## 🌀 Обобщения (Generics) <a id="обобщения-generics"></a>

### 🔸 Обобщённые классы и методы <a id="обобщённые-классы-и-методы"></a>

#### 📦 Что такое обобщения (Generics)

Обобщения позволяют писать универсальный код, который работает с разными типами, сохраняя **типовую безопасность** и **переиспользуемость**.

#### 🧱 Обобщённый класс

Класс, который принимает тип-параметр при создании объекта:

`class Box<T> { T value; }`

Пример использования:

`Box<String> stringBox = new Box<>();`

#### 🧩 Обобщённый метод

Метод, который принимает тип-параметр только в своей области:

```java
public <T> void print(T item) {
    System.out.println(item);
}
```

[🔄 К содержанию - главы](#обобщения-generics-2)  
[▶️ К содержанию](#content)

---

### 🔸 Ограничения: extends, super <a id="ограничения-extends-super"></a>

#### 🔐 Зачем нужны ограничения

Ограничения (`extends` и `super`) позволяют управлять тем, **какие типы могут использоваться** в обобщениях. Это важно для безопасной работы с данными.

#### 🔼 `extends` — верхняя граница

`<? extends Type>` — принимает `Type` **или любой его подкласс**.

- Используется для **чтения** данных (get).
- Пример: `List<? extends Number>` — `Integer`, `Double` и т.д.

📌 Запись: **"Producer Extends"** — если из коллекции **читаем**, используем `extends`.

#### 🔽 `super` — нижняя граница

`<? super Type>` — принимает `Type` **или любой его родитель**.

- Используется для **записи** данных (add).
- Пример: `List<? super Integer>` — `Integer`, `Number`, `Object`.

📌 Запись: **"Consumer Super"** — если в коллекцию **пишем**, используем `super`.

#### 📌 Таблица применения PECS

| Ситуация        | Что используем     | Пример                      |
|----------------|--------------------|-----------------------------|
| Только читаем   | `? extends T`       | `List<? extends Animal>`     |
| Только записываем | `? super T`         | `List<? super Dog>`           |

📝 Итог:  
`extends` — для безопасного чтения, `super` — для безопасной записи. Правило **PECS**: *Producer Extends, Consumer Super*.

[🔄 К содержанию - главы](#обобщения-generics-2)  
[▶️ К содержанию](#content)

---

### 🔸 Wildcards <a id="wildcards"></a>

#### ❔ Что такое wildcard (`?`)

`?` — это подстановочный символ (wildcard) в Generics, обозначает **некоторый неизвестный тип**.

#### 📌 Виды wildcard-ограничений

| Синтаксис             | Значение                                             | Используется для             |
|-----------------------|------------------------------------------------------|------------------------------|
| `<?>`                 | Любой тип                                            | Только чтение, без записи    |
| `<? extends T>`       | `T` и его подклассы                                  | Чтение из структуры          |
| `<? super T>`         | `T` и его суперклассы                                | Запись в структуру           |

#### 🧪 Примеры

- `List<?>` — список с элементами неизвестного типа. Можно читать, нельзя писать.
- `List<? extends Number>` — список чисел (`Integer`, `Double`, ...). Читаем как `Number`.
- `List<? super Integer>` — можно безопасно добавить `Integer`, но читать только как `Object`.

#### ❗ Особенности

- Нельзя использовать `add()` в `List<? extends T>`, кроме `null`.
- Можно использовать `add()` в `List<? super T>`, но только объекты `T` и его подклассов.
- Wildcards **не применимы** при объявлении обобщённых классов/методов (`class Box<?>` — ❌).

📝 Итог:  
Wildcards дают гибкость при работе с обобщениями, когда точный тип неизвестен. Используем `extends` для **чтения**, `super` для **записи**.

[🔄 К содержанию - главы](#обобщения-generics-2)  
[▶️ К содержанию](#content)

---

### 🔸 Raw types <a id="raw-types"></a>

#### ❔ Что такое raw type?

**Raw type** — это использование обобщённого класса или интерфейса **без указания типа**.

Пример:
```java
List list = new ArrayList(); // raw type
```

🚫 Пример проблемы
```java
List list = new ArrayList();
list.add("Hello");
Integer num = (Integer) list.get(0); // Ошибка во время выполнения!
```

📌 Минусы использования raw types:

- Потеря типобезопасности — компилятор не может проверить типы.
- Повышенный риск `ClassCastException` во время выполнения.
- Отсутствие автодополнения и подсказок в IDE.
- Нельзя использовать преимущества дженериков, таких как ограничения `extends/super`.

✅ Когда допустимо:
- При работе с устаревшими библиотеками, которые не используют дженерики.
- При необходимости совместимости со старым кодом (Java 1.4 и ниже).

📝 Вывод:  
Raw types считаются устаревшими и **не рекомендуются** к использованию в современном Java-коде. Лучше всегда явно указывать тип: `List<String>`, `Map<Integer, String>` и т.д.

[🔄 К содержанию - главы](#обобщения-generics-2)  
[▶️ К содержанию](#content)

---

### 🔸 Type erasure <a id="type-erasure"></a>

❔ Что такое Type Erasure?  
Type Erasure (стирание типов) — это механизм, с помощью которого Java удаляет информацию о типах во время компиляции.

📌 Зачем это нужно:  
Generics в Java реализованы на уровне компилятора для обратной совместимости со старым кодом (до Java 5). JVM не знает о параметрах типов — они «стираются».

🧩 Как это работает:

- Все параметры типов заменяются их ограничениями (`extends`) или `Object`, если ограничений нет.
- Перегрузка методов с разными параметрами дженериков невозможна.
- Проверка типа во время выполнения невозможна: нельзя написать `if (obj instanceof List<String>)`.

📌 Последствия:

- Нельзя использовать обобщённые типы в `instanceof`.
- Нельзя создать массив обобщённых типов: `new List<String>[10]` — ошибка.
- Доступ к параметру типа во время выполнения невозможен.

📝 Вывод:  
Type Erasure — это компромисс между безопасностью типов на этапе компиляции и совместимостью со старой JVM. Он накладывает ограничения, но позволяет использовать Generics в языке без изменения виртуальной машины.

[🔄 К содержанию - главы](#обобщения-generics-2)  
[▶️ К содержанию](#content)

---

## 🚀 Современные фичи Java <a id="современные-фичи-java"></a>

### 🔹 Лямбда-выражения <a id="лямбда-выражения"></a>

**Лямбда-выражения** — это механизм, позволяющий представлять **анонимные функции** в Java. Они были введены в язык программирования начиная с версии 8 и служат для передачи логики как параметра без необходимости создавать полноценные классы или анонимные внутренние классы.

**Анонимные функции** — это функции без имени, которые можно использовать для передачи логики в качестве аргумента или создания временных блоков кода.  

Основная цель лямбда-выражений — упростить код, сделать его более компактным и читаемым, особенно при работе с функциональными интерфейсами и API потоков (Stream API).

#### Ключевые характеристики

1. **Функциональные интерфейсы**  
   Лямбда-выражения могут использоваться только с функциональными интерфейсами — интерфейсами, которые содержат ровно один абстрактный метод. Например, `Runnable`, `Callable`, `Predicate`, `Consumer` и другие.

2. **Типизация**  
   Лямбда-выражения являются строго типизированными. Тип лямбды определяется контекстом, в котором она используется, обычно это функциональный интерфейс.

3. **Синтаксис**  
   Структура лямбда-выражения состоит из списка параметров, разделенных запятой, стрелки `->` и тела выражения. Если тело выражения состоит из одного оператора, фигурные скобки можно опустить.

4. **Захват переменных**  
   Лямбда-выражения могут использовать переменные из окружающего контекста (локальные переменные или поля класса). Однако локальные переменные должны быть effectively final (не изменяться после инициализации).

5. **Применение**  
   - Лямбда-выражения широко используются для реализации функциональных интерфейсов.  
   - Они значительно упрощают работу с коллекциями через Stream API, позволяя выполнять операции фильтрации, преобразования и агрегирования данных.  
   - Сокращают необходимость создания анонимных классов, что делает код более лаконичным.

#### Преимущества лямбда-выражений

- **Компактность:** Лямбда-выражения позволяют записывать код короче, чем использование анонимных классов.  
- **Читаемость:** Благодаря простому синтаксису, код становится легче восприниматься.  
- **Функциональный стиль программирования:** Поддержка императивного подхода к решению задач через функциональные интерфейсы и Stream API.  

#### Таблица основных понятий

| Термин                  | Описание                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| Функциональный интерфейс | Интерфейс с одним абстрактным методом, который может быть представлен лямбдой. |
| Effectively final       | Переменная, которая не явно объявлена как `final`, но фактически не изменяется. |
| Stream API              | API для обработки коллекций данных в функциональном стиле.               |
| Захват переменных        | Возможность использования внешних переменных внутри лямбда-выражения.     |
| Анонимные классы        | Предшественники лямбд для реализации одноразовых объектов.               |

##### Пример с коллекциями:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5)
numbersforEach(n -> Systemoutprintln(n * 2))
```

[🔄 К содержанию - главы](#современные-фичи-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Stream API <a id="stream-api"></a>

**Stream API** — это инструмент, введенный в Java 8, который позволяет обрабатывать коллекции данных в функциональном стиле. Он представляет собой последовательность элементов, над которыми можно выполнять различные операции, такие как фильтрация, преобразование и агрегирование. Stream API делает работу с данными более эффективной и компактной, позволяя писать код в декларативном стиле.

Основная идея `Stream API` заключается в том, чтобы отделить логику обработки данных от их хранения. Потоки не хранят данные, они лишь предоставляют возможность их обработки.

#### Основные концепции

1. **Поток (Stream)**  
   Поток — это последовательность элементов, которая поддерживает операции обработки. Потоки создаются на основе существующих коллекций или массивов и не изменяют исходные данные.

2. **Операции над потоками**  
   - **Промежуточные операции**: Возвращают новый поток и могут быть вызваны друг с другом. Примеры: `filter`, `map`, `sorted`.  
   - **Терминальные операции**: Завершают цепочку операций и производят результат или побочный эффект. Примеры: `collect`, `forEach`, `reduce`.

3. **Ленивое выполнение**  
   Промежуточные операции выполняются лениво, то есть фактическая обработка начинается только при вызове терминальной операции.

4. **Параллельная обработка**  
   Stream API поддерживает параллельную обработку данных через метод `parallelStream()`, что может значительно ускорить вычисления для больших наборов данных.

#### Преимущества Stream API

- **Функциональный стиль программирования**: Упрощает сложные операции над данными, делая код более читаемым и понятным.  
- **Ленивое выполнение**: Оптимизирует производительность за счет отложенного выполнения промежуточных операций.  
- **Параллельная обработка**: Обеспечивает возможность использования нескольких потоков для обработки данных.  
- **Компактность**: Сокращает объем кода по сравнению с традиционными циклами и условными конструкциями.

### Таблица основных операций Stream API

| **Тип операции**       | **Методы**                           | **Описание**                                                                 |
|------------------------|--------------------------------------|------------------------------------------------------------------------------|
| **Промежуточные**      | `filter`                             | Отфильтровывает элементы, соответствующие заданному условию.                 |
|                        | `map`                                | Преобразует каждый элемент потока с помощью заданной функции.               |
|                        | `flatMap`                            | Преобразует каждый элемент потока в поток и объединяет все потоки.          |
|                        | `peek`                               | Отладочная операция — позволяет "заглянуть" в элементы, не модифицируя их.  |
|                        | `sorted`                             | Сортирует элементы потока.                                                  |
|                        | `distinct`                           | Удаляет дубликаты из потока.                                                |
|                        | `limit`                              | Ограничивает количество элементов в потоке.                                 |
|                        | `skip`                               | Пропускает указанное количество элементов в начале потока.                  |
|                        | `takeWhile`                          | Берёт элементы, пока условие истинно.                                       |
|                        | `dropWhile`                          | Пропускает элементы, пока условие истинно, затем берёт оставшиеся.          |
| **Терминальные**       | `forEach`                            | Выполняет действие для каждого элемента потока.                             |
|                        | `forEachOrdered`                     | Выполняет действие с сохранением порядка (для параллельных потоков).        |
|                        | `collect`                            | Собирает результаты в коллекцию или другую структуру данных.                |
|                        | `reduce`                             | Агрегирует элементы потока в одно значение (например, сумма или максимум).  |
|                        | `count`                              | Возвращает количество элементов в потоке.                                   |
|                        | `anyMatch`, `allMatch`, `noneMatch` | Проверяет, удовлетворяют ли элементы заданному условию.                     |
|                        | `findFirst`, `findAny`               | Находит первый или любой элемент, удовлетворяющий условию.                  |
|                        | `toArray`                            | Преобразует поток в массив.                                                 |
|                        | `min`, `max`                         | Находит минимальный или максимальный элемент по заданному компаратору.      |

 **Пример использования**:
   ```java
   List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
   names.stream()
        .filter(name -> name.startsWith("A"))
        .map(String::toUpperCase)
        .forEach(System.out::println);
   ```
   

[🔄 К содержанию - главы](#современные-фичи-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Optional <a id="optional"></a>

`Optional<T>` - контейнерный объект, который может содержать или не содержать ненулевое значение. Основное назначение - явное указание на возможное отсутствие значения и избегание `NullPointerException`.

#### Создание Optional

```java
Optional<String> emptyOpt = Optional.empty();  // пустой Optional
Optional<String> valueOpt = Optional.of("value");  // с гарантированно не-null значением
Optional<String> nullableOpt = Optional.ofNullable(getNullableString());  // может быть null
```

#### Основные методы
Проверка наличия значения
```java
boolean isPresent = optional.isPresent();  // true если значение есть
boolean isEmpty = optional.isEmpty();     // Java 11+, true если значения нет
```

#### Получение значения
```java
String value = optional.get();  // бросает NoSuchElementException если пусто

// Безопасные альтернативы:
String value = optional.orElse("default");
String value = optional.orElseGet(() -> generateDefault());
String value = optional.orElseThrow(() -> new CustomException());
```
#### Условные операции
```java
optional.ifPresent(val -> System.out.println(val));  // выполнить если значение есть

// Java 9+
optional.ifPresentOrElse(
    val -> System.out.println(val),
    () -> System.out.println("Значение отсутствует")
);
```

#### Преобразования
```java
Optional<Integer> lengthOpt = optional.map(String::length);  // преобразование значения
Optional<Optional<Integer>> nested = optional.map(s -> Optional.of(s.length()));
Optional<Integer> flat = optional.flatMap(s -> Optional.of(s.length()));  // "разворачивает" вложенный Optional

Optional<String> filtered = optional.filter(s -> s.length() > 3);  // фильтрация
```

#### Лучшие практики
Не использовать:

```java
// Плохо:
Optional<String> optParam // как параметр метода
Optional<User> userField; // как поле класса
```
#### Рекомендуется:

```java
// Хорошо:
public Optional<User> findUser(String id) {
    // возвращаем Optional из метода
}

// Обработка цепочки возможных null:
String city = Optional.ofNullable(user)
    .flatMap(User::getAddress)
    .map(Address::getCity)
    .orElse("Unknown");
```

#### Альтернативы для примитивов

```java
OptionalInt optionalInt = OptionalInt.of(42);
OptionalLong optionalLong = OptionalLong.empty();
OptionalDouble optionalDouble = OptionalDouble.of(3.14);
```

#### Ограничения
 - Не сериализуем
 - Не полностью заменяет проверки на null
 - Может снижать производительность в hot-коде

#### Форматирование включает:
1. Блоки кода на Java с тройными кавычками
2. Заголовки разных уровней
3. Четкое разделение на логические блоки
4. Примеры правильного и неправильного использования
5. Важные заметки в виде маркированных списков



[🔄 К содержанию - главы](#современные-фичи-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Функциональные интерфейсы <a id="функциональные-интерфейсы"></a>

**Функциональный интерфейс** — это специальный тип интерфейса в Java, который содержит **ровно один абстрактный метод** *(Абстрактный метод — это метод **без реализации** (только заголовок), который **обязательно должен быть переопределён** в подклассе.)*. Он служит основой для работы с лямбда-выражениями и методами ссылок, которые были добавлены в Java 8. Благодаря функциональным интерфейсам можно передавать логику (кусок кода) как параметр, что делает код более гибким и компактным.  

#### Зачем нужны функциональные интерфейсы?

Функциональные интерфейсы позволяют:
1. **Упростить код**: Вместо создания целых классов или анонимных классов для реализации интерфейсов, можно использовать короткие лямбда-выражения.
2. **Стандартизировать операции**: Они предоставляют готовые шаблоны для распространенных типов операций, таких как проверка условий, преобразование данных или выполнение действий.

#### Основные стандартные функциональные интерфейсы

В Java есть множество встроенных функциональных интерфейсов, каждый из которых решает определенную задачу:

| **Интерфейс**       | **Назначение**                                                                 | **Пример использования**                                      |
|---------------------|-------------------------------------------------------------------------------|----------------------------------------------------------------|
| **`Predicate<T>`**  | Проверяет условие и возвращает `true` или `false`.                           | Проверка, является ли число четным: `n -> n % 2 == 0`          |
| **`Function<T, R>`**| Преобразует значение одного типа в другой.                                   | Преобразование строки в число: `str -> Integer.parseInt(str)`  |
| **`Consumer<T>`**   | Выполняет действие с переданным параметром и ничего не возвращает.           | Вывод текста в консоль: `text -> System.out.println(text)`     |
| **`Supplier<T>`**   | Возвращает значение без параметров.                                           | Получение текущей даты: `() -> new Date()`                     |
| **`BiFunction<T, U, R>`** | Принимает два параметра разных типов и возвращает результат.            | Сложение двух чисел: `(a, b) -> a + b`                         |
| **`UnaryOperator<T>`** | Принимает и возвращает значение одного типа (специализированный `Function`).| Увеличение числа на 1: `n -> n + 1`                            |

#### Как работают функциональные интерфейсы?

Когда вы используете лямбда-выражение, Java автоматически связывает его с соответствующим функциональным интерфейсом. Например:

- Если ваше лямбда-выражение представляет собой проверку условия (`n -> n > 0`), оно будет связано с интерфейсом `Predicate`.
- Если лямбда выполняет преобразование (`str -> str.toUpperCase()`), она будет связана с интерфейсом `Function`.

#### Преимущества функциональных интерфейсов

1. **Упрощение кода**: Лямбда-выражения делают код короче и понятнее.
2. **Гибкость**: Можно легко передавать логику между методами и классами.
3. **Стандартные контракты**: Использование стандартных интерфейсов уменьшает необходимость создавать свои собственные.

[🔄 К содержанию - главы](#современные-фичи-java-2)  
[▶️ К содержанию](#content)

---

### 🔹 Method references <a id="method-references"></a>

#### 🧩 Что такое Method References

Синтаксический сахар для лямбда-выражений, когда метод уже существует и его можно "передать по ссылке".

Форма записи: `Класс::метод` или `объект::метод`

#### 🔑 Основные типы ссылок

| Вид                     | Пример                    | Описание                                                   |
|-------------------------|---------------------------|------------------------------------------------------------|
| Ссылка на статический метод        | `Math::abs`              | Ссылается на `static`-метод без создания объекта          |
| Ссылка на метод экземпляра        | `str::toLowerCase`       | Метод объекта вызывается для каждого элемента              |
| Ссылка на метод любого объекта типа | `String::toUpperCase`     | Используется в потоках, применяется к каждому элементу     |
| Ссылка на конструктор             | `ArrayList::new`         | Создаёт новый объект                                       |

#### ⚙️ Когда использовать

- Когда лямбда-выражение просто вызывает метод.
- Повышает читаемость кода.
- Часто применяется с **Stream API**, **Optional**, **Collectors**.

📌 Итог:  
Method references — компактный и читабельный способ передать метод как поведение, особенно в функциональных операциях.

[🔄 К содержанию - главы](#современные-фичи-java-2)  
[▶️ К содержанию](#content)

---

## 🧠 JVM, память и производительность <a id="jvm-память-и-производительность"></a>

### 🔸 JVM и её архитектура <a id="jvm-и-архитектура"></a>

📌 JVM (Java Virtual Machine) — это виртуальная машина, которая выполняет байт-код Java на любой платформе. Она обеспечивает платформенную независимость, управление памятью, сборку мусора и безопасность исполнения кода.

🧱 Основные компоненты архитектуры JVM:

- **Class Loader Subsystem**  
  Загружает `.class`-файлы, проверяет и связывает классы.  
  Этапы: загрузка → проверка → подготовка → разрешение → инициализация.

- **Runtime Data Areas**  
  Память, используемая во время выполнения:
  - **Heap** — объекты и данные (все экземпляры классов)
  - **Stack** — стек вызовов методов (каждый поток имеет свой стек)
  - **Method Area (PermGen/Metaspace)** — информация о классах, методах, константах
  - **Program Counter (PC) Register** — адрес текущей инструкции
  - **Native Method Stack** — вызовы нативных методов (на C/C++)

- **Execution Engine**  
  Выполняет байт-код:
  - **Interpreter** — построчное исполнение
  - **JIT (Just-In-Time) компилятор** — компиляция часто вызываемого кода в нативный

- **Native Interface**  
  Позволяет взаимодействовать с нативным кодом (через JNI).

- **Garbage Collector**  
  Автоматически управляет памятью, удаляя неиспользуемые объекты из кучи.

🧠 JVM обеспечивает изоляцию, безопасность и управляемое выполнение Java-программ, делая Java переносимой и эффективной.

[🔄 К содержанию - главы](#jvm-память-и-производительность-2)  
[▶️ К содержанию](#content)

---

### 🔸 Память: Heap, Stack <a id="heap-stack"></a>

📌 Heap (Куча)  
- Область памяти для хранения объектов и массивов.  
- Общая для всех потоков.  
- Управляется сборщиком мусора (Garbage Collector).  
- Размер и организация могут настраиваться (например, молодое и старое поколения).  
- Объекты живут в куче до тех пор, пока на них есть ссылки.

📌 Stack (Стек)  
- Область памяти для хранения локальных переменных и вызовов методов.  
- Каждый поток имеет свой стек.  
- Организован как стек вызовов (stack frames).  
- При вызове метода создаётся новый фрейм, при возврате — удаляется.  
- Хранит примитивные типы и ссылки на объекты в куче.  
- Размер стека ограничен и обычно меньше кучи.

📝 Отличия Heap и Stack:  
- Heap для объектов и долгоживущих данных, Stack — для временных данных и вызовов.  
- Heap медленнее, требует сборки мусора; Stack быстр и управляется автоматически.  
- Ошибки StackOverflow возникают при переполнении стека (глубокая рекурсия), ошибки OutOfMemory — при нехватке кучи.

[🔄 К содержанию - главы](#jvm-память-и-производительность-2)  
[▶️ К содержанию](#content)

---

### 🔸 Сборщик мусора <a id="сборщик-мусора"></a>

📌 Что такое сборщик мусора (Garbage Collector, GC)?  
Автоматический механизм в JVM, который освобождает память, удаляя объекты, на которые больше нет ссылок, предотвращая утечки памяти.

🧩 Основные принципы работы:  
- Отслеживает объекты, доступные для программы.  
- Объекты, на которые нет активных ссылок, считаются мусором.  
- Освобождает память, занимая места этих объектов.

📌 Виды сборщиков мусора в JVM:  
- **Serial GC** — простой однопоточный сборщик, подходит для небольших приложений.  
- **Parallel GC** — многопоточный, оптимален для многопроцессорных систем.  
- **CMS (Concurrent Mark-Sweep)** — снижает паузы, выполняя большую часть работы параллельно с приложением.  
- **G1 (Garbage-First)** — современный сборщик, разделяющий кучу на регионы и оптимизирующий сборку для больших хипов.  
- **ZGC, Shenandoah** — низколатентные сборщики с минимальными паузами.

📌 Основные этапы сборки мусора:  
- **Mark (отметка)** — определение живых объектов.  
- **Sweep (очистка)** — удаление неиспользуемых объектов.  
- **Compact (сжатие)** — уплотнение памяти для уменьшения фрагментации (не во всех GC).

📝 Важно:  
- Разработчику обычно не нужно управлять GC вручную.  
- Правильное управление ссылками и объектами помогает снизить нагрузку на GC.  
- Понимание работы GC важно для оптимизации производительности.
  
[🔄 К содержанию - главы](#jvm-память-и-производительность-2)  
[▶️ К содержанию](#content)

---

### 🔸 Finalize <a id="finalize"></a>

📌 Метод finalize() — специальный метод в Java, вызываемый сборщиком мусора перед удалением объекта из памяти.

🧩 Особенности finalize():  
- Определяется в классе Object, можно переопределить для освобождения ресурсов.  
- Вызывается JVM один раз перед сборкой объекта (но вызов не гарантирован вовремя или вообще).  
- Не рекомендуется использовать для управления ресурсами, так как выполнение непредсказуемо.  
- Может привести к задержкам сборки мусора и проблемам с производительностью.

📌 Современные рекомендации:  
- Вместо finalize() использовать интерфейс AutoCloseable и конструкцию try-with-resources для управления ресурсами.  
- finalize() считается устаревшим (deprecated с Java 9) и будет удалён в будущих версиях.

📝 Вывод:  
Метод finalize() — устаревший механизм очистки, лучше применять альтернативные подходы для освобождения ресурсов.

[🔄 К содержанию - главы](#jvm-память-и-производительность-2)  
[▶️ К содержанию](#content)

---

### 🔸 Оптимизация и утечки <a id="оптимизация-и-утечки"></a>

📌 Оптимизация памяти в Java направлена на эффективное использование ресурсов и снижение нагрузки на сборщик мусора.

Основные подходы:
- Минимизация создания временных объектов для уменьшения частоты сборок мусора.
- Использование примитивных типов вместо обёрток, когда это возможно.
- Переиспользование объектов и пулов, например, String Pool, Object Pool.
- Выбор подходящего сборщика мусора под задачи приложения.

📌 Утечки памяти — ситуации, когда объекты, которые больше не нужны, остаются доступны и не освобождаются:
- Сильные ссылки на неиспользуемые объекты.
- Статические коллекции, в которые добавляются объекты и не очищаются.
- Внутренние классы и слушатели, которые продолжают ссылаться на объекты.
- Некорректное управление ресурсами (например, открытые потоки, соединения).

📌 Методы поиска и предотвращения утечек:
- Использование профилировщиков памяти (VisualVM, YourKit).
- Анализ heap dumps.
- Применение слабых (WeakReference), мягких (SoftReference) и фантомных (PhantomReference) ссылок.
- Тестирование и код-ревью с упором на освобождение ресурсов.

📝 Итог:
Контроль памяти и предотвращение утечек — ключевые задачи для стабильности и производительности Java-приложений.

[🔄 К содержанию - главы](#jvm-память-и-производительность-2)  
[▶️ К содержанию](#content)

---

## 🧵 Многопоточность и конкурентность <a id="многопоточность-и-конкурентность"></a>

### 🔹 Thread, Runnable <a id="thread-runnable"></a>

[🔄 К содержанию - главы](#многопоточность-и-конкурентность-2)  
[▶️ К содержанию](#content)

---

### 🔹 synchronized, volatile <a id="synchronized-volatile"></a>

[🔄 К содержанию - главы](#многопоточность-и-конкурентность-2)  
[▶️ К содержанию](#content)

---

### 🔹 ExecutorService <a id="executorservice"></a>

[🔄 К содержанию - главы](#многопоточность-и-конкурентность-2)  
[▶️ К содержанию](#content)

---

### 🔹 Concurrent коллекции <a id="concurrent-коллекции"></a>

[🔄 К содержанию - главы](#многопоточность-и-конкурентность-2)  
[▶️ К содержанию](#content)

---

### 🔹 Deadlock, race condition <a id="deadlock-race-condition"></a>

[🔄 К содержанию - главы](#многопоточность-и-конкурентность-2)  
[▶️ К содержанию](#content)

---

## 🔎 Рефлексия и аннотации <a id="рефлексия-и-аннотации"></a>

### 🔸 Рефлексия <a id="рефлексия"></a>

[🔄 К содержанию - главы](#рефлексия-и-аннотации-2)  
[▶️ К содержанию](#content)

---

### 🔸 Аннотации <a id="аннотации"></a>

[🔄 К содержанию - главы](#рефлексия-и-аннотации-2)  
[▶️ К содержанию](#content)

---

### 🔸 Создание кастомных аннотаций <a id="создание-кастомных-аннотаций"></a>

[🔄 К содержанию - главы](#рефлексия-и-аннотации-2)  
[▶️ К содержанию](#content)

---

### 🔸 Использование в библиотеках <a id="использование-аннотаций-в-библиотеках"></a>

[🔄 К содержанию - главы](#рефлексия-и-аннотации-2)  
[▶️ К содержанию](#content)

---

## 🗃️ Работа с файлами и вводом/выводом <a id="работа-с-файлами-и-вводом-выводом"></a>

### 🔸 File, Path, Files <a id="file-path-files"></a>

[🔄 К содержанию - главы](#работа-с-файлами-и-вводом-выводом-2)  
[▶️ К содержанию](#content)

---

### 🔸 Reader, Writer <a id="reader-writer"></a>

[🔄 К содержанию - главы](#работа-с-файлами-и-вводом-выводом-2)  
[▶️ К содержанию](#content)

---

### 🔸 BufferedReader, Scanner <a id="bufferedreader-scanner"></a>

[🔄 К содержанию - главы](#работа-с-файлами-и-вводом-выводом-2)  
[▶️ К содержанию](#content)

---

### 🔸 NIO2 <a id="nio2"></a>

[🔄 К содержанию - главы](#работа-с-файлами-и-вводом-выводом-2)  
[▶️ К содержанию](#content)

---

### 🔸 Channels <a id="channels"></a>

[🔄 К содержанию - главы](#работа-с-файлами-и-вводом-выводом-2)  
[▶️ К содержанию](#content)

---

## 🌐 Сетевое взаимодействие <a id="сетевое-взаимодействие"></a>

### 🔸 HttpClient <a id="httpclient"></a>

[🔄 К содержанию - главы](#сетевое-взаимодействие-2)  
[▶️ К содержанию](#content)

---

### 🔸 HttpURLConnection <a id="httpurlconnection"></a>

[🔄 К содержанию - главы](#сетевое-взаимодействие-2)  
[▶️ К содержанию](#content)

---

### 🔸 TCP/UDP сокеты <a id="tcp-udp-сокеты"></a>

[🔄 К содержанию - главы](#сетевое-взаимодействие-2)  
[▶️ К содержанию](#content)

---

### 🔸 Простейшие REST-клиенты <a id="rest-клиенты"></a>

[🔄 К содержанию - главы](#сетевое-взаимодействие-2)  
[▶️ К содержанию](#content)

---

## 🛠 Инструменты и экосистема <a id="инструменты-и-экосистема"></a>

### 🔸 Gradle и Maven <a id="gradle-и-maven"></a>

[🔄 К содержанию - главы](#инструменты-и-экосистема-2)  
[▶️ К содержанию](#content)

---

### 🔸 Unit-тестирование (JUnit 5, Mockito) <a id="unit-тестирование"></a>

[🔄 К содержанию - главы](#инструменты-и-экосистема-2)  
[▶️ К содержанию](#content)

---

### 🔸 Логгирование: SLF4J, Log4j, Logback <a id="логгирование"></a>

[🔄 К содержанию - главы](#инструменты-и-экосистема-2)  
[▶️ К содержанию](#content)

---

### 🔸 CI/CD основы <a id="ci-cd-основы"></a>

[🔄 К содержанию - главы](#инструменты-и-экосистема-2)  
[▶️ К содержанию](#content)

---

## 🏗 Архитектура и паттерны <a id="архитектура-и-паттерны"></a>

### 🔹 Порождающие, структурные, поведенческие <a id="группы-паттернов"></a>

Паттерны проектирования можно классифицировать на три основные группы: **порождающие**, **структурные** и **поведенческие**. Ниже представлены эти группы в виде таблиц.
Применение в автотестах:  
**API-автотесты**  
**Builder** — удобно собирать тело POST-запроса с нужными полями, не прописывая каждый раз весь JSON.  
**Factory** — создаёт тестовые данные или API-клиенты под разное окружение (dev/stage/prod).  
**Singleton** — один общий экземпляр Rest Assured клиента или конфигурации для всех тестов.  
**Strategy** — разные алгоритмы проверки ответа в зависимости от типа данных (JSON, XML, CSV).  

**UI-автотесты**  
**Page Object** — вся логика взаимодействия со страницей (кнопки, поля, проверки) хранится в одном классе, а тесты только вызывают нужные методы.  
**Singleton** — один экземпляр WebDriver на сессию тестов, чтобы не плодить кучу браузеров.  
**Factory** — создание страниц или драйверов под разные браузеры (Chrome, Firefox, Safari).  



#### 1. **Порождающие паттерны (Creational Patterns)**

| **Паттерн**       | **Описание**                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| Singleton         | Обеспечивает наличие единственного экземпляра класса и предоставляет к нему глобальный доступ. |
| Factory Method    | Определяет интерфейс для создания объектов, позволяя подклассам решать, какие объекты создавать. |
| Abstract Factory  | Предоставляет интерфейс для создания семейств связанных или зависимых объектов. |
| Builder           | Разделяет процесс конструирования сложного объекта от его представления.     |
| Prototype         | Создает новые объекты путем копирования существующих (прототипов).            |

#### 2. **Структурные паттерны (Structural Patterns)**

| **Паттерн**       | **Описание**                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| Adapter           | Преобразует интерфейс одного класса в другой, ожидаемый клиентом.             |
| Bridge            | Разделяет абстракцию и реализацию, позволяя им изменяться независимо.         |
| Composite         | Позволяет создавать древовидные структуры объектов с единым интерфейсом.      |
| Decorator         | Динамически добавляет дополнительное поведение объектам без изменения их класса. |
| Facade            | Предоставляет упрощенный интерфейс к сложной системе классов.                 |
| Flyweight         | Минимизирует использование памяти за счет разделяемых данных.                |
| Proxy             | Предоставляет объект-заместитель для контроля доступа к другому объекту.      |

#### 3. **Поведенческие паттерны (Behavioral Patterns)**

| **Паттерн**       | **Описание**                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| Chain of Responsibility | Создает цепочку обработчиков для передачи запросов до тех пор, пока он не будет обработан. |
| Command           | Преобразует запросы в объекты для параметризации клиентов различными запросами. |
| Interpreter       | Определяет грамматику для языка и интерпретирует предложения этого языка.      |
| Iterator          | Предоставляет способ последовательного доступа ко всем элементам коллекции.   |
| Mediator          | Инкапсулирует взаимодействие между множеством объектов.                       |
| Memento           | Сохраняет состояние объекта для его восстановления в будущем.                |
| Observer          | Определяет зависимость между объектами для автоматического уведомления при изменении состояния. |
| State             | Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. |
| Strategy          | Определяет семейство алгоритмов, инкапсулируя каждый из них и делая их взаимозаменяемыми. |
| Template Method   | Определяет скелет алгоритма, позволяя подклассам переопределить некоторые шаги. |
| Visitor           | Позволяет определить новую операцию над каждым элементом структуры данных.     |

[🔄 К содержанию - главы](#архитектура-и-паттерны-2)  
[▶️ К содержанию](#content)

---

### 🔹 Принципы SOLID, DRY, KISS <a id="принципы-solid-dry-kiss"></a>

#### SOLID
Принципы SOLID:
- **S** - Single Responsibility Principle (Принцип единственной ответственности): Каждый класс должен иметь одну и только одну причину для изменения.
- **O** - Open/Closed Principle (Принцип открытости/закрытости): Код должен быть открыт для расширения, но закрыт для изменения.
- **L** - Liskov Substitution Principle (Принцип подстановки Барбары Лисков): Объекты базового класса могут быть заменены объектами его подкласса без изменения корректности программы.
- **I** - Interface Segregation Principle (Принцип разделения интерфейсов): Интерфейс не должен заставлять реализовывать методы, которые не используются.
- **D** - Dependency Inversion Principle (Принцип инверсии зависимостей): Модули верхнего уровня не должны зависеть от модулей нижнего уровня; оба должны зависеть от абстракций.

#### DRY
**Don't Repeat Yourself** (Не повторяй себя):
- Основной принцип: избегать дублирования кода.
- Повторяющийся код заменяется переиспользуемыми компонентами, функциями или классами.
- Это помогает уменьшить количество ошибок и упростить поддержку кода.

#### KISS
**Keep It Simple, Stupid** (Делай проще):
- Этот принцип гласит, что система должна быть настолько простой, насколько возможно.
- Избегай ненужной сложности в дизайне и реализации.
- Простота облегчает понимание, поддержку и улучшение системы.

#### YAGNI
**You Aren't Gonna Need It** (Тебе это не понадобится):
- Не добавляй функциональность, которая может быть нужна в будущем, но не требуется прямо сейчас.
- Сконцентрируйся на текущих потребностях, чтобы избежать лишнего кода и затрат.

#### GRASP
**General Responsibility Assignment Software Patterns** (Шаблоны назначения ответственности):
- Предлагает подходы к распределению обязанностей между классами и объектами в программной системе.
- Включает такие шаблоны, как "Контроллер", "Информационный эксперт" и другие.

#### CoC
**Convention over Configuration** (Конвенция вместо конфигурации):
- В систему заложены стандартные настройки, которые используются по умолчанию.
- Это уменьшает количество ручной конфигурации и делает процесс разработки более эффективным.

#### Encapsulation
**Инкапсуляция**:
- Скрытие внутренней реализации и данных класса от внешнего мира.
- Обеспечивает доступ к функциональности класса через строго определённые интерфейсы.

#### Polymorphism
**Полиморфизм**:
- Возможность использования одного интерфейса для различных реализаций.
- Это позволяет создавать код, независимый от конкретных типов.


[🔄 К содержанию - главы](#архитектура-и-паттерны-2)  
[▶️ К содержанию](#content)

---

### 🔹 DDD, MVC и архитектурные подходы <a id="ddd-mvc"></a>

📌 DDD (Domain-Driven Design):  
Подход к проектированию, в котором внимание сосредоточено на бизнес-области (домене) и моделировании её понятий в коде.  
Ключевые элементы:  
- **Entity** — объект с идентичностью  
- **Value Object** — объект без идентичности  
- **Aggregate** — группа связанных объектов  
- **Repository** — интерфейс к хранилищу  
- **Service** — логика вне сущностей

📌 MVC (Model-View-Controller):  
Шаблон разделения обязанностей:
- **Model** — бизнес-логика и данные  
- **View** — отображение данных  
- **Controller** — обработка пользовательского ввода

🧱 Другие архитектурные подходы:
- **Layered Architecture (Слои)** — разделение на уровни: контроллеры, сервисы, DAO и т.д.
- **Hexagonal Architecture (Порт и адаптер)** — изоляция бизнес-логики от внешнего мира
- **Microservices** — система, разбитая на независимые сервисы
- **Event-Driven** — компоненты взаимодействуют через события
- **Clean Architecture** — вложенные круги, изолирующие доменную модель от внешнего мира

[🔄 К содержанию - главы](#архитектура-и-паттерны-2)  
[▶️ К содержанию](#content)

---

## 📈 Версии Java <a id="версии-java"></a>

### 🔸 Java 8: Stream, Optional, Lambda <a id="java-8"></a>

📌 Java 8 — одна из самых значимых версий Java, выпущенная в 2014 году. Она принесла мощные функциональные возможности и API.

**Lambda-выражения**  
Позволяют писать компактный код для реализации функциональных интерфейсов. Используются в Stream API, коллекциях и обработчиках событий.

**Stream API**  
Позволяет обрабатывать коллекции декларативным стилем (filter, map, reduce). Потоки могут быть последовательными или параллельными, поддерживают ленивые операции.

**Optional**  
Контейнер для значения, которое может быть null. Позволяет избежать `NullPointerException` и писать более безопасный код (`Optional.of()`, `Optional.empty()`, `ifPresent`, `orElse` и т.д.).

🔹 Другие нововведения:
- Метод `forEach` для коллекций.
- Статические методы в интерфейсах.
- Новые API для работы с датой и временем (`java.time`).
- Повышение читаемости и выразительности кода.

[🔄 К содержанию - главы](#версии-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Java 9–17: JPMS, Records, Text Blocks <a id="java-9-17"></a>

📌 Эти версии Java добавили множество улучшений, повышающих читаемость, безопасность и структуру приложений.

**Java 9**
- **JPMS (Java Platform Module System)** — модульная система, позволяющая разбивать код на модули (`module-info.java`), улучшая инкапсуляцию и управление зависимостями.
- **JShell** — интерактивная консоль Java (REPL).
- Улучшения в Stream API: `takeWhile`, `dropWhile`, `iterate`.

**Java 10**
- `var` — вывод типа локальных переменных (type inference).

**Java 11**
- Новый HTTP-клиент (`java.net.http.HttpClient`) вместо `HttpURLConnection`.
- Улучшения в String API: `isBlank()`, `lines()`, `repeat()`.
- Запуск Java-файла без компиляции (`java HelloWorld.java`).

**Java 12–14**
- **Text Blocks (Java 13–14)** — многострочные строки с тройными кавычками `"""`, упрощают работу с JSON, SQL и HTML.
- Улучшения switch-оператора (preview).

**Java 15–16**
- **Records** — компактный способ создания неизменяемых DTO-классов (`record Person(String name, int age)`).
- **Sealed Classes** — ограничивают наследование.

**Java 17 (LTS)**
- LTS (Long-Term Support) версия.
- Поддержка всех предыдущих фич как стабильных.
- Улучшения производительности, стабильности и безопасности.

[🔄 К содержанию - главы](#версии-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Java 21+: Pattern Matching, Virtual Threads <a id="java-21-plus"></a>

📌 **Java 21 — LTS-релиз**, в котором акцент сделан на удобство разработки, читаемость кода и масштабируемую многопоточность.

#### 🔹 Pattern Matching  
Упрощает проверку типов и избавляет от явного кастинга:
```java
if (obj instanceof String s) {
    System.out.println(s.toLowerCase());
}
```
Работает с `instanceof`, `switch`, `record patterns`.

#### 🔹 Record Patterns  
Позволяют распаковать значения из `record` напрямую:
```java
record Point(int x, int y) {}
Object obj = new Point(1, 2);
if (obj instanceof Point(int x, int y)) {
    System.out.println(x + ", " + y);
}
```

#### 🔹 Virtual Threads (Project Loom)  
Позволяют запускать тысячи лёгких потоков без перегрузки CPU:
```java
Thread.startVirtualThread(() -> {
    // Лёгкая конкурентная задача
    fetchData();
});
```
`Virtual Threads` используют планировщик, встроенный в `JVM`, и масштабируются значительно лучше, чем обычные потоки.


[🔄 К содержанию - главы](#версии-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 LTS и поддержка <a id="lts-и-поддержка"></a>

📌 **LTS (Long-Term Support)** — долгосрочная поддержка версий Java, гарантирующая обновления безопасности и исправления ошибок на протяжении нескольких лет.

- Версии с LTS выпускаются каждые три года (например, Java 8, 11, 17, 21).
- LTS-релизы рекомендуются для корпоративного использования из-за стабильности и поддержки.
- Между LTS-релизами выходят промежуточные версии с новыми возможностями, но с ограниченной поддержкой.
- Обновления для LTS включают патчи безопасности, критические исправления и иногда улучшения производительности.
- Обеспечение поддержки зависит от поставщика JDK (Oracle, OpenJDK, другие дистрибутивы).

✅ Для продакшн-проектов рекомендуется использовать именно LTS-версии.

[🔄 К содержанию - главы](#версии-java-2)  
[▶️ К содержанию](#content)

---

## 🧮 Сортировки в Java <a id="сортировки-в-java"></a>

### 🔸 Arrays.sort <a id="arrays-sort"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Collections.sort <a id="collections-sort"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Comparator и Comparable <a id="comparator-и-comparable"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Стабильность сортировки <a id="стабильность-сортировки"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Пользовательские реализации сортировок <a id="пользовательские-реализации-сортировок"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

### 🔸 Сложность алгоритмов сортировки <a id="сложность-алгоритмов-сортировки"></a>

[🔄 К содержанию - главы](#сортировки-в-java-2)  
[▶️ К содержанию](#content)

---

















---

## [🌏Типы данных - Data Types](#типы-данных) 

   - [🔸 Примитивные и ссылочные типы](#примитивные-и-ссылочные-типы)
   - [🔸 Мутабельные и иммутабельные классы](#мутабельные-и-иммутабельные-классы)
     
## [🟡Ключевые концепции ООП](#ключевые-концепции-ооп)

   - [🔹 Переопределение и перегрузка](#переопределение-и-перегрузка)
   - [🔹 Абстрактный класс vs Интерфейс](#абстрактный-класс-vs-интерфейс)
     
## [🔵Модификаторы и управление доступом](#модификаторы-и-управление-доступом)

   - [🔸 Модификаторы доступа - Access Modifiers](#модификаторы-доступа)
   - [🔸 Final/finally/finalize](#final-finally-finalize)
   - [🔸 Final: ограничения](#final-ограничения) 
   - [🔸 Static: применение](#static-применение)
     
## [🟠Операторы и циклы](#операторы-и-циклы)

   - [🔹 Условные операторы](#условные-операторы)
   - [🔹 Автоупаковка и распаковка](#автоупаковка-и-распаковка)
   - [🔹 Циклы](#циклы)
     
## [🟣Работа с исключениями - Exceptions](#работа-с-исключениями)

   - [🔸 Иерархия исключений](#иерархия-исключений)
   - [🔸 Обработка исключений](#обработка-исключений)
     
## [🟤Современные API ](#современные-api)

   - [🔹 Stream API](#stream-api)
   - [🔹 Лямбда-выражения - Functions(Lambda expressions)](#лямбда-выражения)
   - [🔹 Функциональные интерфейсы](#функциональные-интерфейсы)

## [🗂️Коллекции ](#коллекции)
   
   - [🔸 Java Collections и Map](#java-collections-и-map)
     
## [⭕Глубокие концепции Java](#глубокие-концепции-java)

   - [Коллизия](#коллизия)
   - [Рефлексия](#рефлексия)
   - [Хэш-таблицы](#хэш-таблицы)
   - [Очереди и стеки](#очереди-стек)
  
## [🏆Структуры данных и обобщения (Generics)](#generics) 

   - [🔹 hashCode и equals + Хеш-таблицы, buckets](#hashcode-и-equals-хеш-таблицы-buckets)
   - [🔹 Generics: общее понимание](#generics-общее-понимание)

## [👑Управление памятью и работа со ссылками](#memory) 

   - [🔸 Память, сборщик мусора - Memory Management, Garbage Collection](#память)
   - [🔸 Строки и пул строк(Pool string)](#строки-и-пул-строк)
   - [🔸 Каллизия (Call-by-value и Call-by-reference)](#call-by-value)
   
## [💡Фундаментальные концепции](#фундаментальные) 
   
   - [🔹 Методы класса Object](#методы-класса-object)
   - [🔹 Базовый синтаксис - Basic Syntax](#basic)
   - [🔹 Интерфейсы - Interface](#interface)
   - [🔹 Методы](#методы)
   - [🔹 Классы ](#классы)
   - [🔹 Множественное наследование - Multiple Inheritance](#multiple)
   
## [🏗️ Архитектурные подходы и паттерны проектирования](#архитектура) - 
   
   - [🔸 Группы паттернов проектирования](#pattern)
   - [🔸 Термины - SOLID ](#термины-принципов-проектирования)
     
---

# 🌏 Типы данных1️⃣<a id="типы-данных"></a>

## 🔸 Примитивные и ссылочные типы <a id="примитивные-и-ссылочные-типы"></a>

### Определения


[К содержанию](#content)

---

## 🔸 Мутабельные и иммутабельные классы <a id="мутабельные-и-иммутабельные-классы"></a>



[К содержанию](#content)

---

# 🟡 Ключевые концепции ООП 6️⃣<a id="ключевые-концепции-ооп"></a>

**Основные принципы ООП:**

**ООП** — это подход к программированию, в котором программа строится как набор объектов, каждый из которых имеет свои данные (свойства) и функции (методы). Эти объекты могут взаимодействовать друг с другом, обмениваться информацией и выполнять задачи.

***Функциональное программирование***    
*(Функциональное программирование — это стиль программирования, в котором основное внимание уделяется вычислениям через функции, а не изменению состояния или данных. В этом подходе функции являются «первоклассными объектами», то есть их можно передавать как аргументы, возвращать из других функций и использовать без изменения их состояния.    
Основные принципы ФП:   
**Чистые функции** — функции, которые всегда возвращают один и тот же результат для одинаковых входных данных и не изменяют состояние программы.    
**Отсутствие побочных эффектов** — функции не изменяют внешние данные или состояние программы (например, глобальные переменные).  
**Функции высшего порядка** — функции, которые могут принимать другие функции в качестве аргументов или возвращать их.*  


⭐**Инкапсуляция - сокрытие реализации.** 
*Инкапсуляция подразумевает то, что мы скрываем какие-то свойства объекта и предоставляем к ним доступ в Java с помощью методов getter и setter, а также модификаторов доступа.*    
Вы нажимаете на кнопку зажигания, и автомобиль заводится. Вам не нужно знать, как именно работает двигатель внутри (процесс горения топлива, работа цилиндров и т.д.). Вся сложная реализация скрыта, а вы взаимодействуете только с простым интерфейсом — кнопкой.  
**Реализация:** модификаторы доступа + геттеры/сеттеры.  

⭐**Наследование - создание новой сущности на базе уже существующей.**  
*Наследование. То есть то, что класс может наследовать поведение и поля другого класса родительского.*  
Все автомобили имеют общие характеристики, такие как колеса, двигатель и руль. На их основе можно создать более специализированные типы:  
Спортивный автомобиль (SportsCar) наследует от обычного автомобиля (Car) и добавляет уникальные особенности, например, увеличенную мощность или спортивный режим.  
Грузовик (Truck) также наследует от автомобиля, но добавляет возможность перевозить грузы.  
**Реализация:** extends + переопределение.

⭐**Полиморфизм - возможность иметь разные формы для одной и той же сущности.**
*Полиморфизм. Один метод множества реализаций в Java с помощью переопределения и перегрузки.То есть один метод может быть реализован по-разному, в зависимости от того, от кого он вызывается, либо какие параметры в него передаются*  
Разные автомобили могут по-разному реагировать на одно и то же действие. Например, метод accelerate() (ускорение):
Для спортивного автомобиля это может означать быстрое ускорение до 100 км/ч за несколько секунд.
Для грузовика ускорение будет медленнее из-за большого веса.
Один и тот же метод ведет себя по-разному в зависимости от типа автомобиля.
**Реализация:** interface/abstract + разная реализация.

⭐**Абстракция - набор общих характеристик.**  
*Абстракция. Мы абстрактно выделяем какие-то главные свойства, а неглавные не выделяем.*  
Автомобиль — это абстрактная концепция, которая объединяет общие свойства всех машин: они имеют колеса, двигатель, руль и могут ехать. Конкретные модели (например, Toyota Camry или Tesla Model 3) добавляют свои уникальные детали, но все они основаны на этой общей абстракции.
Таким образом, абстракция позволяет нам думать об автомобиле как о единой сущности, не углубляясь в детали каждой конкретной модели.
**Реализация:** interface/abstract + разная реализация.

**Посылка сообщений** - форма связи, взаимодействия между сущностями.  
**Переиспользование**- все что перечислено выше работает на повторное использование кода.  


## 1. **Объекты и классы**
- **Класс**: Это шаблон или blueprint, который определяет структуру и поведение объектов. Он описывает, какие данные (свойства) и действия (методы) будут доступны для объектов этого типа.
- **Объект**: Это экземпляр класса. Объект представляет собой конкретную сущность, созданную на основе класса. У каждого объекта есть свои уникальные значения свойств, но все они следуют общей структуре, заданной классом.

## 2. **Инкапсуляция**
- Инкапсуляция — это механизм скрытия внутренней реализации объекта и предоставления доступа к его функционалу только через публичный интерфейс.
- Основные методы реализации инкапсуляции:
  - Модификаторы доступа (public, private, protected, default).
  - Скрытие данных через ограничение прямого доступа к переменным.
  - Методы-геттеры и сеттеры для безопасного управления внутренними данными.

## 3. **Наследование**
- Наследование позволяет одному классу (дочернему) получить все свойства и методы другого класса (родительского).
- Основные аспекты реализации наследования.
  - Ключевое слово extends (для наследования класса).
  - Повторное использование кода, что упрощает разработку.
  - Расширение функциональности через добавление новых или изменение существующих методов.

## 4. **Полиморфизм**
- Полиморфизм означает "многозначность" и позволяет использовать один интерфейс для различных типов данных.
- Ключевые моменты
   - **Перегрузка методов**:
   - Позволяет иметь несколько методов с одним именем, но с разными параметрами.
 - Ключевые моменты:
   - Статический полиморфизм, который определяется на этапе компиляции.
   - Удобство для различных сценариев, например, сложение чисел разных типов.
  - **Переопределение методов**:
   - Позволяет дочерним классам изменить поведение метода родительского класса.
 - Ключевые моменты:
   - Динамический полиморфизм, который определяется на этапе выполнения.
   - Использование аннотации @Override, чтобы явно указать переопределение.объектов.

## 5. **Абстракция**
- Абстракция — это процесс выделения главных характеристик объекта, игнорируя второстепенные детали.
 Основные методы реализации абстракции:
  - Абстрактные классы (с возможностью включения как абстрактных, так и конкретных методов).
  - Интерфейсы, которые определяют только сигнатуру методов без их реализации.

## Зачем нужны эти концепции?
- **Модульность**: Код становится более организованным и разделенным на логические блоки.
- **Расширяемость**: Программа легко адаптируется к изменениям требований.
- **Безопасность**: Защищает данные и предотвращает несанкционированное изменение внутренней реализации.
- **Читаемость**: Упрощает понимание кода благодаря четкой структуре и разделению ответственности.

[К содержанию](#content)

---

## 🔹 Переопределение и перегрузка <a id="переопределение-и-перегрузка"></a>



[К содержанию](#content)

---

## 🔹 Абстрактный класс vs Интерфейс <a id="абстрактный-класс-vs-интерфейс"></a>

[К содержанию](#content)

--- 

# 🔵 Модификаторы и управление доступом <a id="модификаторы-и-управление-доступом"></a>

## 🔸 Модификаторы доступа 2️⃣ <a id="модификаторы-доступа"></a>



[К содержанию](#content)

---

## 🔸 Final/finally/finalize <a id="final-finally-finalize"></a>




---

## 🔸 Final: ограничения <a id="final-ограничения"></a>

Использование ключевого слова `final` накладывает следующие ограничения:

1. **Final классы**:
   - Нельзя создать подклассы от `final` класса.
   - Полезно для классов, которые предоставляют финальную реализацию и не должны изменяться.

2. **Final методы**:
   - Нельзя переопределить `final` метод в подклассах.
   - Полезно для методов, которые обеспечивают критически важную функциональность и не должны быть изменены.

3. **Final переменные**:
   - Значение `final` переменной должно быть присвоено один раз и не может быть изменено.
   - Для примитивных типов это означает фиксированное значение.
   - Для ссылочных типов это означает, что ссылка не может быть изменена, но содержимое объекта может меняться, если сам объект не является неизменяемым.

[К содержанию](#content)

---


| Ключевое слово | Описание                                                                 |
|----------------|--------------------------------------------------------------------------|
| `static`       | Обозначает, что переменная, метод или блок принадлежит классу, а не экземпляру. Это позволяет обращаться к ним без создания объекта. |
| `final`        | Используется для обозначения констант (неизменяемых значений), окончательных классов (которые нельзя наследовать) или методов (которые нельзя переопределить). |
| `abstract`     | Помечает класс или метод как абстрактный. Абстрактный класс не может быть создан напрямую, а абстрактный метод должен быть реализован в подклассах. |
| `private`      | Указывает, что доступ к методу или переменной возможен только внутри того же класса. Это ограничивает видимость элементов класса. |
| `protected`    | Разрешает доступ к методу или переменной внутри того же пакета и всем подклассам вне пакета. |
| `public`       | Делает метод или переменную доступными из любого места программы. Это наиболее открытый уровень доступа. |
| `this`         | Ссылается на текущий экземпляр класса. Используется для доступа к переменным или методам того же объекта. |
| `super`        | Ссылается на родительский класс. Используется для вызова методов или доступа к переменным родителя. |
| `synchronized` | Используется для обеспечения потокобезопасности. Метод или блок кода помеченный этим словом может выполняться только одним потоком одновременно. |
| `transient`    | Указывает, что поле не должно сериализоваться при сохранении состояния объекта. |
| `volatile`     | Обозначает, что значение переменной может изменяться разными потоками, и все изменения должны быть видны другим потокам без дополнительной синхронизации. |
| `native`       | Помечает метод, который реализован на другом языке программирования (например, C или C++). |
| `strictfp`     | Гарантирует точность вычислений с плавающей запятой, заставляя JVM использовать строгие правила IEEE 754. |
| `interface`    | Обозначает спецификацию поведения, которую должны реализовать классы. Интерфейс определяет контракт без конкретной реализации. |
| `enum`         | Используется для создания ограниченного набора констант. Например, дни недели или цвета. |
| `package`      | Группирует связанные классы и интерфейсы в одну единицу. Это помогает организовать код и избежать конфликтов имен. |
| `import`       | Позволяет использовать классы из других пакетов без необходимости указывать полное имя класса. |
| `throws`       | Указывает, что метод может выбросить исключение. Это предупреждает вызывающий код о возможных проблемах. |
| `try`          | Используется для блока кода, где может возникнуть исключение. |
| `catch`        | Обрабатывает исключения, возникающие в блоке `try`. |
| `finally`      | Выполняется всегда после блока `try-catch`, независимо от того, было ли выброшено исключение. |
| `throw`        | Прерывает выполнение метода и передает управление обработчику исключений. |
| `assert`       | Проверяет условие во время выполнения программы. Если условие ложно, выбрасывается ошибка `AssertionError`. |

## 🔸 Static: применение <a id="static-применение"></a>

Ключевое слово `static` используется для создания членов класса, которые принадлежат самому классу, а не его экземплярам.

1. **Static переменные**:
   - Общие для всех экземпляров класса.
   - Хранят одно значение для всего класса.
   - Пример: счетчик количества созданных объектов.

2. **Static методы**:
   - Может быть вызван без создания экземпляра класса.
   - Не имеет доступа к нестатическим полям и методам, так как они принадлежат конкретным экземплярам.
   - Пример: методы класса `Math`, такие как `Math.sqrt()`.

3. **Static блоки**:
   - Выполняются один раз при загрузке класса.
   - Используются для инициализации статических переменных.

4. **Static вложенные классы**:
   - Вложенный класс, который можно использовать без создания экземпляра внешнего класса.
   - Полезно для группировки связанных классов.

[К содержанию](#content)

--- 

# 🟠 Операторы и циклы <a id="операторы-и-циклы"></a>

## 🔹 Условные операторы <a id="условные-операторы"></a>


[К содержанию](#content)

---

## 🔹 Автоупаковка и распаковка <a id="автоупаковка-и-распаковка"></a>



[К содержанию](#content)

---

## 🔹 Циклы <a id="циклы"></a>


[К содержанию](#content)

---

# 🟣 Работа с исключениями8️⃣ <a id="работа-с-исключениями"></a>

## 🔸 Иерархия исключений <a id="иерархия-исключений"></a>

В Java все исключения организованы в иерархическую структуру, которая начинается с класса `Throwable`. От него наследуются два основных подкласса: `Error` и `Exception`.

 <img src="https://clipof.ru/wp-content/uploads/c/1/d/c1d319d14f1bbf6a7131f7ab2647e480.png" alt="Описание изображения" style="width: 75%; height: auto;">

1. **Throwable**:
   - Корневой класс для всех ошибок и исключений.
   - Позволяет обрабатывать как программные ошибки (`Exception`), так и системные (`Error`).

2. **Error**:
   - Представляет серьезные проблемы, которые обычно невозможно обработать программой.
   - **Примеры:**
     - `OutOfMemoryError`: Возникает, когда JVM не может выделить больше памяти.
     - `StackOverflowError`: Происходит при переполнении стека вызовов, обычно из-за бесконечной рекурсии.
     - `VirtualMachineError`: Указывает на серьезные сбои в виртуальной машине Java.
     - `NoClassDefFoundError`: JVM не может найти определенный класс.
     - `UnsatisfiedLinkError`: Ошибка связывания нативных библиотек.

3. **Exception**:
   - Представляет исключительные ситуации, которые можно обработать в программе.
   - Делится на две категории:

   **Checked Exceptions**:
   - Исключения, которые обязательно должны быть обработаны или объявлены в сигнатуре метода.
   - **Примеры:**
     - `IOException`: Ошибка ввода-вывода, например, при чтении файла.
     - `SQLException`: Ошибка при работе с базами данных.
     - `FileNotFoundException`: Файл не найден.
     - `ClassNotFoundException`: Класс не найден.
     - `ParseException`: Ошибка анализа данных, например, при разборе даты.
     - `InterruptedException`: Поток был прерван.

   **Unchecked Exceptions (Runtime Exceptions)**:
   - Исключения, которые не требуют обязательной обработки.
   - **Примеры:**
     - `NullPointerException`: Попытка обращения к объекту через `null`.
     - `ArrayIndexOutOfBoundsException`: Доступ к несуществующему индексу массива.
     - `ArithmeticException`: Ошибка математической операции, например, деление на ноль.
     - `ClassCastException`: Неправильное приведение типов.
     - `IllegalArgumentException`: Некорректный аргумент метода.
     - `NumberFormatException`: Ошибка преобразования строки в число.
     - `IllegalStateException`: Неверное состояние объекта для вызова метода.

### **Ключевые различия между Error и Exception:**
- **Error:** Серьезные системные сбои, обработка обычно невозможна. Например, нехватка памяти.
- **Exception:** Ошибки программы, которые можно и нужно обрабатывать. Например, неправильный ввод пользователя.



[К содержанию](#content)

---

## 🔸 Обработка исключений <a id="обработка-исключений"></a>

Обработка исключений в Java осуществляется с помощью блоков `try-catch-finally` и оператора `throw/throws`.

1. **try**:
   - Блок кода, который может выбросить исключение.
   - Синтаксис:
     ```java
     try {
         // Код, который может выбросить исключение
     }
     ```

2. **catch**:
   - Блок для обработки конкретного типа исключения.
   - Можно использовать несколько блоков `catch` для разных типов исключений.
   - Синтаксис:
     ```java
     catch (ExceptionType e) {
         // Обработка исключения
     }
     ```

3. **finally**:
   - Блок, который выполняется всегда, независимо от того, было ли выброшено исключение.
   - Используется для освобождения ресурсов (например, закрытие файлов, соединений с базами данных).
   - Синтаксис:
     ```java
     finally {
         // Код, который выполняется всегда
     }
     ```

4. **throw**:
   - Оператор для явного выброса исключения.
   - Синтаксис:
     ```java
     throw new ExceptionType("Сообщение об ошибке");
     ```

5. **throws**:
   - Ключевое слово для указания, что метод может выбросить определенное исключение.
   - Синтаксис:
     ```java
     public void someMethod() throws ExceptionType {
         // Код метода
     }
     ```

6. **Пример полной конструкции**:
   ```java
   try {
       // Код, который может выбросить исключение
   } catch (SpecificException e) {
       // Обработка конкретного исключения
   } catch (AnotherException e) {
       // Обработка другого исключения
   } finally {
       // Код, который выполняется всегда
   }
   ```
   
7. **Автоматическое управление ресурсами (try-with-resources)**:
Для использования механизма try-with-resources в Java необходимо, чтобы объект, который вы хотите использовать в блоке try, реализовывал интерфейс **AutoCloseable**     
   Введено в Java 7 для автоматического закрытия ресурсов, таких как файлы или соединения с базами данных.
   Синтаксис:
   ```java
   try (Resource resource = new Resource()) {
    // Код, который использует ресурс
   } catch (Exception e) {
    // Обработка исключения
   }
   ```
   
[К содержанию](#content)

---

# 🟤 Современные API <a id="современные-api"></a>

## 🔹 Stream API 1️⃣2️⃣<a id="stream-api"></a>



[К содержанию](#content)

---

## 🔹 Лямбда-выражения9️⃣ <a id="лямбда-выражения"></a>



[К содержанию](#content)

---

## 🔹 Функциональные интерфейсы


[К содержанию](#content)

---

# 🗂️Коллекции <a id="коллекции"></a>

## 🔸 Java Collections и Map 7️⃣<a id="java-collections-и-map"></a>



[К содержанию](#content)

---

# ⭕ Глубокие концепции Java <a id="глубокие-концепции-java"></a>

## 🔹 Коллизия <a id="коллизия"></a>

Коллизия в программировании — это ситуация, когда два или более элемента данных сталкиваются, нарушая ожидаемое поведение системы. Чаще всего коллизии рассматриваются в контексте хэш-функций.

**Пример:** 
В хэш-таблицах коллизия возникает, если два ключа имеют одинаковый хэш-значение и попадают в одно и то же "ведро" (bucket).

**Методы разрешения коллизий:**
- **Цепочки (Chaining):** Каждый bucket содержит список элементов, и при коллизии новый элемент добавляется в этот список.
- **Открытая адресация (Open Addressing):** Найдется другое свободное место для хранения элемента.
- **Сбалансированные хэш-функции:** Минимизация вероятности коллизий через улучшенные алгоритмы хэширования.

[К содержанию](#content)

---

## 🔹 Рефлексия <a id="рефлексия"></a>

Рефлексия — это механизм, с помощью которого программа может анализировать и изменять свое поведение во время выполнения.

**Возможности рефлексии:**
- Извлечение информации о классах, методах, конструкторах, полях и аннотациях.
- Динамическое создание объектов и вызов методов.
- Работа с приватными полями и методами (с нарушением инкапсуляции).

**Недостатки рефлексии:**
- Снижение производительности.
- Нарушение принципов инкапсуляции.
- Усложнение отладки.

**Пример использования:**
Рефлексия активно применяется в фреймворках (например, Spring) для создания динамического поведения.

[К содержанию](#content)

---

## 🔹 Хэш-таблица <a id="хэш-таблицы"></a>

**Хэш-таблица** — это структура данных, которая обеспечивает быстрый доступ к элементам на основе ключей. Элементы хранятся в массиве, доступ к которым осуществляется с использованием хэш-функции.

### 🔸 Ключевые элементы хэш-таблицы:

1. **Ключ (Key):** 
   Уникальная идентифицирующая информация, которая используется для нахождения значения. Например, ключом может быть строка или число.

2. **Хэш-функция:** 
   Алгоритм, который преобразует ключ в целочисленное значение (индекс). Это значение указывает, где хранить данные в массиве.

3. **Бакет (Bucket):** 
   Место в массиве, куда помещаются значения. Если несколько ключей имеют одинаковый хэш-код, то они хранятся в одном бакете, используя метод разрешения коллизий.

4. **Коллизия:** 
   Ситуация, когда два ключа генерируют одинаковый хэш-код. Это приводит к размещению нескольких элементов в одном бакете.

### 🔸 Методы разрешения коллизий:

1. **Метод цепочек (Chaining):** 
   Каждый бакет содержит список (или другую структуру данных), чтобы хранить элементы при коллизии.

2. **Открытая адресация (Open Addressing):** 
   Новый элемент помещается в другую свободную ячейку массива, если произошла коллизия.

3. **Перехэширование (Rehashing):** 
   Использование альтернативной хэш-функции для повторного распределения элементов.

### 🔸 Преимущества хэш-таблиц:

- Быстрый доступ к данным по ключу: поиск, добавление и удаление происходят за **O(1)** в среднем случае.
- Эффективность работы при большом количестве элементов.

### 🔸 Недостатки:

- Хэш-таблицы требуют хорошей хэш-функции для минимизации коллизий.
- Потребление памяти из-за необходимости хранения массива, включая пустые бакеты.

[К содержанию](#content)

---

## 🔹 Очереди и стеки <a id="очереди-стек"></a>

**Очередь** — структура данных, работающая по принципу FIFO (First-In-First-Out).  
**Стек** — структура данных, работающая по принципу LIFO (Last-In-First-Out).  

**Различия:**
- Очередь позволяет добавлять элементы в конец и удалять с начала.
- Стек позволяет добавлять и удалять элементы только с одного конца.

**Примеры использования:**
- Очередь: управление задачами в многопоточных приложениях.
- Стек: выполнение операций обратной польской записи.

[К содержанию](#content)

---


# 🏆Структуры данных и обобщения (Generics) <a id="generics"></a>

## 🔹 hashCode и equals + Хеш-таблицы, buckets <a id="hashcode-и-equals-хеш-таблицы-buckets"></a>

1. **Что такое hashCode?**  
**Метод hashCode** — это метод, который возвращает целочисленное значение (хеш-код), представляющее объект. Это значение используется для определения положения объекта в структурах данных, основанных на хеш-таблицах, таких как HashMap, HashSet или Hashtable.  

**Зачем нужен hashCode?**  
Хеш-код помогает ускорить операции поиска, добавления и удаления элементов в коллекциях. Например, в HashMap объекты размещаются в "бакеты" (ячейки) на основе их хеш-кода. Таким образом, чтобы найти объект, программа сначала вычисляет его хеш-код и сразу переходит к соответствующему бакету, а не проверяет каждый элемент по очереди.  

**Основные правила работы с hashCode:** 
Связь с методом equals:  
Если два объекта считаются равными согласно методу equals, их хеш-коды должны быть одинаковыми.  
Однако если хеш-коды одинаковые, это не означает, что объекты равны (возможны коллизии). 
**Коллизия в контексте Java** — это ситуация, когда два или более различных объекта имеют одинаковый хэш-код и попадают в одно и то же "ведро" (bucket) в хэш-таблице. Это происходит при использовании таких структур данных, как HashMap или HashSet.  
Решение коллизий (теория):  
  - Метод цепочек (Chaining): Каждый bucket хранит список элементов. Если происходит коллизия, новый элемент добавляется в список.  
  - Открытая адресация (Open Addressing): При коллизии ищется другое свободное место в массиве для хранения элемента.  
  - Реализация собственных хэш-функций: Хэш-функции должны быть хорошо сбалансированными, чтобы минимизировать вероятность коллизий.  
Переопределение:  
По умолчанию метод hashCode наследуется от класса Object и вычисляет хеш-код на основе адреса объекта в памяти.  
Если вы переопределяете метод equals (например, для сравнения объектов по содержимому полей), вам также нужно переопределить hashCode, чтобы обеспечить корректную работу коллекций.  
Консистентность:  
Хеш-код должен оставаться постоянным для одного и того же объекта, пока его состояние (поля), влияющие на вычисление хеш-кода, не меняется.  


2. **Что такое equals?**
Метод equals используется для проверки равенства двух объектов на основе их содержимого, а не их ссылок в памяти. По умолчанию метод equals, унаследованный от класса Object, сравнивает объекты по их ссылкам (то есть проверяет, указывают ли две переменные на один и тот же объект в памяти). Однако часто требуется сравнивать объекты по их состоянию (например, значениям полей).

**Зачем нужен equals?**
Когда вы создаете собственный класс, вам может потребоваться определить, какие объекты считаются равными с точки зрения логики программы. Например:  
  
Два объекта Person могут считаться равными, если у них одинаковые имя и возраст.  
Два объекта Book могут быть равны, если у них одинаковый ISBN.  
Переопределение метода equals позволяет реализовать такую логику сравнения.  
  
Основные правила работы с equals:  
Связь с hashCode:  
Если два объекта равны согласно методу equals, их хеш-коды должны быть одинаковыми.  
Это правило необходимо для корректной работы коллекций, таких как HashMap или HashSet.  
Симметричность:  
Если a.equals(b) возвращает true, то b.equals(a) также должен возвращать true.  
Транзитивность:  
Если a.equals(b) и b.equals(c) возвращают true, то a.equals(c) тоже должен возвращать true.  
Последовательность:  
Результат equals должен оставаться постоянным, пока состояние объектов не меняется.  
Сравнение с null:  
Метод equals никогда не должен выбрасывать исключение при сравнении с null. Вместо этого он должен возвращать false.  
  
3.**Что такое хеш-таблицы и бакеты?**
**Хеш-таблица** — это эффективная структура данных, которая позволяет быстро выполнять операции добавления, удаления и поиска элементов. Она основана на использовании хеш-функции , которая преобразует ключ объекта в целочисленное значение (хеш-код), которое определяет, в какую ячейку (бакет) таблицы будет помещен этот объект.

**Как работает хеш-таблица?**  
**Хеш-функция:**  
Когда вы добавляете элемент в хеш-таблицу, его ключ обрабатывается хеш-функцией, которая вычисляет целочисленное значение (хеш-код). Это значение используется для определения конкретного бакета, куда будет помещен элемент.   
**Бакеты:**  
Бакеты — это внутренние ячейки хеш-таблицы. Каждый бакет может содержать один или несколько элементов. Хеш-код указывает, в какой бакет поместить элемент.  
**Поиск элемента:**  
При поиске элемента по ключу хеш-функция снова вычисляет хеш-код, чтобы найти нужный бакет. После этого выполняется сравнение с помощью метода equals, чтобы убедиться, что найденный элемент действительно соответствует ключу.  

[К содержанию](#content)

---

## 🔹 Generics: общее понимание 1️⃣1️⃣<a id="generics-общее-понимание"></a>

Generics (обобщения) позволяют создавать классы, интерфейсы и методы, работающие с различными типами данных, при этом сохраняя типобезопасность.

**Дженерики:**
Дженерики позволяют параметризировать классы, интерфейсы и методы типами. Это улучшает безопасность типов на этапе компиляции и делает код более устойчивым к ошибкам.

**Ковариантность:**
Ковариантность позволяет использовать более специфичные типы по сравнению с указанным. Она полезна для чтения данных, но может ограничить возможность записи.

**Контрвариантность:**
Контрвариантность допускает использование более общих типов. Она часто применяется там, где важна запись данных в коллекцию, но чтение ограничено объектами базового типа.

**Инвариантность:**
Инвариантность подразумевает, что обобщённый тип нельзя заменить другим, даже если они связаны отношениями наследования. Для работы с наследованием используются ковариантные или контрвариантные wildcards.


### Таблица: Что такое Generics в Java

| Понятие               | Определение                                                                 |
|-----------------------|-----------------------------------------------------------------------------|
| **Generics**          | Механизм, позволяющий создавать классы, интерфейсы и методы, которые работают с параметризованными типами. Это позволяет избежать явного приведения типов и обеспечивает более безопасную работу с данными во время компиляции. |
| **Типовые параметры** | Параметры типа (например, `<T>`, `<E>`, `<K, V>`), используемые для указания типа данных, который будет использоваться в классе, методе или интерфейсе. Они могут представлять любой тип, например, `String`, `Integer` или пользовательский класс. |
| **Преимущества**      | - **Безопасность типов**: Компилятор проверяет соответствие типов на этапе компиляции, предотвращая ошибки времени выполнения.<br>- **Устранение приведения типов**: Уменьшается необходимость использования оператора `(Type)` для преобразования объектов.<br>- **Код переиспользование**: Одна реализация может работать с разными типами данных. |
| **Ограничения типов**  | Возможность ограничить типы, которые могут быть использованы с generics, с помощью ключевого слова `extends`. Например, `<T extends Number>` означает, что параметр типа должен быть подклассом `Number`. |
| **Wildcards**         | Используются для работы с неизвестными типами данных. Существует три основных вида:<br>- `?` — любой тип.<br>- `<? extends T>` — любой тип, являющийся подтипом `T`.<br>- `<? super T>` — любой тип, являющийся надтипом `T`. |
| **Необходимость**     | Generics особенно полезны при работе с коллекциями, так как они позволяют хранить элементы одного типа, исключая возможность добавления неправильных типов данных. Например, `List<String>` может содержать только строки. |
| **Стерилизация**       | Когда код, использующий generics, компилируется, компилятор выполняет процесс стирания типов (type erasure). Это означает, что в байт-коде все типовые параметры заменяются их ограничениями (или `Object`, если ограничений нет). |
| **Недостатки**        | - Невозможность создания экземпляров параметризованного типа (`new T()` недопустимо).<br>- Нельзя использовать примитивные типы (например, `int`, `char`) в качестве параметров типа; вместо них нужно использовать обертки (`Integer`, `Character`). |


### Таблица: Виды Generics в Java

| Вид Generics            | Описание                                                                                         | Пример использования                                   |
|-------------------------|--------------------------------------------------------------------------------------------------|-------------------------------------------------------|
| **Простые Generics**    | Базовый тип параметризации, где используется один параметр типа для обобщения.                   | `List<T>` — коллекция объектов типа `T`.              |
| **Множественные Generics** | Позволяет использовать несколько параметров типов одновременно.                                  | `Map<K, V>` — словарь с ключами типа `K` и значениями типа `V`. |
| **Ограниченные Generics** | Указывает ограничения на типы, которые могут быть использованы с generics.                       | `<T extends Number>` — `T` должен быть подклассом `Number`. |
| **Нижние границы Generics** | Указывает, что тип должен быть надтипом указанного класса.                                       | `<T super Integer>` — `T` должен быть надтипом `Integer`. |
| **Wildcards (Звездочки)** | Используются для работы с неизвестными или универсальными типами данных.                         |                                                         |
|   - **Unbounded Wildcard** | Обозначает любой тип (`?`).                                                                      | `List<?>` — список любого типа.                        |
|   - **Upper Bounded Wildcard** | Обозначает тип, который является подклассом указанного класса (`<? extends T>`).               | `List<? extends Number>` — список подклассов `Number`.|
|   - **Lower Bounded Wildcard** | Обозначает тип, который является надклассом указанного класса (`<? super T>`).                 | `List<? super Integer>` — список надклассов `Integer`.|
| **Статические Generics**  | Позволяет создавать статические методы, поддерживающие параметры типов.                           | `public static <T> void printArray(T[] array)`        |
| **Generic Methods**     | Методы, которые принимают или возвращают параметризованные типы, независимо от класса.             | `public <T> T getFirstElement(List<T> list)`          |
| **Generic Classes**     | Классы, которые определены с параметрами типов, позволяя работать с различными типами данных.       | `public class Box<T> { private T content; }`          |
| **Generic Interfaces**  | Интерфейсы, которые используют параметры типов для абстракции различных типов данных.              | `public interface Comparator<T> { int compare(T o1, T o2); }` |
| **Type Erasure**        | Процесс, при котором компилятор заменяет все параметры типов на их ограничения или `Object`.       | Компилятор преобразует `List<String>` в `List<Object>`.|

1. **Основная идея**:
   - Generics обеспечивают возможность использовать параметризованные типы, что позволяет избежать приведения типов и уменьшить количество ошибок во время выполнения.
   - Пример:
     ```java
     List<String> list = new ArrayList<>();
     listadd("Hello");
     String str = listget(0); // Без явного приведения типа
     ```

2. **Ограничения типов**:
   - Можно указывать ограничения для параметров типа с помощью ключевого слова `extends`.
   - Пример:
     ```java
     class Box<T extends Number> {
         private T value;
         public void set(T value) { thisvalue = value; }
         public T get() { return value; }
     }
     ```

3. **Wildcards**:
   - Используются для работы с неизвестными типами.
   - Пример:
     ```java
     List<?> list = new ArrayList<>(); // Любой тип
     List<? extends Number> numbers = new ArrayList<>(); // Подтип Number
     List<? super Integer> integers = new ArrayList<>(); // Супертип Integer
     ```

4. **Type Erasure**:
   - Во время компиляции информация о типах generics удаляется (type erasure), поэтому generics работают только на уровне компиляции.
   - Это может привести к ограничениям, например, нельзя создать новый экземпляр параметризованного типа.

[К содержанию](#content)

---

# 👑Управление памятью и работа со ссылками <a id="memory"></a>

## 🔸 Управление памятью, сборщик мусора - Memory Management, Garbage Collection4️⃣ <a id="память"></a>

В Java управление памятью автоматизировано, что делает язык более безопасным и удобным для использования. Память делится на несколько областей:

**Stack (Стек)** : Хранит локальные переменные и информацию о вызовах методов. Каждый поток имеет свой собственный стек.  
**Heap (Куча)** : Общая область памяти, где создаются все объекты. Управление памятью здесь осуществляется через механизм сборки мусора.  
**Method Area (Область методов)** : Хранит метаданные классов, такие как имена, типы и код методов.  
**PC Register (Регистр команд)** : Отслеживает текущую выполняемую инструкцию для каждого потока.  
**Native Method Stack (Стек нативных методов)** : Используется для выполнения методов, написанных на других языках программирования.  

Сборщик мусора (Garbage Collector) автоматически удаляет объекты, которые больше недоступны для программы. Это позволяет разработчику не беспокоиться о ручном освобождении памяти, снижая риск утечек.

#### finalize() метод
Метод **finalize()** — это специальный метод в Java, который был предназначен для выполнения очистки ресурсов перед тем, как объект будет удален сборщиком мусора. Однако его использование считается устаревшим и не рекомендуется в современных приложениях.  

**Что такое finalize()?**  
Метод finalize() определен в классе Object и может быть переопределен в подклассах.  
Он вызывается JIT-компилятором (Just-In-Time Compiler) перед удалением объекта сборщиком мусора.  
Его основное назначение — выполнить действия по очистке ресурсов (например, закрыть файлы, сокеты или другие внешние ресурсы).  

**Альтернативы finalize()**
Современные подходы к управлению ресурсами в Java:

**Интерфейс AutoCloseable и конструкция try-with-resources:**    
Используется для автоматического закрытия ресурсов (например, файлов, соединений с базой данных).  
После выхода из блока try, ресурс автоматически закрывается.    
**Ручное управление ресурсами:**  
Явно вызывать методы для освобождения ресурсов (например, close() для файлов или disconnect() для сетевых соединений).  
**Финализаторы заменены на Cleaner и PhantomReference:**  
В Java 9 появился класс **java.lang.ref.Cleaner**, который является более эффективной альтернативой **finalize()**.  
**PhantomReference** позволяет отслеживать объекты, готовые к сборке мусора, без использования **finalize()**.  

## 1. **Stack (Стек)**
- Используется для хранения локальных переменных и информации о вызовах методов.
- Каждый поток имеет свой собственный стек.
- Локальные переменные, примитивные типы данных и ссылки на объекты хранятся здесь.
- Размер стека ограничен, что может привести к `StackOverflowError`, если глубина вызовов методов слишком велика.

## 2. **Heap (Куча)**
- Общая область памяти для всех потоков, где создаются объекты.
- Управление памятью в куче осуществляется автоматически через механизм сборки мусора (Garbage Collector).
- Все объекты, созданные с помощью оператора `new`, выделяются в куче.
- Размер кучи можно настраивать через параметры JVM.

## 3. **Method Area (Область методов)**
- Часть памяти, используемая для хранения структуры классов, таких как метаданные классов, код методов и константы.
- Включает в себя **String Pool** — пул строк, где хранятся литеральные строки.
- Является общей для всех потоков.

## 4. **PC Register (Регистр команд)**
- Содержит адрес текущей выполняемой инструкции для каждого потока.
- Отслеживает порядок выполнения команд.

## 5. **Native Method Stack (Стек нативных методов)**
- Используется для выполнения нативных методов (методов, написанных на языках, отличных от Java, таких как C или C++).
- Аналогичен обычному стеку, но专门为 нативный код.

## 6. **Garbage Collector (Сборщик мусора)**
- Автоматический механизм очистки памяти в куче.
- Освобождает память, занимаемую объектами, которые больше не доступны для программы.
- Работает асинхронно и может временно приостанавливать выполнение программы (pause).

[К содержанию](#content)

---

## 🔸 Строки и пул строк(Pool string) <a id="строки-и-пул-строк"></a>

Строки в Java являются неизменяемыми (`immutable`), что означает, что их содержимое нельзя изменить после создания.

**Пул строк** — это специальная область памяти в Java Heap(Куча), где хранятся литеральные строки (строки, объявленные как "текст"). JVM автоматически управляет этим пулом для оптимизации использования памяти. Если строка уже существует в пуле, вместо создания новой копии ссылается на существующий объект.

**Строка (String)** в Java представляет собой неизменяемую (иммутабельную) последовательность символов. Класс String является частью пакета java.lang и используется для работы с текстовыми данными. Поскольку строки являются иммутабельными, любая операция, изменяющая строку (например, конкатенация или замена символов), на самом деле создает новую строку.

1. **Пул строк**:
   - Java автоматически сохраняет строки в пуле для оптимизации использования памяти.
   - Если строка уже существует в пуле, создается ссылка на существующую строку, а не новая копия.
   - Пример:
     ```java
     String str1 = "Hello";
     String str2 = "Hello";
     Systemoutprintln(str1 == str2); // true, так как строки берутся из пула
     ```

2. **new String**:
   - Создание строки с использованием оператора `new` всегда приводит к созданию нового объекта в памяти, даже если такая строка уже существует в пуле.
   - Пример:
     ```java
     String str3 = new String("Hello");
     Systemoutprintln(str1 == str3); // false, так как str3 создан вне пула
     ```

3. **intern**:
   - Метод `intern()` добавляет строку в пул, если её там нет.
   - Пример:
     ```java
     String str4 = new String("Hello").intern();
     Systemoutprintln(str1 == str4); // true, так как str4 теперь ссылается на строку из пула
     ```
[К содержанию](#content)

---

## 🔸 Каллизия (Call-by-value и Call-by-reference) <a id="call-by-value"></a>

### Каллизия (Call-by-value и Call-by-reference)

#### 1. **Call-by-value**
- При передаче параметров по значению (**call-by-value**) в метод копируется значение аргумента.
- Любые изменения, произведенные внутри метода с этими параметрами, не влияют на оригинальные данные за пределами метода.

#### 2. **Особенность Java: Объекты передаются через ссылки, но все еще call-by-value**
- В Java используется только **call-by-value**, даже при работе с объектами.
- Когда передается объект, kopия ссылки на этот объект передается в метод.
- Это позволяет изменять состояние объекта (например, его поля) внутри метода, но не позволяет заменить сам объект на другой.

#### 3. **Сравнение Call-by-value и Call-by-reference**

| **Особенность**           | **Call-by-value**                                                                 | **Call-by-reference**                                                                 |
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| **Передача данных**       | Передается копия значения или ссылки.                                           | Передается сама ссылка на данные.                                                   |
| **Изменение параметров**   | Изменения внутри метода не влияют на оригинальные данные.                       | Изменения внутри метода влияют на оригинальные данные.                              |
| **Java**                  | Используется только call-by-value, даже для объектов (передается копия ссылки). | Языки, такие как C++ или Python, поддерживают call-by-reference для некоторых типов. |

#### 4. **Важно помнить**
- В Java всегда используется **call-by-value**.
- Для примитивных типов передается копия значения.
- Для объектов передается копия ссылки, что позволяет изменять состояние объекта, но не заменять сам объект.

[К содержанию](#content)

---

# 💡 Фундаментальные концепции <a id="фундаментальные"></a>

## 🔹 Методы класса Object <a id="методы-класса-object"></a>

### Таблица: Методы класса Object

| Метод                          | Возвращаемый тип | Описание                                                                                       |
|--------------------------------|------------------|------------------------------------------------------------------------------------------------|
| `toString()`                   | `String`         | Возвращает строковое представление объекта. Может быть переопределен для более осмысленного вывода. |
| `equals(Object obj)`           | `boolean`        | Сравнивает этот объект с указанным объектом (`obj`). По умолчанию сравнивает ссылки.            |
| `hashCode()`                   | `int`            | Возвращает хэш-код объекта. Должен быть согласован с методом `equals()`.                        |
| `clone()`                      | `Object`         | Создает и возвращает копию объекта. Класс должен реализовать интерфейс `Cloneable`.             |
| `finalize()`                   | `void`           | Вызывается перед сборкой мусора. Устаревший с Java 9, не рекомендуется использовать.            |
| `getClass()`                   | `Class<?>`       | Возвращает объект типа `Class`, представляющий класс этого объекта.                            |
| `notify()`                     | `void`           | Будит один поток, который ждет на этом объекте. Используется в многопоточности.                 |
| `notifyAll()`                  | `void`           | Будит все потоки, которые ждут на этом объекте.                                                |
| `wait()`                       | `void`           | Приостанавливает выполнение текущего потока, пока другой поток не вызовет `notify()` или `notifyAll()`. |
| `wait(long timeout)`           | `void`           | Аналогично `wait()`, но с таймаутом в миллисекундах.                                           |
| `wait(long timeout, int nanos)`| `void`           | Аналогично `wait(long timeout)`, но с точностью до наносекунд.                                 |

Класс `Object` является суперклассом всех классов в Java. Он предоставляет базовые методы, которые могут быть переопределены в подклассах.


1. **toString**:
   - Возвращает строковое представление объекта.
   - Переопределяется для удобного вывода информации о состоянии объекта.
   - Пример:
     ```java
     @Override
     public String toString() {
         return "MyClass{" + "field1=" + field1 + ", field2=" + field2 + '}';
     }
     ```

2. **equals**:
   - Описан выше. Используется для сравнения объектов.

3. **hashCode**:
   - Описан выше. Используется для работы с хеш-таблицами.

4. **clone**:
   - Создает копию объекта. Требует реализации интерфейса `Cloneable`.
   - Пример:
     ```java
     @Override
     protected MyClass clone() throws CloneNotSupportedException {
         return (MyClass) super.clone();
     }
     ```

5. **finalize** (устаревший):
   - Вызывается перед сборкой мусора для выполнения очистки ресурсов.
   - Не рекомендуется использовать из-за неопределённости времени вызова.

6. **getClass**:
   - Возвращает объект `Class`, представляющий тип объекта.

7. **wait/notify/notifyAll**:
   - Используются для синхронизации потоков.
   - Пример:
     ```java
     synchronized (this) {
         wait(); // Приостанавливает текущий поток
         notify(); // Пробуждает один поток
     }
     ```
[К содержанию](#content)

---

## 🔹 Базовый синтаксис - Basic Syntax3️⃣ <a id="basic"></a>

**JVM, Java Virtual Machine (Виртуальная машина Java)** — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java.

**JRE, Java Runtime Environment (Среда времени выполнения Java)** - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений.

**JDK, Java Development Kit (Комплект разработки на Java)** - среда для разработки программ на Java, включающая в себя JRE - среду для обеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java программ.

**Java** — строго типизированный язык программирования, требующий явного объявления типов переменных. Программа всегда начинается с класса, который содержит метод main. Этот метод является точкой входа программы.

Основные правила синтаксиса включают:

Все операции выполняются внутри блоков, ограниченных фигурными скобками {}.
Инструкции завершаются точкой с запятой (;).
Комментарии пишутся с помощью // (однострочный) или /* ... */ (многострочный).

Структура программы включает объявление переменных, методов и классов. Каждый класс может содержать поля (переменные), методы (функции) и конструкторы для создания объектов.

Метод **main** является основной точкой входа в программу на Java. Без этого метода программа не сможет быть выполнена, так как JVM (Java Virtual Machine) ищет именно его для запуска.

[К содержанию](#content)

---

## 🔹 Интерфейсы - Interface5️⃣ <a id="interface"></a>
  
Интерфейсы в Java — это как "правила игры", которые класс должен соблюдать. Они помогают определить, какие действия объект должен уметь выполнять, но не указывают, как именно их выполнять.

### **Что такое интерфейс?**
**Интерфейс** — это набор методов без реализации (то есть без тела), который классы обязаны реализовать.  
Когда класс реализует интерфейс, он **гарантирует выполнение всех методов**, описанных в интерфейсе.

### Особенности интерфейсов 📝

#### Абстрактные методы
- Методы без тела (реализации).  
- Классы, реализующие интерфейс, **обязаны предоставить реализацию** всех абстрактных методов.

#### Константы
- Переменные с модификаторами `public static final`.  
- Доступны всем классам, реализующим интерфейс.  
- Неизменяемы (константы).  

#### Методы по умолчанию (default)
- Добавлены с **Java 8**.  
- Содержат **реализацию по умолчанию**.  
- Позволяют добавлять новые методы в интерфейс, не нарушая работу существующих классов.  

#### Статические методы
- Также появились с **Java 8**.  
- Вызываются напрямую через имя интерфейса.  
- Не могут быть переопределены в классах, реализующих интерфейс.  

### Зачем нужны интерфейсы? 🤔

#### Множественная реализация
- В Java класс может наследоваться только от **одного класса**, но реализовывать **несколько интерфейсов**.  
- Обеспечивает гибкость при проектировании.  

#### Общие контракты
- Определяют **единые правила** для множества классов.  
- Позволяют работать с объектами различных классов одинаково через ссылки на интерфейс.

## Типы интерфейсов 

| **Тип интерфейса**             | **Описание**                                                                                           | **Примеры интерфейсов**         |
|--------------------------------|-------------------------------------------------------------------------------------------------------|---------------------------------|
| **Маркерный**                  | Не содержит методов. Используется для **обозначения свойств** объектов.                                | `Serializable`, `Cloneable`    |
| **Функциональный**             | Содержит **один абстрактный метод**. Часто применяется в **лямбда-выражениях**.                       | `Runnable`, `Callable`, `Function<T, R>` |
| **Нормальный**                 | Содержит **один или более абстрактных методов** и может включать `default`, `static`, `private` методы. | `List`, `Map`, `Set`           |
| **Интерфейс с вложенными интерфейсами** | Может содержать вложенные интерфейсы для логической группировки или структурирования API.               | `Map.Entry<K, V>`              |
| **Потребительский (Consumer)** | Интерфейсы, которые **потребляют данные**, не возвращая результата. Используются в обработке данных.  | `Consumer<T>`, `BiConsumer<T, U>` |

[К содержанию](#content)

---

## 🔹 Методы <a id="методы"></a>

Методы в Java — это **блоки кода**, выполняющие определенные действия. Они обеспечивают **переиспользование кода**, **инкапсуляцию** и **структурирование программы**.

### Что такое метод? 📝

**Метод** — это именованный блок кода, который выполняет определенную задачу и может возвращать результат. Методы могут принимать параметры и могут быть вызваны несколько раз из различных мест программы.

### Основные особенности методов 🚩

#### Объявление метода
- Состоит из **модификаторов доступа**, **типа возвращаемого значения**, **имени метода** и **параметров** (если есть).  
- Пример объявления (без реализации): `public int add(int a, int b)`

#### Параметры метода
- Передаваемые значения, необходимые для выполнения метода.  
- Могут быть **примитивными типами** или **объектами**.  

#### Возвращаемое значение
- Тип, который метод возвращает (`int`, `String`, `void` и т. д.).  
- `void` означает, что метод **ничего не возвращает**.  

### Типы методов в Java 📚

| Тип метода                  | Описание                                                                                  |
|-----------------------------|--------------------------------------------------------------------------------------------|
| Статический метод           | Объявляется с ключевым словом `static`. Вызывается через имя класса.                      |
| Экземплярный метод          | Принадлежит объекту класса. Требует создания экземпляра для вызова.                       |
| Абстрактный метод           | Объявляется с ключевым словом `abstract`. Не имеет реализации. Реализуется в подклассах.   |
| Метод по умолчанию          | Объявляется в интерфейсах с ключевым словом `default`. Имеет реализацию.                  |
| Финализированный метод      | Объявляется с ключевым словом `final`. Не может быть переопределен в подклассах.          |
| Синхронизированный метод    | Объявляется с ключевым словом `synchronized`. Обеспечивает **потокобезопасность**.        |
| Конструктор                 | Специальный метод, вызываемый при создании объекта. Не имеет типа возвращаемого значения.  |
| Перегруженный метод         | Метод с тем же именем, но с разными параметрами.                                          |
| Нативный метод              | Объявляется с ключевым словом `native`. Реализуется вне Java (например, на C/C++).         |
| Private метод               | Объявляется с ключевым словом `private`. Доступен только внутри класса.                   |
| Protected метод             | Объявляется с ключевым словом `protected`. Доступен внутри пакета и в подклассах.          |
| Public метод                | Объявляется с ключевым словом `public`. Доступен из любого места программы.                |
| Пакетно-приватный метод     | Метод без модификатора доступа. Доступен только внутри пакета.                             |
| Метод с переменным числом аргументов | Объявляется с использованием `...` после типа параметра. Позволяет передавать произвольное количество аргументов. |
| Переопределенный метод      | Метод, который переопределяет метод родительского класса с помощью аннотации `@Override`.  |
| Лямбда-выражение            | Не является методом в классическом смысле, но используется как анонимная реализация функционального интерфейса. |
| Метод, объявленный в enum   | Метод, определенный внутри перечисления (`enum`). Может быть статическим или экземплярным. |
| Метод, объявленный в record | Метод, определенный внутри записи (`record`). Может быть как автоматически сгенерированным, так и пользовательским. |
| Метод, помеченный как `strictfp` | Объявляется с ключевым словом `strictfp`. Гарантирует одинаковое поведение операций с плавающей точкой на всех платформах. |
| Метод с возвращаемым значением | Метод, который возвращает значение определенного типа (например, `int`, `String`).        |
| Метод без возвращаемого значения | Метод, объявленный с типом возвращаемого значения `void`. Не возвращает никаких данных.   |

### Модификаторы доступа к методам 🔐

| Модификатор     | Описание                                           |
|----------------|----------------------------------------------------|
| `public`       | Доступен из любого класса.                         |
| `protected`    | Доступен из классов того же пакета и подклассов.    |
| `private`      | Доступен только внутри объявляющего класса.        |
| (Без модификатора) | Доступен только внутри пакета (package-private). |

### Специальные типы методов 🎯

#### Перегрузка (Overloading)
- Создание **нескольких методов с одним именем**, но разными параметрами.  
- Позволяет **разные способы вызова** метода в зависимости от параметров.  

#### Переопределение (Overriding)
- Позволяет подклассу **предоставить свою реализацию** метода, объявленного в суперклассе.  
- Требуется одинаковая сигнатура метода (имя, параметры и тип возвращаемого значения).  

### Методы в интерфейсах 📌

| Тип метода  | Описание                                                     |
|-------------|-------------------------------------------------------------|
| Абстрактный | Метод без реализации. Классы, реализующие интерфейс, должны его реализовать. |
| По умолчанию (default) | Метод с реализацией, добавленный с Java 8. |
| Статический | Метод, который можно вызывать через имя интерфейса.         |
| Приватный   | Метод, используемый внутри интерфейса для разбиения логики (Java 9 и выше). |

[К содержанию](#content)

---

## 🔹 Классы <a id="классы"></a>

Класс — это шаблон или структура в объектно-ориентированном программировании (ООП), которая описывает свойства (поля) и поведение (методы) объектов. Он используется для создания экземпляров (объектов), которые имеют одинаковые характеристики и поведение.

#### **Основные элементы класса:**
- **Поля:** Переменные, которые хранят данные или состояние объекта.
- **Методы:** Действия или функции, которые определяют поведение объекта.
- **Конструкторы:** Специальные методы для инициализации объектов при их создании.
- **Модификаторы доступа:** Указывают доступность элементов класса (например, `public`, `private`, `protected`).
- **Статические элементы:** Методы или поля, принадлежащие всему классу, а не конкретным объектам.

### **Типы классов**

| **Тип класса**              | **Описание**                                                                                 | **Примеры**               |
|-----------------------------|---------------------------------------------------------------------------------------------|---------------------------|
| **Обычные классы**          | Основные классы, которые используются для описания сущностей.                                | `Person`, `Animal`        |
| **Абстрактные классы**      | Классы, которые не могут быть инстанцированы и служат базой для других классов.             | `Shape`, `Vehicle`        |
| **Вложенные (Nested) классы** | Классы, определенные внутри других классов. Делятся на статические и нестатические.         | `Outer.Inner`             |
| **Анонимные классы**        | Классы без имени, которые обычно используются для переопределения методов интерфейсов.      | Реализация `Runnable`     |
| **Финальные классы**        | Классы, которые нельзя наследовать (объявляются с ключевым словом `final`).                 | `String`                  |
| **Классы-оболочки (Wrapper)** | Классы, которые оборачивают примитивные типы данных, чтобы работать с ними как с объектами. | `Integer`, `Double`       |
| **Иммутабельные классы**    | Классы, состояние объектов которых не может быть изменено после создания.                   | `String`, `BigDecimal`    |

### **Преимущества использования классов**
- Инкапсуляция данных и поведения.
- Повышение повторного использования кода за счет наследования.
- Легкость создания и работы с объектами.
- Улучшение структурирования программы.

[К содержанию](#content)

---

## 🔹 Множественное наследование - Multiple Inheritance🔟 <a id="multiple"></a>

Множественное наследование в Java: Почему интерфейсы, а не классы?

Что такое множественное наследование?

**Множественное наследование** — это когда один класс может брать свойства и методы сразу от нескольких родительских классов. Это как если бы вы могли научиться одновременно готовить, петь и танцевать, используя умения из разных людей.

**Почему Java не поддерживает множественное наследование через классы?**
Казалось бы, множественное наследование — это удобно, но оно может привести к серьезным проблемам:

**Конфликты методов** : Если два родителя имеют методы с одинаковым названием, какой из них выбрать? Компьютер запутается.
**Проблема алмазной формы**: Представьте такую цепочку:
Класс A — общий предок.
От него наследуются классы B и C.
Класс D наследуется от обоих B и C.
Если B и C переопределяют один и тот же метод из A, то как понять, чья версия нужна в D? Это вызывает путаницу.
Из-за этих сложностей Java решила отказаться от множественного наследования через классы.

**Как интерфейсы помогают решить эту проблему?**
Вместо классов Java предлагает использовать интерфейсы для множественного наследования. Интерфейсы — это как список правил, которые класс должен выполнить, но сам интерфейс не содержит конкретного кода.

Интерфейсы содержат только "шаблоны" методов : В них нет готового кода, только описание того, какие методы должны быть. 
Класс, который реализует этот интерфейс, сам решает, как именно будет летать.
Нет состояния (полей) : Интерфейсы не хранят данные, поэтому не возникает конфликтов из-за полей.
Методы по умолчанию (начиная с Java 8) : Теперь интерфейсы могут иметь методы с готовым кодом, помеченные как default. Но если несколько интерфейсов предоставляют одинаковые методы, класс должен явно выбрать, какой использовать. Это исключает неоднозначность.

[К содержанию](#content)

---

# 🏗️ Архитектурные подходы и паттерны проектирования  <a id="архитектура"></a> 

## 🔸 Группы паттернов проектирования  <a id="pattern"></a> 



[К содержанию](#content)

---

## 🔸 Термины - SOLID  <a id="термины-принципов-проектирования"></a> 


[К содержанию](#content)

---

