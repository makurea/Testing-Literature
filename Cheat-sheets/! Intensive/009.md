# Локаторы в веб-тестировании

## Что такое локатор и для чего он нужен?

Локатор — это способ нахождения элемента на веб-странице для взаимодействия с ним (например, для клика, ввода текста, проверки значений и т.д.). Локаторы используются в автоматизированных тестах и скриптах для поиска элементов на основе различных критериев.

## Абсолютный и относительный путь

### Абсолютный путь:
Абсолютный путь указывает полный путь к элементу начиная от корня документа (обычно это `<html>`). Он начинается с корня дерева DOM и включает все элементы, которые приводят к целевому элементу.

### Пример абсолютного пути:
```xpath
/html/body/div[1]/div[2]/button
```

### Относительный путь:
Относительный путь ищет элемент, начиная с определённого узла (например, родительского элемента), и не требует указания полного пути от корня документа. Он чаще используется, потому что более гибкий и краткий.

### Пример относительного пути:
```xpath
//div/button
```

## Разница между CSS и XPath

| Характеристика          | CSS                                         | XPath                                      |
|-------------------------|---------------------------------------------|--------------------------------------------|
| Синтаксис               | Краткий и лаконичный                        | Более гибкий, но сложный                   |
| Поддержка браузеров    | Поддерживается всеми основными браузерами   | Также поддерживается всеми основными браузерами |
| Производительность     | Чуть быстрее для простых запросов          | Может быть медленнее при сложных запросах |
| Удобство                | Простой синтаксис для большинства случаев   | Возможности выбора более сложных условий |
| Пример                  | `div > .class`                              | `//div[@class='class']`                   |

## По каким атрибутам можно искать элементы?

- **id** — уникальный идентификатор элемента на странице.
- **class** — CSS-класс элемента.
- **name** — имя элемента (например, для формы или input).
- **type** — тип элемента (например, для кнопки или текстового поля).
- **placeholder** — текст, который появляется в поле ввода.
- **value** — значение атрибута для элементов формы (например, кнопка отправки).

## Как найти элемент через CSS и XPath?

### Пример поиска элемента по CSS:

```css
#submit-button      /* По id */
.button-class       /* По классу */
input[name='email'] /* По имени атрибута */
```

### Пример поиска элемента по XPath:

```xpath
//*[@id='submit-button']        /* По id */
//div[@class='button-class']    /* По классу */
//input[@name='email']          /* По имени атрибута */
```

## Зачем нужен локатор типа `.//` и `./`?

- **`./`** — используется для поиска элемента относительно текущего узла. Это локатор для поиска в пределах родительского элемента.
- **`.//`** — используется для поиска элемента на текущем уровне и ниже. Это локатор для поиска элементов на текущем уровне и в дочерних элементах.

### Пример использования:

```xpath
./div/button   /* Находит button, который является прямым потомком div */
.//button      /* Находит все button в текущем элементе и всех его дочерних элементах */
```

## Оси XPath

XPath оси позволяют выбрать элементы относительно текущего узла. Вот несколько часто используемых осей:

| Ось          | Описание                                    | Пример                                     |
|--------------|---------------------------------------------|--------------------------------------------|
| **child**    | Выбирает прямых потомков текущего элемента. | `./child::div`                             |
| **descendant**| Выбирает все потомки текущего элемента.     | `.//div`                                   |
| **parent**   | Выбирает родительский элемент.              | `..`                                       |
| **following**| Выбирает элементы, которые следуют после текущего. | `.//div/following::p`                   |
| **preceding**| Выбирает элементы, которые предшествуют текущему. | `.//div/preceding::a`                    |

## Практика XPath и CSS

### Пример CSS:

1. Найти элемент с id:
```css
#login-form
```

2. Найти элемент по классу:
```css
.button
```

3. Найти элемент по атрибуту name:
```css
input[name='username']
```

### Пример XPath:

1. Найти элемент с id:
```xpath
//*[@id='login-form']
```

2. Найти элемент по классу:
```xpath
//div[@class='button']
```

3. Найти элемент по атрибуту name:
```xpath
//input[@name='username']
```

Эти локаторы можно использовать в автоматизированных тестах или скриптах для взаимодействия с элементами на веб-странице.

# Инициализация браузера с использованием Selenium WebDriver

## Что такое Selenium WebDriver?

**Selenium WebDriver** — это инструмент для автоматизации браузеров, который предоставляет интерфейс для управления браузером программно. Он позволяет запускать браузеры, имитировать действия пользователя (клики, ввод текста, навигация) и тестировать веб-приложения.

WebDriver позволяет взаимодействовать с браузером, эмулируя действия пользователя, и поддерживает работу с несколькими браузерами, такими как Chrome, Firefox, Safari и Edge.

## JSON Wire Protocol

**JSON Wire Protocol** — это протокол, который использует Selenium WebDriver для взаимодействия с браузером. Он определяет правила, по которым WebDriver может отправлять команды в браузер и получать результаты в формате JSON. Этот протокол был основным в старых версиях Selenium, но с выпуском WebDriver API был заменён на более универсальный HTTP протокол, что улучшило производительность и упрощение работы.

## Где прописать путь к драйверам?

Чтобы WebDriver мог управлять браузером, нужно указать путь к соответствующему драйверу для каждого браузера:

- Для **Chrome**: `chromedriver`
- Для **Firefox**: `geckodriver`
- Для **Edge**: `msedgedriver`

Путь к драйверам можно прописывать в коде, но удобнее всего хранить их в системной переменной PATH или указывать путь через настройки в коде.

### Пример указания пути к драйверу:

```java
System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
```

Можно указать путь через переменную окружения:

```bash
export PATH=$PATH:/path/to/chromedriver
```

## Реализация инициализации WebDriver

Инициализация WebDriver зависит от выбранного браузера. Пример инициализации для разных браузеров:

### Инициализация для Chrome:

```java
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;

System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
WebDriver driver = new ChromeDriver();
driver.get("https://www.example.com");
```

### Инициализация для Firefox:

```java
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;

System.setProperty("webdriver.gecko.driver", "path/to/geckodriver");
WebDriver driver = new FirefoxDriver();
driver.get("https://www.example.com");
```

### Инициализация для Edge:

```java
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.edge.EdgeDriver;

System.setProperty("webdriver.edge.driver", "path/to/msedgedriver");
WebDriver driver = new EdgeDriver();
driver.get("https://www.example.com");
```

## Реализация инициализации Singleton и абстрактной фабрики

### Singleton:

Шаблон **Singleton** гарантирует, что будет создан только один экземпляр WebDriver, который будет использоваться по всему приложению. Это полезно для предотвращения создания нескольких экземпляров WebDriver.

```java
public class WebDriverSingleton {
    private static WebDriver driver;

    private WebDriverSingleton() {}

    public static WebDriver getDriver() {
        if (driver == null) {
            System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
            driver = new ChromeDriver();
        }
        return driver;
    }

    public static void quitDriver() {
        if (driver != null) {
            driver.quit();
            driver = null;
        }
    }
}
```

### Абстрактная фабрика:

**Абстрактная фабрика** — это шаблон проектирования, который предоставляет интерфейсы для создания семейств взаимосвязанных объектов, не уточняя их конкретных классов.

Пример реализации абстрактной фабрики для создания разных драйверов:

```java
interface BrowserFactory {
    WebDriver createDriver();
}

class ChromeFactory implements BrowserFactory {
    @Override
    public WebDriver createDriver() {
        System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
        return new ChromeDriver();
    }
}

class FirefoxFactory implements BrowserFactory {
    @Override
    public WebDriver createDriver() {
        System.setProperty("webdriver.gecko.driver", "path/to/geckodriver");
        return new FirefoxDriver();
    }
}

public class BrowserFactoryProducer {
    public static BrowserFactory getFactory(String browserType) {
        if (browserType.equalsIgnoreCase("chrome")) {
            return new ChromeFactory();
        } else if (browserType.equalsIgnoreCase("firefox")) {
            return new FirefoxFactory();
        }
        return null;
    }
}
```

## Возможности браузера

WebDriver предоставляет множество методов для взаимодействия с браузером, такими как:

- **driver.get(url)** — Переход к указанному URL.
- **driver.findElement(By locator)** — Поиск элемента на странице.
- **driver.quit()** — Закрытие браузера.
- **driver.manage().window().maximize()** — Максимизация окна браузера.
- **driver.manage().timeouts().implicitlyWait(time)** — Установка времени ожидания для поиска элементов.

### Пример использования:

```java
WebDriver driver = new ChromeDriver();
driver.get("https://www.example.com");
driver.manage().window().maximize();
driver.quit();
```

## Headless-режим

**Headless-режим** — это режим работы браузера, когда он запускается без графического интерфейса. Это полезно для автоматизированных тестов, когда нет необходимости видеть интерфейс браузера. Это экономит ресурсы и ускоряет выполнение тестов.

### Инициализация браузера в Headless-режиме:

```java
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;

ChromeOptions options = new ChromeOptions();
options.addArguments("--headless"); // Включаем headless-режим
options.addArguments("--disable-gpu"); // Отключаем аппаратное ускорение

System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
WebDriver driver = new ChromeDriver(options);
driver.get("https://www.example.com");
```

Этот код запускает браузер Chrome в headless-режиме и открывает сайт.

---

С этим подходом ты можешь легко управлять браузерами, настраивать их и использовать в автоматизированных тестах.

# Selenium API

## Методы класса WebDriver

Класс **WebDriver** является основным интерфейсом в Selenium для управления браузером. Он предоставляет методы для взаимодействия с браузером, поиска элементов, управления окнами и выполнения других операций.

| Метод                      | Описание                                      | Пример                                      |
|----------------------------|----------------------------------------------|---------------------------------------------|
| **get(String url)**         | Переход к указанному URL.                    | `driver.get("https://www.example.com");`    |
| **findElement(By by)**      | Находит первый элемент, соответствующий локатору. | `WebElement element = driver.findElement(By.id("submit"));` |
| **findElements(By by)**     | Находит все элементы, соответствующие локатору. | `List<WebElement> elements = driver.findElements(By.className("button"));` |
| **manage()**                | Управление браузером (например, окнами и таймаутами). | `driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);` |
| **quit()**                  | Закрытие браузера.                           | `driver.quit();`                            |
| **getTitle()**              | Получить заголовок текущей страницы.         | `String title = driver.getTitle();`         |

### Пример использования метода WebDriver:

```java
WebDriver driver = new ChromeDriver();
driver.get("https://www.example.com");
System.out.println(driver.getTitle());
driver.quit();
```

## Методы класса WebElement

**WebElement** представляет собой элемент на веб-странице и предоставляет методы для взаимодействия с этим элементом.

| Метод                           | Описание                                      | Пример                                          |
|----------------------------------|----------------------------------------------|-------------------------------------------------|
| **click()**                      | Клик на элемент.                             | `element.click();`                              |
| **sendKeys(CharSequence keysToSend)** | Ввод текста в поле.                        | `element.sendKeys("Hello!");`                   |
| **getText()**                    | Получение текста из элемента.                | `String text = element.getText();`              |
| **getAttribute(String name)**    | Получение значения атрибута элемента.        | `String value = element.getAttribute("value");` |
| **isDisplayed()**                | Проверка, виден ли элемент на странице.      | `boolean isVisible = element.isDisplayed();`    |

### Пример использования методов WebElement:

```java
WebElement button = driver.findElement(By.id("submit"));
button.click();
WebElement input = driver.findElement(By.name("username"));
input.sendKeys("myusername");
```

## Методы класса By

Класс **By** используется для определения локаторов элементов на веб-странице. Это абстракция для различных типов локаторов, таких как id, name, className, XPath, и CSS-селекторы.

| Метод                                | Описание                                      | Пример                                          |
|--------------------------------------|----------------------------------------------|-------------------------------------------------|
| **By.id(String id)**                 | Локатор по ID.                               | `By idLocator = By.id("username");`             |
| **By.name(String name)**             | Локатор по имени.                            | `By nameLocator = By.name("password");`         |
| **By.className(String className)**   | Локатор по классу.                           | `By classLocator = By.className("login-btn");`  |
| **By.xpath(String xpathExpression)** | Локатор по XPath.                            | `By xpathLocator = By.xpath("//div/button");`   |
| **By.cssSelector(String selector)**  | Локатор по CSS-селектору.                    | `By cssLocator = By.cssSelector(".login .btn");`|

### Пример использования метода By:

```java
WebElement usernameField = driver.findElement(By.id("username"));
WebElement passwordField = driver.findElement(By.name("password"));
```

## Actions

Класс **Actions** используется для выполнения сложных действий, таких как перетаскивание, ввод текста с задержкой, наведение курсора и другие.

| Метод                               | Описание                                      | Пример                                          |
|-------------------------------------|----------------------------------------------|-------------------------------------------------|
| **moveToElement(WebElement target)** | Наведение курсора на элемент.                | `new Actions(driver).moveToElement(target).perform();` |
| **clickAndHold(WebElement target)** | Нажатие и удерживание элемента.              | `new Actions(driver).clickAndHold(target).perform();` |
| **dragAndDrop(WebElement source, WebElement target)** | Перетаскивание элемента. | `new Actions(driver).dragAndDrop(source, target).perform();` |

### Пример использования Actions:

```java
Actions actions = new Actions(driver);
actions.moveToElement(menu).click().perform();
```

## Alert

Класс **Alert** используется для работы с всплывающими окнами (alert), которые могут появляться на странице, например, с сообщениями или запросами на подтверждение.

| Метод                        | Описание                                         | Пример                                        |
|------------------------------|-------------------------------------------------|-----------------------------------------------|
| **accept()**                  | Подтверждение всплывающего окна.                 | `driver.switchTo().alert().accept();`         |
| **dismiss()**                 | Отклонение всплывающего окна.                   | `driver.switchTo().alert().dismiss();`        |
| **getText()**                 | Получение текста из всплывающего окна.          | `String alertText = driver.switchTo().alert().getText();` |
| **sendKeys(String text)**     | Отправка текста в всплывающее окно (например, в окно ввода). | `driver.switchTo().alert().sendKeys("Text");`  |

### Пример использования Alert:

```java
Alert alert = driver.switchTo().alert();
System.out.println(alert.getText());
alert.accept();
```

## IFrame

**IFrame** — это встроенный фрейм (вкладка) на странице. Для работы с элементами внутри фрейма необходимо переключиться в этот фрейм с помощью метода `switchTo().frame()`.

| Метод                         | Описание                                           | Пример                                          |
|-------------------------------|---------------------------------------------------|-------------------------------------------------|
| **switchTo().frame(int index)** | Переключение на фрейм по индексу.                  | `driver.switchTo().frame(0);`                   |
| **switchTo().frame(String nameOrId)** | Переключение на фрейм по имени или ID.         | `driver.switchTo().frame("frameId");`          |
| **switchTo().defaultContent()** | Переключение обратно в основной контент страницы. | `driver.switchTo().defaultContent();`           |

### Пример использования IFrame:

```java
driver.switchTo().frame("frameName");
WebElement input = driver.findElement(By.id("inputField"));
input.sendKeys("Hello");
driver.switchTo().defaultContent();
```

## JSExecutor

**JSExecutor** используется для выполнения JavaScript-кода внутри браузера. Это полезно для выполнения действий, которые невозможно выполнить с помощью стандартных методов WebDriver.

| Метод                             | Описание                                          | Пример                                      |
|-----------------------------------|--------------------------------------------------|---------------------------------------------|
| **executeScript(String script)**  | Выполнение JavaScript-кода.                      | `((JavascriptExecutor) driver).executeScript("alert('Hello');");` |
| **executeAsyncScript(String script)** | Выполнение асинхронного JavaScript-кода.       | `((JavascriptExecutor) driver).executeAsyncScript("return document.title;");` |

### Пример использования JSExecutor:

```java
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("window.scrollBy(0, 500)");
```

## WindowHandle

**WindowHandle** позволяет управлять окнами браузера. Если у вас несколько окон или вкладок, вы можете переключаться между ними.

| Метод                         | Описание                                           | Пример                                          |
|-------------------------------|---------------------------------------------------|-------------------------------------------------|
| **getWindowHandle()**          | Получение идентификатора текущего окна.           | `String mainWindow = driver.getWindowHandle();` |
| **getWindowHandles()**         | Получение всех идентификаторов окон.              | `Set<String> allWindows = driver.getWindowHandles();` |
| **switchTo().window(String windowHandle)** | Переключение на окно по идентификатору.        | `driver.switchTo().window(windowHandle);`      |

### Пример использования WindowHandle:

```java
String mainWindow = driver.getWindowHandle();
Set<String> allWindows = driver.getWindowHandles();
for (String window : allWindows) {
    if (!window.equals(mainWindow)) {
        driver.switchTo().window(window);
        // Выполнение действий в новом окне
        driver.close();
    }
}
driver.switchTo().window(mainWindow);
```

## Исключения в Selenium

Selenium может генерировать различные исключения. Вот несколько основных:

| Исключение                       | Описание                                          | Пример                                          |
|-----------------------------------|--------------------------------------------------|-------------------------------------------------|
| **NoSuchElementException**        | Элемент не найден.                               | `throw new NoSuchElementException("Element not found");` |
| **ElementNotInteractableException** | Элемент найден, но с ним нельзя взаимодействовать. | `throw new ElementNotInteractableException("Element not interactable");` |
| **TimeoutException**              | Время ожидания истекло.                          | `throw new TimeoutException("Timeout while waiting for element");` |
| **StaleElementReferenceException** | Элемент устарел (например, был обновлён на странице). | `throw new StaleElementReferenceException("Element is no longer attached to the DOM");` |

### Пример обработки исключения:

```java
try {
    WebElement element = driver.findElement(By.id("submit"));
    element.click();
} catch (NoSuchElementException e) {
    System.out.println("Элемент не найден!");
}
```

---

С этим подходом ты можешь эффективно использовать Selenium для автоматизации тестирования веб-приложений, обрабатывать различные сценарии и исключения.

# Ожидания в Selenium

## Виды ожиданий и зачем они нужны

**Ожидания** — это ключевая часть автоматизации тестирования с Selenium, так как веб-страницы часто загружаются асинхронно, и элементы могут быть не готовы к взаимодействию в момент, когда скрипт пытается с ними работать.

Основные виды ожиданий:

1. **Implicit Wait** (неявное ожидание) — применяется ко всем элементам на странице и указывает Selenium, сколько времени он должен ждать появления элемента, прежде чем выбросить исключение.
2. **Explicit Wait** (явное ожидание) — используется для ожидания выполнения конкретного условия (например, видимости элемента) перед выполнением действия.
3. **Fluent Wait** — более гибкая версия явного ожидания, позволяющая настраивать интервал между проверками и количество повторений.

## Разница между ними

| Тип ожидания     | Описание                                                       | Пример                                        |
|------------------|---------------------------------------------------------------|-----------------------------------------------|
| **Implicit Wait** | Ожидание определённого времени перед поиском элемента на странице. | `driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);` |
| **Explicit Wait** | Ожидание, пока не выполнится определённое условие для элемента.  | `WebDriverWait wait = new WebDriverWait(driver, 10); wait.until(ExpectedConditions.visibilityOf(element));` |
| **Fluent Wait**   | Явное ожидание с настройкой интервала между проверками и числа попыток. | `FluentWait<WebDriver> wait = new FluentWait<>(driver).withTimeout(30, TimeUnit.SECONDS).pollingEvery(5, TimeUnit.SECONDS);` |

## Использование методов с Expected Conditions

**Expected Conditions** предоставляет набор предустановленных условий для явных ожиданий, таких как видимость элемента, его кликабельность и другие.

Методы **ExpectedConditions**:

- **visibilityOf(WebElement element)** — ожидание, пока элемент не станет видимым.
- **elementToBeClickable(WebElement element)** — ожидание, пока элемент не станет кликабельным.
- **presenceOfElementLocated(By locator)** — ожидание, пока элемент не станет доступен в DOM.
- **alertIsPresent()** — ожидание появления alert.
- **titleContains(String title)** — ожидание, пока титул страницы не будет содержать заданную строку.

### Применение ExpectedConditions:

```java
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("submit")));
element.click();
```

Этот код будет ожидать, пока элемент с ID "submit" не станет видимым на странице, прежде чем выполнить клик.

## Виды Explicit Wait

**Explicit Wait** (явное ожидание) используется, когда необходимо ожидать выполнение конкретного условия, связанного с элементом, перед выполнением действия.

### Пример использования Explicit Wait:

```java
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("submit")));
element.click();
```

Этот код будет ждать, пока элемент с ID "submit" не станет кликабельным, прежде чем выполнить клик.

## Виды Implicit Wait

**Implicit Wait** (неявное ожидание) указывает Selenium, сколько времени следует ожидать при поиске элементов на странице. Это ожидание применяется ко всем поискам элементов, пока они не будут найдены.

### Пример использования Implicit Wait:

```java
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
```

Этот код будет ждать до 10 секунд, пока элемент не будет найден. Если элемент не найден в течение этого времени, Selenium выбросит исключение.

## Fluent Wait

**Fluent Wait** — это улучшенная версия явного ожидания, позволяющая задавать интервал между попытками проверки условия и количество попыток.

### Пример использования Fluent Wait:

```java
FluentWait<WebDriver> wait = new FluentWait<>(driver)
    .withTimeout(30, TimeUnit.SECONDS)
    .pollingEvery(5, TimeUnit.SECONDS)
    .ignoring(NoSuchElementException.class);

WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("submit")));
element.click();
```

Этот код будет проверять условие каждые 5 секунд в течение 30 секунд, пока элемент с ID "submit" не станет видимым. Также будет игнорировать исключение `NoSuchElementException` во время ожидания.

## Пример реализации Explicit Wait

В данном примере мы реализуем явное ожидание, чтобы дождаться, пока элемент не станет кликабельным, и затем выполнить клик.

```java
// Создание экземпляра WebDriver
WebDriver driver = new ChromeDriver();

// Переход на страницу
driver.get("https://www.example.com");

// Ожидание, пока кнопка не станет кликабельной
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement button = wait.until(ExpectedConditions.elementToBeClickable(By.id("submit")));

// Клик по кнопке
button.click();

// Закрытие браузера
driver.quit();
```

Этот код создаёт WebDriver, открывает сайт, ждёт, пока кнопка с ID "submit" не станет кликабельной, затем кликает на неё и закрывает браузер.

---

С этими типами ожиданий ты можешь эффективно управлять асинхронной загрузкой веб-страниц и взаимодействовать с элементами, как только они будут готовы, минимизируя риски ошибок в автоматизированных тестах.
