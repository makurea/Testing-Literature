# Инструменты автоматизации тестирования

## JUnit и TestNG

### Определение и назначение
- **JUnit**: Это фреймворк для модульного тестирования в Java, который позволяет разработчикам писать и запускать повторяемые тесты. Он является стандартом де-факто для unit-тестирования в Java.
- **TestNG**: Это более современный фреймворк для тестирования, который был создан для преодоления ограничений JUnit. Он поддерживает более сложные сценарии тестирования, такие как интеграционное тестирование, функциональное тестирование и end-to-end тестирование.

### Основные различия между JUnit и TestNG

| Характеристика          | JUnit                          | TestNG                         |
|-------------------------|--------------------------------|--------------------------------|
| **Параллельный запуск** | Ограниченная поддержка (только через расширения) | Полноценная поддержка (на уровне методов, классов, тестов) |
| **Параметризация**      | Через `@ParameterizedTest` и `@ValueSource`, `@CsvSource` | Через `@DataProvider`, который позволяет гибко передавать данные |
| **Зависимости тестов**  | Нет встроенной поддержки       | Есть (через `dependsOnMethods` или `dependsOnGroups`) |
| **Группировка тестов**  | Нет встроенной поддержки       | Есть (через `groups`, что позволяет запускать тесты по группам) |
| **Конфигурация тестов** | Через аннотации (`@BeforeEach`, `@AfterEach`) | Более гибкая конфигурация (например, `@BeforeSuite`, `@AfterTest`) |
| **Отчеты**              | Базовые отчеты                | Более детализированные и настраиваемые отчеты |
| **Интеграция с CI/CD**  | Хорошая, но требует дополнительных плагинов | Лучшая, благодаря встроенной поддержке параллелизма и гибкости |

### Запуск и пропуск тестов
- **JUnit**:
  - Запуск теста: Аннотация `@Test`.
  - Пропуск теста: Аннотация `@Disabled`.
- **TestNG**:
  - Запуск теста: Аннотация `@Test`.
  - Пропуск теста: Атрибут `enabled = false` в аннотации `@Test`.

### Параметризация тестов
- **JUnit**:
  - Использует `@ParameterizedTest` в сочетании с `@ValueSource`, `@CsvSource`, `@MethodSource` и другими.
  - Подходит для простых сценариев, где данные передаются напрямую.
- **TestNG**:
  - Использует `@DataProvider`, который позволяет возвращать массив объектов для параметризации.
  - Более гибкий подход, так как данные могут быть динамически сгенерированы или загружены из внешних источников.

### Параллельный запуск тестов
- **JUnit**:
  - Поддержка параллельного запуска ограничена и требует использования расширений (например, `junit-platform-engine`).
  - Параллелизм на уровне методов или классов.
- **TestNG**:
  - Полноценная поддержка параллельного запуска через конфигурацию в `testng.xml`.
  - Параллелизм на уровне методов, классов, тестов и даже наборов тестов (suites).

### Критерии выбора фреймворка
1. **Простота использования**: JUnit проще для начинающих и подходит для unit-тестирования.
2. **Гибкость**: TestNG предлагает больше возможностей для сложных сценариев, таких как интеграционное тестирование.
3. **Параллелизм**: Если требуется параллельный запуск тестов, TestNG предпочтительнее.
4. **Интеграция с инструментами**: JUnit лучше интегрирован с IDE (IntelliJ IDEA, Eclipse) и инструментами сборки (Maven, Gradle).
5. **Поддержка сообщества**: JUnit имеет более широкое сообщество и больше ресурсов для обучения.

### Хуки (Hooks)
Хуки — это методы, которые выполняются до или после тестов. Они используются для настройки и очистки данных.

#### JUnit:
- `@BeforeAll`: Выполняется один раз перед всеми тестами в классе.
- `@AfterAll`: Выполняется один раз после всех тестов в классе.
- `@BeforeEach`: Выполняется перед каждым тестом.
- `@AfterEach`: Выполняется после каждого теста.

#### TestNG:
- `@BeforeSuite`: Выполняется перед всеми тестами в наборе (suite).
- `@AfterSuite`: Выполняется после всех тестов в наборе.
- `@BeforeTest`: Выполняется перед всеми тестами в теговом блоке (тег `<test>` в `testng.xml`).
- `@AfterTest`: Выполняется после всех тестов в теговом блоке.
- `@BeforeClass`: Выполняется перед всеми тестами в классе.
- `@AfterClass`: Выполняется после всех тестов в классе.
- `@BeforeMethod`: Выполняется перед каждым тестовым методом.
- `@AfterMethod`: Выполняется после каждого тестового метода.

---

# Инструменты для управления проектом

## Package Manager

### Зачем они нужны
Package Manager (менеджер пакетов) — это инструмент, который упрощает управление зависимостями проекта, автоматизирует процессы сборки, тестирования и развертывания. Он позволяет:
- Управлять библиотеками и зависимостями.
- Автоматически разрешать конфликты версий.
- Упрощать сборку и развертывание проекта.

### Примеры популярных менеджеров пакетов
- **Maven** (Java)
- **Gradle** (Java, Kotlin, Groovy)
- **npm** (JavaScript)
- **pip** (Python)
- **NuGet** (.NET)

### Java: Maven

#### Основные понятия
- **GroupID**: Уникальный идентификатор группы, к которой принадлежит проект (например, `com.example`).
- **ArtifactID**: Уникальный идентификатор артефакта (проекта) (например, `my-app`).
- **Version**: Версия артефакта (например, `1.0.0`).
- **Dependency**: Зависимость, которая необходима для сборки и выполнения проекта. Указывается в формате `GroupID:ArtifactID:Version`.

#### Жизненные циклы Maven
Maven использует концепцию жизненных циклов, которые состоят из фаз:
1. **clean**: Удаляет скомпилированные файлы и артефакты.
2. **validate**: Проверяет корректность проекта.
3. **compile**: Компилирует исходный код.
4. **test**: Запускает unit-тесты.
5. **package**: Упаковывает скомпилированный код в JAR, WAR или другой формат.
6. **verify**: Проверяет качество кода.
7. **install**: Устанавливает артефакт в локальный репозиторий.
8. **deploy**: Размещает артефакт в удаленном репозитории.
9. **site**: Генерирует документацию проекта.

#### Преимущества Maven
- Стандартизация структуры проекта.
- Автоматическое управление зависимостями.
- Широкая поддержка плагинов.

### Java: Gradle

#### Основные понятия
- **Task**: Задача, которая может быть выполнена (например, компиляция, тестирование).
- **Build Script**: Скрипт на Groovy или Kotlin, который определяет, как проект должен быть собран.
- **Dependency Management**: Управление зависимостями через `build.gradle`.

#### Преимущества Gradle
- Гибкость и расширяемость.
- Поддержка инкрементальных сборок (ускоряет процесс).
- Интеграция с Maven и Ivy.
- Использование DSL (Domain-Specific Language) для настройки сборки.

### Сравнение Maven и Gradle

| Характеристика          | Maven                          | Gradle                         |
|-------------------------|--------------------------------|--------------------------------|
| **Конфигурация**        | XML-файл (`pom.xml`)           | Groovy/Kotlin DSL (`build.gradle`) |
| **Производительность**  | Медленнее (полная пересборка)  | Быстрее (инкрементальные сборки) |
| **Гибкость**            | Ограниченная                   | Высокая (можно писать кастомные задачи) |
| **Поддержка плагинов**  | Широкая                        | Широкая (включая поддержку Kotlin) |
| **Сложность обучения**  | Проще для новичков             | Требует знания Groovy/Kotlin   |

---
