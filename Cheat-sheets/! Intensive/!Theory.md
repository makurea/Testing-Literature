## Содержание <a id="content"></a>

1. [Что такое тестирование](#что-такое-тестирование)
2. [Виды тестирования](#виды-тестирования)
3. [Где мы видим требования и ожидаемый результат](#где-мы-видим-требования-и-ожидаемый-результат)
4. [Основные цели тестирования](#основные-цели-тестирования)
5. [Отчет о дефекте](#отчет-о-дефекте)
6. [Отчет о тестировании](#отчет-о-тестировании)
7. [QA и QC](#qa-и-qc)
8. [Валидация и верификация](#валидация-и-верификация)
9. [Верификация и валидация - различия](#верификация-и-валидация-различия)
10. [7 принципов тестирования](#7-принципов-тестирования)
11. [Скопление дефектов](#скопление-дефектов)
12. [Основные модели разработки](#основные-модели-разработки)
13. [Модель, которая оценивает риски](#модель-которая-оценивает-риски)
14. [Предприятия, где водопадная модель](#предприятия-где-водопадная-модель)
15. [Инкрементная модель](#инкрементная-модель)
16. [4 принципа Agile манифеста](#4-принципа-agile-манифеста)
17. [Сравнение Scrum и Kanban](#сравнение-scrum-и-kanban)
18. [Доска в Scrum](#доска-в-scrum)
19. [Роли в Scrum](#роли-в-scrum)
20. [Основные встречи и ритуалы в Scrum](#основные-встречи-и-ритуалы-в-scrum)
21. [Артефакты в Scrum](#артефакты-в-scrum)
22. [Velocity](#velocity)
23. [Capacity](#capacity)
24. [Релиз раз в спринт](#релиз-раз-в-спринт)
25. [Уровни тестирования](#уровни-тестирования)
26. [Кто разрабатывает модульные тесты](#кто-разрабатывает-модульные-тесты)
27. [4 большие группы тестирования](#4-большие-группы-тестирования)
28. [Функциональное, нефункциональное, связанное с изменениями и структурное тестирование](#функциональное-нефункциональное-связанное-с-изменениями-и-структурное-тестирование)
29. [Производительность](#производительность)
30. [Нефункциональные тесты](#нефункциональные-тесты)
31. [Тестирование совместимости](#тестирование-совместимости)
32. [Санити тестинг](#санити-тестинг)
33. [Разница Санити и Смоук тестинг](#разница-санити-и-смоук-тестинг)
34. [Виды тестовой документации](#виды-тестовой-документации)
35. [Плюсы/минусы чек-листов и тест-кейсов](#плюсы-минусы-чек-листов-и-тест-кейсов)
36. [Дефект/отказ отличия](#дефект-отказ-отличия)
37. [Основные атрибуты баг-репорта](#основные-атрибуты-баг-репорта)
38. [Серьезность опечатки](#серьезность-опечатки)
39. [Техники тест-дизайна](#техники-тест-дизайна)
40. [Методы оценки трудозатрат](#методы-оценки-трудозатрат)
41. [По 3 точкам как оценить](#по-3-точкам-как-оценить)
42. [Метрики тестирования](#метрики-тестирования)
43. [Что такое требование](#что-такое-требование)
44. [Свойства качественных требований](#свойства-качественных-требований)
45. [Клиент-серверная архитектура](#клиент-серверная-архитектура)
46. [Что такое API](#что-такое-api)
47. [Взаимодействие в трехуровневой клиент-серверной архитектуре](#взаимодействие-в-трехуровневой-клиент-серверной-архитектуре)
48. [Толстый и тонкий клиент](#толстый-и-тонкий-клиент)
49. [HTTP и HTTPS. В чем отличия](#http-и-https-в-чем-отличия)
50. [HTTPS и шифрование](#https-и-шифрование)
51. [Структура HTTP запроса](#структура-http-запроса)
52. [Уровни модели OSI](#уровни-модели-osi)
53. [Протоколы на прикладном уровне](#протоколы-на-прикладном-уровне)
54. [Протоколы на транспортном уровне](#протоколы-на-транспортном-уровне)
55. [MAC и IP адреса](#mac-и-ip-адреса)
56. [Коды ответов](#коды-ответов)
57. [Код на регистрацию нового клиента](#код-на-регистрацию-нового-клиента)
58. [Методы HTTP](#методы-http)
59. [GET и POST запросы](#get-и-post-запросы)
60. [Иденпотентность](#идентичность)
61. [Безопасные методы HTTP](#безопасные-методы-http)
62. [HEAD и OPTIONS методы](#head-и-options-методы)
63. [Что такое API](#что-такое-api)
64. [Виды API](#виды-api)
65. [RESTful системы](#restful-системы)
66. [Код по требованию](#код-по-требованию)
67. [Разница между SOAP и REST](#разница-между-soap-и-rest)
68. [Безопасность SOAP и REST](#безопасность-soap-и-rest)
69. [WS-Security в SOAP](#ws-security-в-soap)
70. [SOAP и REST](#soap-и-rest)
71. [Документация в SOAP и REST](#документация-в-soap-и-rest)
72. [Брокер сообщений](#брокер-сообщений)
73. [Известные брокеры сообщений](#известные-брокеры-сообщений)
74. [Монолит и микросервисная архитектура](#монолит-и-микросервисная-архитектура)
75. [Связь микросервисов](#связь-микросервисов)
76. [Синхронные и асинхронные процессы](#синхронные-и-асинхронные-процессы)
77. [Брокер сообщений и асинхронная передача](#брокер-сообщений-и-асинхронная-передача)
78. [Микросервисы и синхронная передача данных](#микросервисы-и-синхронная-передача-данных)
79. [Виды баз данных](#виды-баз-данных)
80. [Первичный ключ](#первичный-ключ)
81. [Внешний ключ](#внешний-ключ)
82. [Уникальность первичного и внешнего ключа](#уникальность-первичного-и-внешнего-ключа)
83. [Виды операторов в SQL](#виды-операторов-в-sql)
84. [Виды мобильных приложений](#виды-мобильных-приложений)
85. [Примеры гибридных приложений](#примеры-гибридных-приложений)


### 1. Что такое тестирование? <a id="что-такое-тестирование"></a>

Тестирование — это процесс оценки программного обеспечения или системы для выявления дефектов и обеспечения качества продукта. Это комплексный процесс, который включает в себя проверку функциональности, производительности, безопасности и других характеристик ПО. Целью тестирования является обеспечение того, чтобы конечный продукт соответствовал требованиям заказчика и удовлетворял ожидания пользователей.

[К содержанию](#content)

---

### 2. Виды тестирования <a id="виды-тестирования"></a>

Существует множество видов тестирования, которые можно разделить на несколько категорий:

- **Функциональное тестирование**: проверка того, что система выполняет все необходимые функции согласно спецификации.
  - Тестирование интерфейса
  - Тестирование API
  - Тестирование баз данных

- **Нефункциональное тестирование**: проверка нефункциональных аспектов, таких как производительность, безопасность и масштабируемость.
  - Тестирование производительности
  - Тестирование нагрузки
  - Тестирование безопасности

- **Тестирование, связанное с изменениями**:
  - Регрессионное тестирование: проверка того, что новые изменения не сломали существующую функциональность.
  - Перетестирование: повторная проверка исправленных дефектов.

- **Структурное тестирование**: проверка внутренней структуры программы, например, покрытие кода тестами.

[К содержанию](#content)

---

### 3. Где мы видим требования и ожидаемый результат? <a id="где-мы-видим-требования-и-ожидаемый-результат"></a>

Требования и ожидаемый результат обычно находятся в следующих документах:

- **SRS (Software Requirements Specification)**: спецификация требований к программному обеспечению, где описаны все функциональные и нефункциональные требования.
- **Документация по тест-кейсам**: здесь указаны шаги выполнения, входные данные, ожидаемый результат и фактический результат.
- **Use Cases**: описание сценариев использования системы.
- **User Stories**: истории пользователя, описывающие потребности конечных пользователей.

[К содержанию](#content)

---

### 4. Основные цели тестирования <a id="основные-цели-тестирования"></a>

Основные цели тестирования включают:

- **Актуальная информация по состоянию продукта**: предоставление информации о текущем состоянии разработки, включая количество обнаруженных и исправленных дефектов.
- **Предоставление информации заинтересованным сторонам**: команда разработки, менеджеры проекта и заказчики должны быть проинформированы о рисках и качестве продукта.
- **Обеспечение уверенности в качестве**: тестирование помогает убедиться, что продукт соответствует требованиям и готов к выпуску.

[К содержанию](#content)

---

### 5. Отчет о дефекте <a id="отчет-о-дефекте"></a>

Отчет о дефекте — это документ, который описывает найденный дефект. Он включает следующие элементы:

- **Идентификатор дефекта**: уникальный номер для отслеживания.
- **Описание**: краткое описание проблемы.
- **Шаги для воспроизведения**: детальное описание действий, необходимых для воспроизведения дефекта.
- **Ожидаемый результат**: что должно было произойти.
- **Фактический результат**: что действительно произошло.
- **Степень серьёзности**: уровень влияния дефекта на систему.
- **Приоритет**: важность исправления дефекта.

[К содержанию](#content)

---

### 6. Отчет о тестировании <a id="отчет-о-тестировании"></a>

Отчет о тестировании — это документ, который описывает результаты тестирования. Он включает:

- **Обзор выполнения тестов**: общая информация о тестировании, включая количество пройденных и не пройденных тестов.
- **Список обнаруженных дефектов**: детальное описание всех найденных проблем.
- **Рекомендации по дальнейшим действиям**: предложения по улучшению产品质量 или дополнительным тестам.

[К содержанию](#content)

---

### 7. QA и QC <a id="qa-и-qc"></a>

- **QA (Quality Assurance)**: процессо-ориентированный подход, направленный на обеспечение качества процессов разработки. Включает создание стандартов, процедур и методологий для предотвращения ошибок.
- **QC (Quality Control)**: продуктно-ориентированный подход, направленный на обеспечение качества готового продукта. Включает тестирование, инспекцию и верификацию.

[К содержанию](#content)

---

### 8. Валидация и верификация <a id="валидация-и-верификация"></a>

- **Верификация (Verification)**: процесс проверки того, что продукт соответствует требованиям на этапе разработки.
  Примеры:
  - Рецензирование документации.
  - Код-ревью.
  - Статический анализ кода.

- **Валидация (Validation)**: процесс проверки того, что готовый продукт соответствует ожиданиям пользователя.
  Примеры:
  - Тестирование в реальных условиях.
  - Пользовательское принятие.

[К содержанию](#content)

---

### 9. Верификация и валидация — различия <a id="верификация-и-валидация-различия"></a>

| **Характеристика**       | **Верификация**                                | **Валидация**                              |
|--------------------------|-----------------------------------------------|-------------------------------------------|
| **Цель**                | Проверка корректности процесса разработки.    | Проверка соответствия продукта требованиям. |
| **Этап**                | До завершения разработки.                     | После завершения разработки.              |
| **Методы**              | Статические методы (анализ документов, кода). | Динамические методы (тестирование).        |

[К содержанию](#content)

---

### 10. 7 принципов тестирования <a id="7-принципов-тестирования"></a>

1. **Тестирование демонстрирует наличие дефектов, но не гарантирует их отсутствие**: тесты могут найти ошибки, но не могут доказать их полное отсутствие.
2. **Исчерпывающее тестирование невозможно**: невозможно протестировать все возможные комбинации входных данных и условий.
3. **Раннее тестирование экономит время и деньги**: чем раньше найден дефект, тем дешевле его исправить.
4. **Скопление дефектов в одних местах**: некоторые части системы могут содержать больше ошибок из-за их сложности или изменений.
5. **Парадокс пестицида**: если тесты не меняются, они перестают находить новые дефекты.
6. **Тестирование зависит от контекста**: разные типы приложений требуют разных подходов к тестированию.
7. **Заблуждение об отсутствии ошибок**: успешное прохождение тестов не означает, что продукт свободен от ошибок.

[К содержанию](#content)

---

## 11. Скопление дефектов <a id="скопление-дефектов"></a>

**Описание**: Дефекты в программном обеспечении не распределяются равномерно по всему коду. Они часто концентрируются в определенных модулях или компонентах. Это явление известно как "скопление дефектов" или "принцип Парето в тестировании".

**Причины**:

* Сложность кода: Более сложные модули, как правило, содержат больше дефектов.
* Частые изменения: Модули, которые часто подвергаются изменениям, более подвержены ошибкам.
* Недостаточное тестирование: Модули, которые не были тщательно протестированы, могут содержать скрытые дефекты.

**Практическое применение**:

* Приоритизация тестирования: Сосредоточьте усилия по тестированию на модулях с высоким риском дефектов.
* Анализ кода: Используйте инструменты анализа кода для выявления потенциальных проблемных областей.
* Рефакторинг: Регулярно рефакторите сложные модули, чтобы упростить их и уменьшить вероятность ошибок.

[К содержанию](#content)

---

## 12. Основные модели разработки <a id="основные-модели-разработки"></a>


**Описание**: Модели разработки определяют структуру и последовательность этапов создания программного обеспечения.

**Основные модели**:

* **Водопадная модель (Waterfall)**: Линейная последовательность этапов, где каждый этап должен быть завершен до начала следующего.
* **Итеративная модель (Iterative)**: Разработка ведется итерациями, каждая из которых создает инкремент продукта.
* **Agile (гибкая) модель**: Ориентирована на гибкость, адаптивность и взаимодействие с заказчиком.

[К содержанию](#content)

---

## 13. Модель, которая оценивает риски <a id="модель-которая-оценивает-риски"></a>

**Описание**: Модель разработки на основе рисков (Risk-Based Development) фокусируется на выявлении и управлении рисками на протяжении всего жизненного цикла разработки.

**Применение**:

* Оценка рисков: Определение потенциальных рисков, их вероятности и воздействия.
* Планирование: Разработка стратегий управления рисками.
* Тестирование: Приоритизация тестирования на основе рисков.

[К содержанию](#content)

---

## 14. Предприятия, где водопадная модель <a id="предприятия-где-водопадная-модель"></a>

**Описание**: Водопадная модель подходит для проектов с четко определенными требованиями и низкой степенью неопределенности.

**Применение**:

* Государственные проекты: Проекты с жесткими требованиями и строгой документацией.
* Проекты с безопасностью: Проекты, где безопасность критически важна (например, авиация, медицина).
* Проекты с фиксированным бюджетом и сроками: Проекты, где изменения требований нежелательны.

[К содержанию](#content)

---

## 15. Инкрементная модель <a id="инкрементная-модель"></a>

**Описание**: Инкрементная модель предполагает разработку продукта по частям (инкрементам), каждая из которых добавляет функциональность к предыдущей.

**Применение**:

* Большие и сложные проекты: Разделение проекта на управляемые инкременты.
* Проекты с изменяющимися требованиями: Возможность адаптации к изменениям на каждой итерации.
* Проекты с необходимостью быстрого выпуска: Возможность выпуска работающего продукта на ранних этапах.

[К содержанию](#content)

---

## 16. 4 принципа Agile манифеста <a id="4-принципа-agile-манифеста"></a>

**Описание**: Agile манифест определяет ценности и принципы гибкой разработки программного обеспечения.

**Принципы**:

1.  **Люди и взаимодействие важнее процессов и инструментов**: Фокус на коммуникации и сотрудничестве.
2.  **Работающий продукт важнее исчерпывающей документации**: Приоритет отдается созданию функционального продукта.
3.  **Сотрудничество с заказчиком важнее согласования условий контракта**: Вовлечение заказчика в процесс разработки.
4.  **Готовность к изменениям важнее следования первоначальному плану**: Адаптация к изменениям требований.

[К содержанию](#content)

---

## 17. Сравнение Scrum и Kanban <a id="сравнение-scrum-и-kanban"></a>

**Описание**: Scrum и Kanban - это популярные Agile-методологии, но они имеют разные подходы к управлению проектами.

**Сравнение**:

| Характеристика | Scrum | Kanban |
| :------------- | :---- | :----- |
| Спринты       | Фиксированные по времени | Непрерывный поток |
| Роли          | Определены | Гибкие |
| Планирование  | Планирование спринта | Планирование по мере необходимости |
| Изменения     | В конце спринта | В любое время |

[К содержанию](#content)

---

## 18. Доска в Scrum <a id="доска-в-scrum"></a>

**Описание**: Доска в Scrum - это визуальный инструмент для отслеживания хода выполнения задач в спринте.

**Применение**:

* Отображение задач: Задачи разбиваются на карточки и перемещаются по доске.
* Отслеживание статуса: Доска показывает, какие задачи находятся в каком состоянии (например, "К выполнению", "В работе", "Готово").
* Прозрачность: Доска обеспечивает прозрачность хода выполнения спринта для всей команды.

[К содержанию](#content)

---

## 19. Роли в Scrum  <a id="роли-в-scrum"></a>

**Описание**: Scrum определяет три основные роли в команде разработки.

**Роли**:

* **Product Owner (владелец продукта)**: Определяет требования к продукту и приоритезирует задачи.
* **Scrum Master (координатор)**: Обеспечивает соблюдение принципов Scrum и устраняет препятствия.
* **Development Team (команда разработки)**: Создает продукт.

[К содержанию](#content)

---

## 20. Основные встречи и ритуалы в Scrum  <a id="основные-встречи-и-ритуалы-в-scrum"></a>

**Описание**: Scrum включает несколько регулярных встреч и ритуалов для обеспечения эффективной работы команды.

**Встречи и ритуалы**:

* **Sprint Planning (планирование спринта)**: Команда планирует работу на предстоящий спринт.
* **Daily Scrum (ежедневный скрам)**: Команда обсуждает прогресс и планирует работу на день.
* **Sprint Review (обзор спринта)**: Команда демонстрирует результаты спринта заказчику.
* **Sprint Retrospective (ретроспектива спринта)**: Команда обсуждает, что можно улучшить в следующем спринте.

[К содержанию](#content)

---

### 21. Артефакты в Scrum <a id="артефакты-в-scrum"></a>

В Scrum используются три основных артефакта:

| Артефакт          | Описание |
|-------------------|----------|
| **Product Backlog** (Бэклог продукта) | Список всех требований и задач, необходимых для реализации продукта. Приоритеты определяются владельцем продукта. |
| **Sprint Backlog** (Бэклог спринта) | Набор задач из Product Backlog, которые команда обязуется выполнить в течение текущего спринта. |
| **Increment** (Инкремент) | Готовая к выпуску версия продукта, содержащая все выполненные задачи текущего спринта. |

[К содержанию](#content)

---

### 22. Velocity <a id="velocity"></a>

**Velocity** (скорость команды) — это метрика, показывающая среднее количество сторипоинтов, выполненных за спринт.

- Используется для прогнозирования скорости работы команды.
- Рассчитывается на основе данных нескольких предыдущих спринтов.
- Помогает команде планировать будущие спринты.

**Формула расчета Velocity:**

```
Velocity = (Story Points завершенных задач) / (Количество спринтов)
```

[К содержанию](#content)

---

### 23. Capacity <a id="capacity"></a>

**Capacity** (ёмкость команды) — это доступное время команды на спринт. 

| Фактор | Влияние |
|--------|---------|
| Количество участников | Чем больше людей, тем выше Capacity. |
| Отпуска и болезни | Уменьшают Capacity. |
| Время, потраченное на встречи | Уменьшает доступное рабочее время. |

**Формула расчета Capacity:**

```
Capacity = (Кол-во членов команды) × (Доступные рабочие часы за спринт)
```

[К содержанию](#content)

---

### 24. Релиз раз в спринт <a id="релиз-раз-в-спринт"></a>

В Scrum релизы продукта осуществляются в конце каждого спринта. 

- Важно, чтобы инкремент был **готов к использованию** после каждого спринта.
- Включает в себя тестирование, код-ревью и деплой на продакшен.

[К содержанию](#content)

---

### 25. Уровни тестирования <a id="уровни-тестирования"></a>

| Уровень | Описание |
|---------|----------|
| **Модульное тестирование** | Тестирование отдельных компонентов системы. |
| **Интеграционное тестирование** | Проверка взаимодействия между модулями. |
| **Системное тестирование** | Проверка всей системы в целом. |
| **Приёмочное тестирование** | Подтверждение, что продукт соответствует требованиям заказчика. |

[К содержанию](#content)

---

### 26. Кто разрабатывает модульные тесты <a id="кто-разрабатывает-модульные-тесты"></a>

Модульные тесты разрабатывают **разработчики**.

Пример кода модульного теста на Java с использованием JUnit:

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}

public class MathUtilsTest {
    @Test
    void testAdd() {
        assertEquals(5, MathUtils.add(2, 3));
    }
}
```

[К содержанию](#content)

---

### 27. 4 большие группы тестирования <a id="4-большие-группы-тестирования"></a>

- **Функциональное тестирование**
- **Нефункциональное тестирование**
- **Тестирование, связанное с изменениями**
- **Структурное тестирование**

[К содержанию](#content)

---

### 28. Функциональное, нефункциональное, связанное с изменениями и структурное тестирование <a id="функциональное-нефункциональное-связанное-с-изменениями-и-структурное-тестирование"></a>

| Тип тестирования | Описание |
|------------------|----------|
| **Функциональное тестирование** | Проверка работы функционала согласно требованиям. |
| **Нефункциональное тестирование** | Проверка характеристик, не связанных с функционалом (производительность, безопасность). |
| **Тестирование, связанное с изменениями** | Проверка изменений в коде и их влияния на систему. |
| **Структурное тестирование** | Анализ внутренней структуры кода. |

[К содержанию](#content)

---

### 29. Производительность <a id="производительность"></a>

**Тестирование производительности** — проверка скорости и эффективности работы системы.

Методы:

- **Load Testing** (нагрузочное тестирование) — проверка системы при нормальной нагрузке.
- **Stress Testing** (стресс-тестирование) — проверка системы при экстремальных нагрузках.
- **Scalability Testing** (тестирование масштабируемости) — проверка способности системы увеличивать нагрузку.

Пример JMeter скрипта для тестирования нагрузки:

```xml
<testPlan>
    <threadGroup>
        <numThreads>100</numThreads>
        <rampUp>10</rampUp>
    </threadGroup>
    <httpSampler>
        <url>https://example.com</url>
        <method>GET</method>
    </httpSampler>
</testPlan>
```

[К содержанию](#content)

---

### 30. Нефункциональные тесты <a id="нефункциональные-тесты"></a>

Нефункциональные тесты оценивают **производительность, безопасность, удобство использования** и другие характеристики системы.

| Тип тестирования | Пример |
|------------------|--------|
| **Производительность** | Нагрузочное тестирование |
| **Безопасность** | Проверка защиты от атак |
| **Юзабилити** | Оценка удобства интерфейса |

[К содержанию](#content)

---

### 31. Тестирование совместимости

Проверка работы приложения на разных устройствах, платформах, браузерах.

[К содержанию](#content)

---

### 32. Санити тестинг

Тестирование, направленное на проверку новых функций или исправлений перед основным тестированием.

[К содержанию](#content)

---

### 33. Разница Санити и Смоук тестинг

- Санити тестинг — проверка определенной функциональности (вглубь).
- Смоук тестинг — проверка основных функций системы (вширь).

[К содержанию](#content)

---

### 34. Виды тестовой документации

- Тест-кейсы
- Чек-листы
- Тест-планы
- Отчеты о тестировании

[К содержанию](#content)

---

### 35. Плюсы/минусы чек-листов и тест-кейсов

- Чек-листы: быстрее, проще, но менее детализированные.
- Тест-кейсы: более подробные, но требуют больше времени на создание.

[К содержанию](#content)

---

### 36. Дефект/отказ отличия

- Дефект — ошибка в коде.
- Отказ — результат ошибки, проявляющийся в работе системы.
  
[К содержанию](#content)

---

### 37. Основные атрибуты баг-репорта

- Идентификатор
- Описание
- Шаги для воспроизведения
- Ожидаемый и фактический результат
- Степень серьёзности и приоритет
  
[К содержанию](#content)

---

### 38. Серьезность опечатки - тривиал

Опечатка имеет низкую серьезность и классифицируется как тривиал.
  
[К содержанию](#content)

---

### 39. Техники тест-дизайна

- Эквивалентное разделение
- Анализ граничных значений
- Таблицы принятия решений
- Сценарии использования
  
[К содержанию](#content)

---

### 40. Методы оценки трудозатрат

- Экспертное мнение
- Метод аналогий
- Делфи метод
  
[К содержанию](#content)

---

### 41. По 3 точкам как оценить

Оценка по методу PERT:
- Оценивается минимальное (Optimistic), наиболее вероятное (Most likely) и максимальное (Pessimistic) время.
- Формула: (O + 4M + P) / 6
  
[К содержанию](#content)

---

### 42. Метрики тестирования

- Покрытие кода
- Количество дефектов
- Среднее время на исправление дефекта
- Уровень отказов
  
[К содержанию](#content)

---

### 43. Что такое требование

Описание функциональности или атрибута, который должен быть реализован в продукте.
  
[К содержанию](#content)

---

### 44. Свойства качественных требований

- Полнота
- Непротиворечивость
- Проверяемость
- Однозначность
  
[К содержанию](#content)

---

### 45. Клиент-серверная архитектура

Модель взаимодействия, где клиент запрашивает данные у сервера, а сервер их предоставляет.
  
[К содержанию](#content)

---

### 46. Что такое API

API (Application Programming Interface) — это набор функций и процедур, позволяющих создавать приложения, которые могут получать доступ к данным и функционалу другого приложения, службы или операционной системы.
  
[К содержанию](#content)

---

### 47. Взаимодействие в 3-уровневой клиент-серверной архитектуре

Трехуровневая архитектура включает:
1. Пользовательский интерфейс (UI) — клиентская сторона, с которой взаимодействует пользователь.
2. Логический уровень — серверная часть, обрабатывающая запросы и выполняющая бизнес-логику.
3. Уровень данных — база данных, где хранятся данные.
  
[К содержанию](#content)

---

### 48. Толстый и тонкий клиент

- Толстый клиент: клиентская сторона, выполняющая большую часть вычислений и логики (например, десктопное приложение).
- Тонкий клиент: клиентская сторона с минимальными вычислениями, полагающаяся на сервер для обработки (например, веб-браузер).
  
[К содержанию](#content)

---

### 49. HTTP, HTTPS: в чем отличия, на каких портах работают

- HTTP (Hypertext Transfer Protocol) — протокол передачи гипертекста, работает на порте 80.
- HTTPS (HTTP Secure) — защищенная версия HTTP, использующая SSL/TLS для шифрования данных, работает на порте 443.
  
[К содержанию](#content)

---

### 50. Что использует HTTPS для шифрования?

HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных.
  
[К содержанию](#content)

---

### 51. Структура HTTP-запроса

HTTP-запрос включает:
- Метод (например, GET, POST)
- URL-адрес
- Версия HTTP
- Заголовки
- Тело запроса (для методов POST, PUT)
  
[К содержанию](#content)

---

### 52. Какие уровни модели OSI

Модель OSI (Open Systems Interconnection) включает 7 уровней:
1. Физический
2. Канальный
3. Сетевой
4. Транспортный
5. Сеансовый
6. Представительный
7. Прикладной
  
[К содержанию](#content)

---

### 53. Какие протоколы на прикладном уровне. DNS что делает

На прикладном уровне работают протоколы:
- HTTP/HTTPS
- FTP
- SMTP
- DNS (Domain Name System) — отвечает за преобразование доменных имен в IP-адреса.
  
[К содержанию](#content)

---

### 54. Протоколы на транспортном уровне. Разница между ними

На транспортном уровне работают протоколы:
- TCP (Transmission Control Protocol) — надежный протокол, гарантирующий доставку данных.
- UDP (User Datagram Protocol) — быстрый, но ненадежный протокол, не гарантирующий доставку данных.
  
[К содержанию](#content)

---

### 55. MAC и IP адреса

- MAC (Media Access Control) — уникальный адрес сетевого интерфейса устройства.
- IP (Internet Protocol) — адрес, идентифицирующий устройство в сети.
  
[К содержанию](#content)

---

### 56. Какие коды ответов есть. С какими сталкивалась

Коды ответов HTTP:
- 1xx — Информационные
- 2xx — Успешные
- 3xx — Перенаправления
- 4xx — Ошибки клиента (например, 404 Not Found)
- 5xx — Ошибки сервера (например,
  
[К содержанию](#content)

---

### 57. Код на регистрацию нового клиента

Для регистрации нового клиента в системе используется POST запрос к API, содержащий данные нового клиента (например, имя, email, пароль) в теле запроса.

[К содержанию](#content)

---

### 58. Методы HTTP

- GET: Получение данных с сервера.
- POST: Отправка данных на сервер для создания ресурса.
- PUT: Обновление существующего ресурса на сервере.
- PATCH: Частичное обновление ресурса на сервере.
- DELETE: Удаление ресурса с сервера.

[К содержанию](#content)

---

### 59. GET запрос и POST запрос

- GET: используется для получения данных. Не изменяет состояние сервера. Параметры передаются в URL.
- POST: используется для отправки данных на сервер для создания нового ресурса. Параметры передаются в теле запроса.

[К содержанию](#content)

---

### 60. Иденпотентность

Иденпотентные методы — это методы, которые не изменяют состояние сервера при повторных вызовах. Примеры иденпотентных методов: GET, PUT, DELETE.

[К содержанию](#content)

---

### 61. Безопасные методы HTTP

Безопасные методы — это методы, которые не изменяют состояние сервера. Пример безопасного метода: GET.

[К содержанию](#content)

---

### 62. HEAD и OPTIONS методы

- HEAD: Запрашивает заголовки ресурса, без тела.
- OPTIONS: Запрашивает поддерживаемые методы для ресурса.

[К содержанию](#content)

---

### 63. Что такое API

API (Application Programming Interface) — интерфейс для взаимодействия различных программных компонентов. Определяет методы и параметры для вызовов.

[К содержанию](#content)

---

### 64. Виды API

- REST API
- SOAP API
- GraphQL API

[К содержанию](#content)

---

### 65. RESTful системы

Системы, использующие архитектурный стиль REST, работают по принципам:
- Отсутствие состояния (stateless)
- Клиент-серверная архитектура
- Кеширование
- Единообразие интерфейса

[К содержанию](#content)

---

### 66. Код по требованию

Клиент может получать исполняемый код от сервера для выполнения, позволяя динамически изменять функциональность.

[К содержанию](#content)

---

### 67. Разница между SOAP и REST

- SOAP: протокол на основе XML, поддерживающий ACID транзакции, высокий уровень безопасности, сложен в использовании.
- REST: архитектурный стиль, использующий HTTP, легче в реализации и использовании, но менее строгие требования к безопасности.

[К содержанию](#content)

---

### 68. Безопасность SOAP и REST

SOAP более безопасный, так как поддерживает WS-Security для обеспечения целостности и конфиденциальности сообщений.

[К содержанию](#content)

---

### 69. WS-Security в SOAP

WS-Security — набор протоколов, обеспечивающих безопасность сообщений в SOAP, включая шифрование и аутентификацию.

[К содержанию](#content)

---

### 70. SOAP и REST

- SOAP работает с любыми протоколами, но не поддерживает кэширование.
- REST работает только с HTTP и HTTPS, поддерживает кэширование.

[К содержанию](#content)

---

### 71. Документация в SOAP и REST

- SOAP: WSDL (Web Services Description Language).
- REST: OpenAPI (ранее Swagger) или просто текстовая документация.

[К содержанию](#content)

---

### 72. Брокер сообщений

Посредник для передачи сообщений между различными системами. Обеспечивает асинхронную передачу данных.

[К содержанию](#content)

---

### 73. Известные брокеры сообщений

- Apache Kafka
- RabbitMQ
- Amazon SQS

[К содержанию](#content)

---

### 74. Монолит и микросервисная архитектура

- Монолит: Цельное приложение, где все компоненты тесно связаны.
- Микросервисная: Приложение состоит из независимых сервисов, каждый выполняет отдельные функции.

[К содержанию](#content)

---

## 75. Связь микросервисов <a id="связь-микросервисов"></a>

Микросервисы взаимодействуют друг с другом через API, используя различные протоколы связи:

- **HTTP (REST, gRPC)** — для синхронного взаимодействия
- **Сообщения (Message Broker)** — для асинхронного взаимодействия
- **WebSockets** — для двустороннего общения в реальном времени
- **Event-Driven Architecture** — через публикацию событий в шине сообщений (Kafka, RabbitMQ)

[К содержанию](#content)

---

## 76. Синхронные и асинхронные процессы <a id="синхронные-и-асинхронные-процессы"></a>

| Тип процесса  | Описание |
|--------------|----------|
| **Синхронный** | Клиент ожидает ответ от сервера, блокируя выполнение до получения результата. Примеры: HTTP-запросы, JDBC-запросы к БД. |
| **Асинхронный** | Клиент не ожидает немедленного ответа, выполнение продолжается, а результат обрабатывается позже. Примеры: WebSockets, очереди сообщений. |

[К содержанию](#content)

---

## 77. Брокер сообщений — асинхронная передача <a id="брокер-сообщений-и-асинхронная-передача"></a>

Брокер сообщений используется для асинхронной передачи данных между микросервисами. Он позволяет уменьшить нагрузку на систему, обеспечивая надежную доставку сообщений.

Примеры брокеров сообщений:
- **RabbitMQ**
- **Apache Kafka**
- **ActiveMQ**
- **Amazon SQS**

Преимущества использования:
- Масштабируемость
- Децентрализация
- Устойчивость к отказам

Пример кода для отправки и получения сообщений в RabbitMQ (Java):

```java
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
try (Connection connection = factory.newConnection(); 
     Channel channel = connection.createChannel()) {
    channel.queueDeclare("queue_name", false, false, false, null);
    String message = "Hello, World!";
    channel.basicPublish("", "queue_name", null, message.getBytes());
}
```

[К содержанию](#content)

---

## 78. Микросервисы и синхронная передача данных <a id="микросервисы-и-синхронная-передача-данных"></a>

При синхронной передаче данных клиент ожидает ответ от сервиса. Используются:

- **REST API** (HTTP)
- **gRPC** (более производительный вариант REST, использующий Protocol Buffers)

Пример REST-запроса в Spring Boot:

```java
@RestController
@RequestMapping("/api")
public class MyController {
    @GetMapping("/data")
    public ResponseEntity<String> getData() {
        return ResponseEntity.ok("Response data");
    }
}
```

[К содержанию](#content)

---

## 79. Виды баз данных <a id="виды-баз-данных"></a>

| Тип | Описание | Примеры |
|------|----------|---------|
| **Реляционные (SQL)** | Используют таблицы и связи между ними. | MySQL, PostgreSQL, Oracle |
| **NoSQL (нереляционные)** | Хранят данные в виде документов, ключ-значение, графов. | MongoDB, Redis, Cassandra |
| **Графовые базы данных** | Представляют данные в виде графов. | Neo4j, ArangoDB |

[К содержанию](#content)

---

## 80. Первичный ключ <a id="первичный-ключ"></a>

Первичный ключ (Primary Key) — это уникальный идентификатор записи в таблице базы данных.

Пример в SQL:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);
```

[К содержанию](#content)

---

## 81. Внешний ключ <a id="внешний-ключ"></a>

Внешний ключ (Foreign Key) указывает на первичный ключ другой таблицы.

Пример:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id)
);
```

[К содержанию](#content)

---

## 82. Уникальность первичного и внешнего ключа <a id="уникальность-первичного-и-внешнего-ключа"></a>

| Ключ | Уникальность |
|------|-------------|
| **Первичный ключ** | Всегда уникален в таблице. |
| **Внешний ключ** | Может быть неуникальным, так как несколько записей могут ссылаться на одну. |

[К содержанию](#content)

---

## 83. Виды операторов в SQL <a id="виды-операторов-в-sql"></a>

Основные операторы SQL:

- **SELECT** — получение данных
- **INSERT** — добавление данных
- **UPDATE** — обновление данных
- **DELETE** — удаление данных

Пример:

```sql
SELECT * FROM users;
INSERT INTO users (name) VALUES ('John Doe');
UPDATE users SET name = 'Jane Doe' WHERE id = 1;
DELETE FROM users WHERE id = 1;
```

[К содержанию](#content)

---

## 84. Виды мобильных приложений <a id="виды-мобильных-приложений"></a>

| Тип | Описание |
|------|----------|
| **Нативные** | Разрабатываются для конкретной платформы (iOS, Android). |
| **Веб-приложения** | Открываются через браузер, не требуют установки. |
| **Гибридные** | Комбинируют нативные и веб-технологии. |

[К содержанию](#content)

---

## 85. Примеры гибридных приложений <a id="примеры-гибридных-приложений"></a>

Популярные гибридные приложения:

- **Instagram**
- **Uber**
- **Twitter**

Они используют такие технологии, как **Flutter, React Native, Ionic, Cordova**.

[К содержанию](#content)

---
