## Содержание <a id="content"></a>

1. [Что такое тестирование](#что-такое-тестирование)
2. [Виды тестирования](#виды-тестирования)
3. [Где мы видим требования и ожидаемый результат](#где-мы-видим-требования-и-ожидаемый-результат)
4. [Основные цели тестирования](#основные-цели-тестирования)
5. [Отчет о дефекте](#отчет-о-дефекте)
6. [Отчет о тестировании](#отчет-о-тестировании)
7. [QA и QC](#qa-и-qc)
8. [Валидация и верификация](#валидация-и-верификация)
9. [Верификация и валидация - различия](#верификация-и-валидация-различия)
10. [7 принципов тестирования](#7-принципов-тестирования)
11. [Скопление дефектов](#скопление-дефектов)
12. [Основные модели разработки](#основные-модели-разработки)
13. [Модель, которая оценивает риски](#модель-которая-оценивает-риски)
14. [Предприятия, где водопадная модель](#предприятия-где-водопадная-модель)
15. [Инкрементная модель](#инкрементная-модель)
16. [4 принципа Agile манифеста](#4-принципа-agile-манифеста)
17. [Сравнение Scrum и Kanban](#сравнение-scrum-и-kanban)
18. [Доска в Scrum](#доска-в-scrum)
19. [Роли в Scrum](#роли-в-scrum)
20. [Основные встречи и ритуалы в Scrum](#основные-встречи-и-ритуалы-в-scrum)
21. [Артефакты в Scrum](#артефакты-в-scrum)
22. [Velocity](#velocity)
23. [Capacity](#capacity)
24. [Релиз раз в спринт](#релиз-раз-в-спринт)
25. [Уровни тестирования](#уровни-тестирования)
26. [Кто разрабатывает модульные тесты](#кто-разрабатывает-модульные-тесты)
27. [4 большие группы тестирования](#4-большие-группы-тестирования)
28. [Функциональное, нефункциональное, связанное с изменениями и структурное тестирование](#функциональное-нефункциональное-связанное-с-изменениями-и-структурное-тестирование)
29. [Производительность](#производительность)
30. [Нефункциональные тесты](#нефункциональные-тесты)
31. [Тестирование совместимости](#тестирование-совместимости)
32. [Санити тестинг](#санити-тестинг)
33. [Разница Санити и Смоук тестинг](#разница-санити-и-смоук-тестинг)
34. [Виды тестовой документации](#виды-тестовой-документации)
35. [Плюсы/минусы чек-листов и тест-кейсов](#плюсы-минусы-чек-листов-и-тест-кейсов)
36. [Дефект/отказ отличия](#дефект-отказ-отличия)
37. [Основные атрибуты баг-репорта](#основные-атрибуты-баг-репорта)
38. [Серьезность опечатки](#серьезность-опечатки)
39. [Техники тест-дизайна](#техники-тест-дизайна)
40. [Методы оценки трудозатрат](#методы-оценки-трудозатрат)
41. [По 3 точкам как оценить](#по-3-точкам-как-оценить)
42. [Метрики тестирования](#метрики-тестирования)
43. [Что такое требование](#что-такое-требование)
44. [Свойства качественных требований](#свойства-качественных-требований)
45. [Клиент-серверная архитектура](#клиент-серверная-архитектура)
46. [Что такое API](#что-такое-api)
47. [Взаимодействие в трехуровневой клиент-серверной архитектуре](#взаимодействие-в-трехуровневой-клиент-серверной-архитектуре)
48. [Толстый и тонкий клиент](#толстый-и-тонкий-клиент)
49. [HTTP и HTTPS. В чем отличия](#http-и-https-в-чем-отличия)
50. [HTTPS и шифрование](#https-и-шифрование)
51. [Структура HTTP запроса](#структура-http-запроса)
52. [Уровни модели OSI](#уровни-модели-osi)
53. [Протоколы на прикладном уровне](#протоколы-на-прикладном-уровне)
54. [Протоколы на транспортном уровне](#протоколы-на-транспортном-уровне)
55. [MAC и IP адреса](#mac-и-ip-адреса)
56. [Коды ответов](#коды-ответов)
57. [Код на регистрацию нового клиента](#код-на-регистрацию-нового-клиента)
58. [Методы HTTP](#методы-http)
59. [GET и POST запросы](#get-и-post-запросы)
60. [Иденпотентность](#идентичность)
61. [Безопасные методы HTTP](#безопасные-методы-http)
62. [HEAD и OPTIONS методы](#head-и-options-методы)
63. [Что такое API](#что-такое-api)
64. [Виды API](#виды-api)
65. [RESTful системы](#restful-системы)
66. [Код по требованию](#код-по-требованию)
67. [Разница между SOAP и REST](#разница-между-soap-и-rest)
68. [Безопасность SOAP и REST](#безопасность-soap-и-rest)
69. [WS-Security в SOAP](#ws-security-в-soap)
70. [SOAP и REST](#soap-и-rest)
71. [Документация в SOAP и REST](#документация-в-soap-и-rest)
72. [Брокер сообщений](#брокер-сообщений)
73. [Известные брокеры сообщений](#известные-брокеры-сообщений)
74. [Монолит и микросервисная архитектура](#монолит-и-микросервисная-архитектура)
75. [Связь микросервисов](#связь-микросервисов)
76. [Синхронные и асинхронные процессы](#синхронные-и-асинхронные-процессы)
77. [Брокер сообщений и асинхронная передача](#брокер-сообщений-и-асинхронная-передача)
78. [Микросервисы и синхронная передача данных](#микросервисы-и-синхронная-передача-данных)
79. [Виды баз данных](#виды-баз-данных)
80. [Первичный ключ](#первичный-ключ)
81. [Внешний ключ](#внешний-ключ)
82. [Уникальность первичного и внешнего ключа](#уникальность-первичного-и-внешнего-ключа)
83. [Виды операторов в SQL](#виды-операторов-в-sql)
84. [Виды мобильных приложений](#виды-мобильных-приложений)
85. [Примеры гибридных приложений](#примеры-гибридных-приложений)


### 1. Что такое тестирование? <a id="что-такое-тестирование"></a>

Тестирование — это процесс оценки программного обеспечения или системы для выявления дефектов и обеспечения качества продукта. Это комплексный процесс, который включает в себя проверку функциональности, производительности, безопасности и других характеристик ПО. Целью тестирования является обеспечение того, чтобы конечный продукт соответствовал требованиям заказчика и удовлетворял ожидания пользователей.

[К содержанию](#content)

---

### 2. Виды тестирования <a id="виды-тестирования"></a>

Существует множество видов тестирования, которые можно разделить на несколько категорий:

- **Функциональное тестирование**: проверка того, что система выполняет все необходимые функции согласно спецификации.
  - Тестирование интерфейса
  - Тестирование API
  - Тестирование баз данных

- **Нефункциональное тестирование**: проверка нефункциональных аспектов, таких как производительность, безопасность и масштабируемость.
  - Тестирование производительности
  - Тестирование нагрузки
  - Тестирование безопасности

- **Тестирование, связанное с изменениями**:
  - Регрессионное тестирование: проверка того, что новые изменения не сломали существующую функциональность.
  - Перетестирование: повторная проверка исправленных дефектов.

- **Структурное тестирование**: проверка внутренней структуры программы, например, покрытие кода тестами.

[К содержанию](#content)

---

### 3. Где мы видим требования и ожидаемый результат? <a id="где-мы-видим-требования-и-ожидаемый-результат"></a>

Требования и ожидаемый результат обычно находятся в следующих документах:

- **SRS (Software Requirements Specification)**: спецификация требований к программному обеспечению, где описаны все функциональные и нефункциональные требования.
- **Документация по тест-кейсам**: здесь указаны шаги выполнения, входные данные, ожидаемый результат и фактический результат.
- **Use Cases**: описание сценариев использования системы.
- **User Stories**: истории пользователя, описывающие потребности конечных пользователей.

[К содержанию](#content)

---

### 4. Основные цели тестирования <a id="основные-цели-тестирования"></a>

Основные цели тестирования включают:

- **Актуальная информация по состоянию продукта**: предоставление информации о текущем состоянии разработки, включая количество обнаруженных и исправленных дефектов.
- **Предоставление информации заинтересованным сторонам**: команда разработки, менеджеры проекта и заказчики должны быть проинформированы о рисках и качестве продукта.
- **Обеспечение уверенности в качестве**: тестирование помогает убедиться, что продукт соответствует требованиям и готов к выпуску.

[К содержанию](#content)

---

### 5. Отчет о дефекте <a id="отчет-о-дефекте"></a>

Отчет о дефекте — это документ, который описывает найденный дефект. Он включает следующие элементы:

- **Идентификатор дефекта**: уникальный номер для отслеживания.
- **Описание**: краткое описание проблемы.
- **Шаги для воспроизведения**: детальное описание действий, необходимых для воспроизведения дефекта.
- **Ожидаемый результат**: что должно было произойти.
- **Фактический результат**: что действительно произошло.
- **Степень серьёзности**: уровень влияния дефекта на систему.
- **Приоритет**: важность исправления дефекта.

[К содержанию](#content)

---

### 6. Отчет о тестировании <a id="отчет-о-тестировании"></a>

Отчет о тестировании — это документ, который описывает результаты тестирования. Он включает:

- **Обзор выполнения тестов**: общая информация о тестировании, включая количество пройденных и не пройденных тестов.
- **Список обнаруженных дефектов**: детальное описание всех найденных проблем.
- **Рекомендации по дальнейшим действиям**: предложения по улучшению产品质量 или дополнительным тестам.

[К содержанию](#content)

---

### 7. QA и QC <a id="qa-и-qc"></a>

- **QA (Quality Assurance)**: процессо-ориентированный подход, направленный на обеспечение качества процессов разработки. Включает создание стандартов, процедур и методологий для предотвращения ошибок.
- **QC (Quality Control)**: продуктно-ориентированный подход, направленный на обеспечение качества готового продукта. Включает тестирование, инспекцию и верификацию.

[К содержанию](#content)

---

### 8. Валидация и верификация <a id="валидация-и-верификация"></a>

- **Верификация (Verification)**: процесс проверки того, что продукт соответствует требованиям на этапе разработки.
  Примеры:
  - Рецензирование документации.
  - Код-ревью.
  - Статический анализ кода.

- **Валидация (Validation)**: процесс проверки того, что готовый продукт соответствует ожиданиям пользователя.
  Примеры:
  - Тестирование в реальных условиях.
  - Пользовательское принятие.

[К содержанию](#content)

---

### 9. Верификация и валидация — различия <a id="верификация-и-валидация-различия"></a>

| **Характеристика**       | **Верификация**                                | **Валидация**                              |
|--------------------------|-----------------------------------------------|-------------------------------------------|
| **Цель**                | Проверка корректности процесса разработки.    | Проверка соответствия продукта требованиям. |
| **Этап**                | До завершения разработки.                     | После завершения разработки.              |
| **Методы**              | Статические методы (анализ документов, кода). | Динамические методы (тестирование).        |

[К содержанию](#content)

---

### 10. 7 принципов тестирования <a id="7-принципов-тестирования"></a>

1. **Тестирование демонстрирует наличие дефектов, но не гарантирует их отсутствие**: тесты могут найти ошибки, но не могут доказать их полное отсутствие.
2. **Исчерпывающее тестирование невозможно**: невозможно протестировать все возможные комбинации входных данных и условий.
3. **Раннее тестирование экономит время и деньги**: чем раньше найден дефект, тем дешевле его исправить.
4. **Скопление дефектов в одних местах**: некоторые части системы могут содержать больше ошибок из-за их сложности или изменений.
5. **Парадокс пестицида**: если тесты не меняются, они перестают находить новые дефекты.
6. **Тестирование зависит от контекста**: разные типы приложений требуют разных подходов к тестированию.
7. **Заблуждение об отсутствии ошибок**: успешное прохождение тестов не означает, что продукт свободен от ошибок.

[К содержанию](#content)

---

## 11. Скопление дефектов <a id="скопление-дефектов"></a>

**Описание**: Дефекты в программном обеспечении не распределяются равномерно по всему коду. Они часто концентрируются в определенных модулях или компонентах. Это явление известно как "скопление дефектов" или "принцип Парето в тестировании".

**Причины**:

* Сложность кода: Более сложные модули, как правило, содержат больше дефектов.
* Частые изменения: Модули, которые часто подвергаются изменениям, более подвержены ошибкам.
* Недостаточное тестирование: Модули, которые не были тщательно протестированы, могут содержать скрытые дефекты.

**Практическое применение**:

* Приоритизация тестирования: Сосредоточьте усилия по тестированию на модулях с высоким риском дефектов.
* Анализ кода: Используйте инструменты анализа кода для выявления потенциальных проблемных областей.
* Рефакторинг: Регулярно рефакторите сложные модули, чтобы упростить их и уменьшить вероятность ошибок.

[К содержанию](#content)

---

## 12. Основные модели разработки <a id="основные-модели-разработки"></a>


**Описание**: Модели разработки определяют структуру и последовательность этапов создания программного обеспечения.

**Основные модели**:

* **Водопадная модель (Waterfall)**: Линейная последовательность этапов, где каждый этап должен быть завершен до начала следующего.
* **Итеративная модель (Iterative)**: Разработка ведется итерациями, каждая из которых создает инкремент продукта.
* **Agile (гибкая) модель**: Ориентирована на гибкость, адаптивность и взаимодействие с заказчиком.

[К содержанию](#content)

---

## 13. Модель, которая оценивает риски <a id="модель-которая-оценивает-риски"></a>

**Описание**: Модель разработки на основе рисков (Risk-Based Development) фокусируется на выявлении и управлении рисками на протяжении всего жизненного цикла разработки.

**Применение**:

* Оценка рисков: Определение потенциальных рисков, их вероятности и воздействия.
* Планирование: Разработка стратегий управления рисками.
* Тестирование: Приоритизация тестирования на основе рисков.

[К содержанию](#content)

---

## 14. Предприятия, где водопадная модель <a id="предприятия-где-водопадная-модель"></a>

**Описание**: Водопадная модель подходит для проектов с четко определенными требованиями и низкой степенью неопределенности.

**Применение**:

* Государственные проекты: Проекты с жесткими требованиями и строгой документацией.
* Проекты с безопасностью: Проекты, где безопасность критически важна (например, авиация, медицина).
* Проекты с фиксированным бюджетом и сроками: Проекты, где изменения требований нежелательны.

[К содержанию](#content)

---

## 15. Инкрементная модель <a id="инкрементная-модель"></a>

**Описание**: Инкрементная модель предполагает разработку продукта по частям (инкрементам), каждая из которых добавляет функциональность к предыдущей.

**Применение**:

* Большие и сложные проекты: Разделение проекта на управляемые инкременты.
* Проекты с изменяющимися требованиями: Возможность адаптации к изменениям на каждой итерации.
* Проекты с необходимостью быстрого выпуска: Возможность выпуска работающего продукта на ранних этапах.

[К содержанию](#content)

---

## 16. 4 принципа Agile манифеста <a id="4-принципа-agile-манифеста"></a>

**Описание**: Agile манифест определяет ценности и принципы гибкой разработки программного обеспечения.

**Принципы**:

1.  **Люди и взаимодействие важнее процессов и инструментов**: Фокус на коммуникации и сотрудничестве.
2.  **Работающий продукт важнее исчерпывающей документации**: Приоритет отдается созданию функционального продукта.
3.  **Сотрудничество с заказчиком важнее согласования условий контракта**: Вовлечение заказчика в процесс разработки.
4.  **Готовность к изменениям важнее следования первоначальному плану**: Адаптация к изменениям требований.

[К содержанию](#content)

---

## 17. Сравнение Scrum и Kanban <a id="сравнение-scrum-и-kanban"></a>

**Описание**: Scrum и Kanban - это популярные Agile-методологии, но они имеют разные подходы к управлению проектами.

**Сравнение**:

| Характеристика | Scrum | Kanban |
| :------------- | :---- | :----- |
| Спринты       | Фиксированные по времени | Непрерывный поток |
| Роли          | Определены | Гибкие |
| Планирование  | Планирование спринта | Планирование по мере необходимости |
| Изменения     | В конце спринта | В любое время |

[К содержанию](#content)

---

## 18. Доска в Scrum <a id="доска-в-scrum"></a>

**Описание**: Доска в Scrum - это визуальный инструмент для отслеживания хода выполнения задач в спринте.

**Применение**:

* Отображение задач: Задачи разбиваются на карточки и перемещаются по доске.
* Отслеживание статуса: Доска показывает, какие задачи находятся в каком состоянии (например, "К выполнению", "В работе", "Готово").
* Прозрачность: Доска обеспечивает прозрачность хода выполнения спринта для всей команды.

[К содержанию](#content)

---

## 19. Роли в Scrum  <a id="роли-в-scrum"></a>

**Описание**: Scrum определяет три основные роли в команде разработки.

**Роли**:

* **Product Owner (владелец продукта)**: Определяет требования к продукту и приоритезирует задачи.
* **Scrum Master (координатор)**: Обеспечивает соблюдение принципов Scrum и устраняет препятствия.
* **Development Team (команда разработки)**: Создает продукт.

[К содержанию](#content)

---

## 20. Основные встречи и ритуалы в Scrum  <a id="основные-встречи-и-ритуалы-в-scrum"></a>

**Описание**: Scrum включает несколько регулярных встреч и ритуалов для обеспечения эффективной работы команды.

**Встречи и ритуалы**:

* **Sprint Planning (планирование спринта)**: Команда планирует работу на предстоящий спринт.
* **Daily Scrum (ежедневный скрам)**: Команда обсуждает прогресс и планирует работу на день.
* **Sprint Review (обзор спринта)**: Команда демонстрирует результаты спринта заказчику.
* **Sprint Retrospective (ретроспектива спринта)**: Команда обсуждает, что можно улучшить в следующем спринте.

[К содержанию](#content)

---

### 21. Артефакты в Scrum <a id="артефакты-в-scrum"></a>

В Scrum используются три основных артефакта:

| Артефакт          | Описание |
|-------------------|----------|
| **Product Backlog** (Бэклог продукта) | Список всех требований и задач, необходимых для реализации продукта. Приоритеты определяются владельцем продукта. |
| **Sprint Backlog** (Бэклог спринта) | Набор задач из Product Backlog, которые команда обязуется выполнить в течение текущего спринта. |
| **Increment** (Инкремент) | Готовая к выпуску версия продукта, содержащая все выполненные задачи текущего спринта. |

[К содержанию](#content)

---

### 22. Velocity <a id="velocity"></a>

**Velocity** (скорость команды) — это метрика, показывающая среднее количество сторипоинтов, выполненных за спринт.

- Используется для прогнозирования скорости работы команды.
- Рассчитывается на основе данных нескольких предыдущих спринтов.
- Помогает команде планировать будущие спринты.

**Формула расчета Velocity:**

```
Velocity = (Story Points завершенных задач) / (Количество спринтов)
```

[К содержанию](#content)

---

### 23. Capacity <a id="capacity"></a>

**Capacity** (ёмкость команды) — это доступное время команды на спринт. 

| Фактор | Влияние |
|--------|---------|
| Количество участников | Чем больше людей, тем выше Capacity. |
| Отпуска и болезни | Уменьшают Capacity. |
| Время, потраченное на встречи | Уменьшает доступное рабочее время. |

**Формула расчета Capacity:**

```
Capacity = (Кол-во членов команды) × (Доступные рабочие часы за спринт)
```

[К содержанию](#content)

---

### 24. Релиз раз в спринт <a id="релиз-раз-в-спринт"></a>

В Scrum релизы продукта осуществляются в конце каждого спринта. 

- Важно, чтобы инкремент был **готов к использованию** после каждого спринта.
- Включает в себя тестирование, код-ревью и деплой на продакшен.

[К содержанию](#content)

---

### 25. Уровни тестирования <a id="уровни-тестирования"></a>

| Уровень | Описание |
|---------|----------|
| **Модульное тестирование** | Тестирование отдельных компонентов системы. |
| **Интеграционное тестирование** | Проверка взаимодействия между модулями. |
| **Системное тестирование** | Проверка всей системы в целом. |
| **Приёмочное тестирование** | Подтверждение, что продукт соответствует требованиям заказчика. |

[К содержанию](#content)

---

### 26. Кто разрабатывает модульные тесты <a id="кто-разрабатывает-модульные-тесты"></a>

Модульные тесты разрабатывают **разработчики**.

Пример кода модульного теста на Java с использованием JUnit:

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}

public class MathUtilsTest {
    @Test
    void testAdd() {
        assertEquals(5, MathUtils.add(2, 3));
    }
}
```

[К содержанию](#content)

---

### 27. 4 большие группы тестирования <a id="4-большие-группы-тестирования"></a>

- **Функциональное тестирование**
- **Нефункциональное тестирование**
- **Тестирование, связанное с изменениями**
- **Структурное тестирование**

[К содержанию](#content)

---

### 28. Функциональное, нефункциональное, связанное с изменениями и структурное тестирование <a id="функциональное-нефункциональное-связанное-с-изменениями-и-структурное-тестирование"></a>

| Тип тестирования | Описание |
|------------------|----------|
| **Функциональное тестирование** | Проверка работы функционала согласно требованиям. |
| **Нефункциональное тестирование** | Проверка характеристик, не связанных с функционалом (производительность, безопасность). |
| **Тестирование, связанное с изменениями** | Проверка изменений в коде и их влияния на систему. |
| **Структурное тестирование** | Анализ внутренней структуры кода. |

[К содержанию](#content)

---

### 29. Производительность <a id="производительность"></a>

**Тестирование производительности** — проверка скорости и эффективности работы системы.

Методы:

- **Load Testing** (нагрузочное тестирование) — проверка системы при нормальной нагрузке.
- **Stress Testing** (стресс-тестирование) — проверка системы при экстремальных нагрузках.
- **Scalability Testing** (тестирование масштабируемости) — проверка способности системы увеличивать нагрузку.

Пример JMeter скрипта для тестирования нагрузки:

```xml
<testPlan>
    <threadGroup>
        <numThreads>100</numThreads>
        <rampUp>10</rampUp>
    </threadGroup>
    <httpSampler>
        <url>https://example.com</url>
        <method>GET</method>
    </httpSampler>
</testPlan>
```

[К содержанию](#content)

---

### 30. Нефункциональные тесты <a id="нефункциональные-тесты"></a>

Нефункциональные тесты оценивают **производительность, безопасность, удобство использования** и другие характеристики системы.

| Тип тестирования | Пример |
|------------------|--------|
| **Производительность** | Нагрузочное тестирование |
| **Безопасность** | Проверка защиты от атак |
| **Юзабилити** | Оценка удобства интерфейса |

[К содержанию](#content)

---

### 31. Тестирование совместимости <a id="тестирование-совместимости"></a>

Проверка работы приложения на разных устройствах, платформах, браузерах. Включает в себя тестирование на различных операционных системах (Windows, macOS, Linux), мобильных платформах (Android, iOS), различных браузерах (Chrome, Firefox, Safari) и различных устройствах (смартфоны, планшеты, ПК).

[К содержанию](#content)

---

### 32. Санити тестинг <a id="санити-тестинг"></a>

Тестирование, направленное на проверку новых функций или исправлений перед основным тестированием. Оно включает в себя поверхностную проверку основных функций, чтобы удостовериться, что недавние изменения не вызвали новых дефектов в системе. 

[К содержанию](#content)

---

### 33. Разница Санити и Смоук тестинг <a id="разница-санити-и-смоук-тестинг"></a>

- **Санити тестинг** — проверка определенной функциональности (вглубь). 
  - Цель: убедиться, что недавно добавленные или измененные функции работают корректно.
  - Ориентирован на конкретную область приложения.
- **Смоук тестинг** — проверка основных функций системы (вширь).
  - Цель: убедиться, что основная функциональность системы работает после нового билда.
  - Быстрая проверка всех основных компонентов системы.

[К содержанию](#content)

---

### 34. Виды тестовой документации <a id="виды-тестовой-документации"></a>

- **Тест-кейсы**: детализированные сценарии с шагами, ожиданиями и результатами.
- **Чек-листы**: список проверок без детализированных шагов.
- **Тест-планы**: стратегический документ, описывающий цели и объем тестирования, ресурсы и расписание.
- **Отчеты о тестировании**: резюме результатов тестирования, обнаруженные дефекты, завершенные тест-кейсы.

[К содержанию](#content)

---

### 35. Плюсы/минусы чек-листов и тест-кейсов <a id="плюсы-минусы-чек-листов-и-тест-кейсов"></a>

|               | **Чек-листы**                      | **Тест-кейсы**                                |
|---------------|------------------------------------|-----------------------------------------------|
| **Плюсы**     | Быстрее составлять, проще в использовании. | Подробные, четкие инструкции для тестировщиков. |
| **Минусы**    | Менее детализированные, могут пропустить нюансы. | Требуют больше времени на создание, сложнее в поддержке. |

[К содержанию](#content)

---

### 36. Дефект/отказ отличия <a id="дефект-отказ-отличия"></a>

- **Дефект** — ошибка в коде, которая вызывает неправильное поведение системы. Например, некорректная логика в функции вычисления.
- **Отказ** — проявление дефекта в работе системы. Например, приложение падает из-за дефекта в коде.

[К содержанию](#content)

---

### 37. Основные атрибуты баг-репорта <a id="основные-атрибуты-баг-репорта"></a>

- **Идентификатор**: уникальный номер для отслеживания дефекта.
- **Описание**: краткое описание проблемы.
- **Шаги для воспроизведения**: последовательность действий, необходимых для воспроизведения дефекта.
- **Ожидаемый и фактический результат**: что должно происходить и что происходит на самом деле.
- **Степень серьёзности и приоритет**: насколько серьезен дефект и как быстро его нужно исправить.

[К содержанию](#content)

---

### 38. Серьезность опечатки <a id="серьезность-опечатки"></a>

Опечатка имеет низкую серьезность и классифицируется как тривиал. Опечатки редко влияют на функциональность системы, но могут портить впечатление от использования.

[К содержанию](#content)

---

### 39. Техники тест-дизайна <a id="техники-тест-дизайна"></a>

- **Эквивалентное разделение**: разделение входных данных на группы, которые обрабатываются одинаково.
- **Анализ граничных значений**: проверка поведения системы на границах допустимых значений.
- **Таблицы принятия решений**: использование таблиц для определения правил и условий, влияющих на результаты тестирования.
- **Сценарии использования**: моделирование реальных сценариев использования приложения.

[К содержанию](#content)

---

### 40. Методы оценки трудозатрат <a id="методы-оценки-трудозатрат"></a>

- **Экспертное мнение**: получение оценки от экспертов, основываясь на их опыте.
- **Метод аналогий**: оценка на основе аналогичных проектов или задач.
- **Делфи метод**: групповая оценка, где эксперты независимо дают свои оценки, а затем обсуждают и пересматривают их до достижения консенсуса.

[К содержанию](#content)

### 41. По 3 точкам как оценить <a id="по-3-точкам-как-оценить"></a>

Оценка по методу PERT:
- Оценивается минимальное (Optimistic), наиболее вероятное (Most likely) и максимальное (Pessimistic) время.
- Формула: (O + 4M + P) / 6

[К содержанию](#content)

---

### 42. Метрики тестирования <a id="метрики-тестирования"></a>

- **Покрытие кода**: процент кода, который был протестирован.
- **Количество дефектов**: общее количество обнаруженных дефектов.
- **Среднее время на исправление дефекта**: время, необходимое для исправления дефекта после его обнаружения.
- **Уровень отказов**: частота отказов системы за определенный период.

[К содержанию](#content)

---

### 43. Что такое требование <a id="что-такое-требование"></a>

Описание функциональности или атрибута, который должен быть реализован в продукте. Требования могут быть функциональными (описывающими, что система должна делать) и нефункциональными (описывающими, как система должна это делать).

[К содержанию](#content)

---

### 44. Свойства качественных требований <a id="свойства-качественных-требований"></a>

- **Полнота**: требование должно быть полным и содержать всю необходимую информацию.
- **Непротиворечивость**: требования не должны противоречить друг другу.
- **Проверяемость**: каждое требование должно быть проверяемым и тестируемым.
- **Однозначность**: требования должны быть четко и ясно сформулированы.

[К содержанию](#content)

---

### 45. Клиент-серверная архитектура <a id="клиент-серверная-архитектура"></a>

Модель взаимодействия, где клиент запрашивает данные у сервера, а сервер их предоставляет. Клиент инициирует запрос, сервер обрабатывает запрос и отправляет ответ. Примеры: веб-приложения, мобильные приложения.

[К содержанию](#content)

---

### 46. Что такое API <a id="что-такое-api"></a>

API (Application Programming Interface) — это набор функций и процедур, позволяющих создавать приложения, которые могут получать доступ к данным и функционалу другого приложения, службы или операционной системы. API предоставляет интерфейс для взаимодействия различных программных компонентов.

[К содержанию](#content)

---

### 47. Взаимодействие в трехуровневой клиент-серверной архитектуре <a id="взаимодействие-в-трехуровневой-клиент-серверной-архитектуре"></a>

Трехуровневая архитектура включает:
1. **Пользовательский интерфейс (UI)** — клиентская сторона, с которой взаимодействует пользователь.
2. **Логический уровень** — серверная часть, обрабатывающая запросы и выполняющая бизнес-логику.
3. **Уровень данных** — база данных, где хранятся данные.

[К содержанию](#content)

---

### 48. Толстый и тонкий клиент <a id="толстый-и-тонкий-клиент"></a>

- **Толстый клиент**: клиентская сторона, выполняющая большую часть вычислений и логики (например, десктопное приложение).
- **Тонкий клиент**: клиентская сторона с минимальными вычислениями, полагающаяся на сервер для обработки (например, веб-браузер).

[К содержанию](#content)

---

### 49. HTTP и HTTPS: в чем отличия <a id="http-и-https-в-чем-отличия"></a>

- **HTTP (Hypertext Transfer Protocol)** — протокол передачи гипертекста, работает на порте 80.
- **HTTPS (HTTP Secure)** — защищенная версия HTTP, использующая SSL/TLS для шифрования данных, работает на порте 443.

[К содержанию](#content)

---

### 50. HTTPS и шифрование <a id="https-и-шифрование"></a>

HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных. SSL/TLS обеспечивает конфиденциальность и целостность передаваемой информации между клиентом и сервером.

[К содержанию](#content)

### 51. Структура HTTP-запроса <a id="структура-http-запроса"></a>

HTTP-запрос включает:
- **Метод** (например, GET, POST)
- **URL-адрес**
- **Версия HTTP**
- **Заголовки**
- **Тело запроса** (для методов POST, PUT)

Структура HTTP-запроса выглядит следующим образом:

```http
GET /path/to/resource HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

Если это POST запрос, то тело может содержать данные:

```http
POST /path/to/resource HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded

field1=value1&field2=value2
```

[К содержанию](#content)

---

### 52. Уровни модели OSI <a id="уровни-модели-osi"></a>

Модель OSI (Open Systems Interconnection) включает 7 уровней:
1. **Физический**: передача битов по физическому каналу связи.
2. **Канальный**: обеспечение надежной передачи данных между узлами.
3. **Сетевой**: маршрутизация данных между узлами.
4. **Транспортный**: обеспечение надежной передачи данных между приложениями.
5. **Сеансовый**: управление диалогами (сеансами) между приложениями.
6. **Представительный**: преобразование данных для их передачи.
7. **Прикладной**: взаимодействие с приложениями пользователя.

[К содержанию](#content)

---

### 53. Протоколы на прикладном уровне <a id="протоколы-на-прикладном-уровне"></a>

На прикладном уровне работают протоколы:
- **HTTP/HTTPS**: протоколы передачи гипертекста.
- **FTP**: протокол передачи файлов.
- **SMTP**: протокол отправки электронной почты.
- **DNS (Domain Name System)**: отвечает за преобразование доменных имен в IP-адреса.

[К содержанию](#content)

---

### 54. Протоколы на транспортном уровне <a id="протоколы-на-транспортном-уровне"></a>

На транспортном уровне работают протоколы:
- **TCP (Transmission Control Protocol)**: надежный протокол, гарантирующий доставку данных.
- **UDP (User Datagram Protocol)**: быстрый, но ненадежный протокол, не гарантирующий доставку данных.

Разница между ними:
- **TCP**: обеспечивает контроль потока, обнаружение ошибок и повторную передачу потерянных пакетов. Подходит для приложений, требующих надежной передачи данных (например, веб-страницы, email).
- **UDP**: не предоставляет контроль потока и обнаружение ошибок. Подходит для приложений, требующих высокой скорости передачи и допускающих потерю данных (например, видеостриминг, онлайн-игры).

[К содержанию](#content)

---

### 55. MAC и IP адреса <a id="mac-и-ip-адреса"></a>

- **MAC (Media Access Control)**: уникальный адрес сетевого интерфейса устройства, назначается производителем и используется на канальном уровне модели OSI.
- **IP (Internet Protocol)**: адрес, идентифицирующий устройство в сети, используется на сетевом уровне модели OSI. IP-адреса могут быть статическими (постоянными) или динамическими (меняющимися).

[К содержанию](#content)

---

### 56. Коды ответов <a id="коды-ответов"></a>

Коды ответов HTTP:
- **1xx — Информационные**: продолжается обработка запроса (например, 100 Continue).
- **2xx — Успешные**: запрос успешно выполнен (например, 200 OK, 201 Created).
- **3xx — Перенаправления**: требуется дальнейшее действие для выполнения запроса (например, 301 Moved Permanently, 302 Found).
- **4xx — Ошибки клиента**: запрос содержит синтаксическую ошибку или не может быть выполнен (например, 400 Bad Request, 404 Not Found).
- **5xx — Ошибки сервера**: сервер не может выполнить запрос из-за ошибки (например, 500 Internal Server Error, 503 Service Unavailable).

[К содержанию](#content)

---

### 57. Код на регистрацию нового клиента <a id="код-на-регистрацию-нового-клиента"></a>

Для регистрации нового клиента в системе используется POST запрос к API, содержащий данные нового клиента (например, имя, email, пароль) в теле запроса. Пример кода:

```java
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.OutputStream;

public class RegisterClient {
    public static void main(String[] args) {
        try {
            URL url = new URL("http://www.example.com/api/register");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json; utf-8");
            conn.setDoOutput(true);
            
            String jsonInputString = "{\"name\": \"John Doe\", \"email\": \"john.doe@example.com\", \"password\": \"securePassword\"}";
            
            try(OutputStream os = conn.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);           
            }
            
            int responseCode = conn.getResponseCode();
            System.out.println("POST Response Code :: " + responseCode);
            
            if (responseCode == HttpURLConnection.HTTP_OK) { //success
                System.out.println("Client registered successfully.");
            } else {
                System.out.println("Failed to register client.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

[К содержанию](#content)

---

### 58. Методы HTTP <a id="методы-http"></a>

- **GET**: Получение данных с сервера.
- **POST**: Отправка данных на сервер для создания ресурса.
- **PUT**: Обновление существующего ресурса на сервере.
- **PATCH**: Частичное обновление ресурса на сервере.
- **DELETE**: Удаление ресурса с сервера.

[К содержанию](#content)

---

### 59. GET и POST запросы <a id="get-и-post-запросы"></a>

- **GET**: используется для получения данных. Не изменяет состояние сервера. Параметры передаются в URL.
- **POST**: используется для отправки данных на сервер для создания нового ресурса. Параметры передаются в теле запроса.

Пример GET запроса:

```http
GET /api/users?id=123 HTTP/1.1
Host: www.example.com

Пример POST запроса:

```http
POST /api/users HTTP/1.1
Host: www.example.com
Content-Type: application/json

{
    "name": "John Doe",
    "email": "john.doe@example.com"
}
```

[К содержанию](#content)

---

### 60. Иденпотентность <a id="идентичность"></a>

Иденпотентные методы — это методы, которые не изменяют состояние сервера при повторных вызовах. Примеры иденпотентных методов: GET, PUT, DELETE. Повторный вызов этих методов не должен приводить к различным результатам.

[К содержанию](#content)


### 61. Безопасные методы HTTP <a id="безопасные-методы-http"></a>

Безопасные методы — это методы, которые не изменяют состояние сервера. Пример безопасного метода: GET.

[К содержанию](#content)

---

### 62. HEAD и OPTIONS методы <a id="head-и-options-методы"></a>

- **HEAD**: Запрашивает заголовки ресурса, без тела. Используется для проверки доступности ресурса и получения метаинформации.
- **OPTIONS**: Запрашивает поддерживаемые методы для ресурса. Используется для определения возможностей веб-сервера или конкретного ресурса.

Пример HEAD запроса:

```http
HEAD /path/to/resource HTTP/1.1
Host: www.example.com
```
Пример OPTIONS запроса:

```http
OPTIONS /path/to/resource HTTP/1.1
Host: www.example.com
```

[К содержанию](#content)

---

### 63. Что такое API <a id="что-такое-api"></a>

API (Application Programming Interface) — интерфейс для взаимодействия различных программных компонентов. Определяет методы и параметры для вызовов. API позволяет приложениям взаимодействовать друг с другом и обмениваться данными.

[К содержанию](#content)

---

### 64. Виды API <a id="виды-api"></a>

- **REST API**: использует архитектурный стиль REST и передает данные в формате JSON или XML.
- **SOAP API**: использует протокол SOAP и передает данные в формате XML.
- **GraphQL API**: использует язык запросов GraphQL для получения данных с сервера.

[К содержанию](#content)

---

### 65. RESTful системы <a id="restful-системы"></a>

Системы, использующие архитектурный стиль REST, работают по принципам:
- **Отсутствие состояния (stateless)**: каждый запрос от клиента к серверу должен содержать всю необходимую информацию.
- **Клиент-серверная архитектура**: разделение на клиентскую и серверную части, которые взаимодействуют через HTTP.
- **Кеширование**: ответы сервера могут быть кэшированы для повышения производительности.
- **Единообразие интерфейса**: использование стандартных методов HTTP (GET, POST, PUT, DELETE).

[К содержанию](#content)

---

### 66. Код по требованию <a id="код-по-требованию"></a>

Клиент может получать исполняемый код от сервера для выполнения, позволяя динамически изменять функциональность. Это позволяет серверу изменять поведение клиента, передавая ему части кода для выполнения.

Пример использования кода по требованию в RESTful системе:

```java
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

public class CodeOnDemand {
    public static void main(String[] args) {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("JavaScript");
        
        String script = "function greet() { return 'Hello, World!'; } greet();";
        
        try {
            Object result = engine.eval(script);
            System.out.println(result);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
```

[К содержанию](#content)

---

### 67. Разница между SOAP и REST <a id="разница-между-soap-и-rest"></a>

- **SOAP**: протокол на основе XML, поддерживающий ACID транзакции, высокий уровень безопасности, сложен в использовании.
- **REST**: архитектурный стиль, использующий HTTP, легче в реализации и использовании, но менее строгие требования к безопасности.

Основные различия между SOAP и REST:
- **Формат данных**: SOAP использует только XML, REST поддерживает XML, JSON и другие форматы.
- **Сложность**: SOAP требует больше настроек и конфигураций, чем REST.
- **Гибкость**: REST более гибок и широко используется для веб-сервисов.

[К содержанию](#content)

---

### 68. Безопасность SOAP и REST <a id="безопасность-soap-и-rest"></a>

SOAP более безопасный, так как поддерживает WS-Security для обеспечения целостности и конфиденциальности сообщений. REST полагается на стандартные механизмы безопасности HTTP, такие как SSL/TLS.

[К содержанию](#content)

---

### 69. WS-Security в SOAP <a id="ws-security-в-soap"></a>

WS-Security — набор протоколов, обеспечивающих безопасность сообщений в SOAP, включая шифрование и аутентификацию. WS-Security обеспечивает защиту от различных угроз, таких как перехват данных и подмена сообщений.

Пример SOAP сообщения с WS-Security:

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:sec="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
   <soapenv:Header>
      <sec:Security>
         <sec:UsernameToken>
            <sec:Username>username</sec:Username>
            <sec:Password>password</sec:Password>
         </sec:UsernameToken>
      </sec:Security>
   </soapenv:Header>
   <soapenv:Body>
      ...
   </soapenv:Body>
</soapenv:Envelope>
```

[К содержанию](#content)

---

### 70. SOAP и REST <a id="soap-и-rest"></a>

- **SOAP** работает с любыми протоколами, но не поддерживает кэширование.
- **REST** работает только с HTTP и HTTPS, поддерживает кэширование.

SOAP и REST используются для различных задач и имеют свои преимущества и недостатки. SOAP обеспечивает высокий уровень безопасности и надежности, тогда как REST является более простым и гибким решением.

[К содержанию](#content)


### 71. Документация в SOAP и REST <a id="документация-в-soap-и-rest"></a>

- **SOAP**: использует WSDL (Web Services Description Language) для описания веб-сервисов и их интерфейсов.
- **REST**: использует OpenAPI (ранее Swagger) или просто текстовую документацию для описания API и его методов.

Пример WSDL документации для SOAP:

```xml
<definitions>
  <types>
    <!-- Определение типов данных -->
  </types>
  <message>
    <!-- Определение сообщений -->
  </message>
  <portType>
    <!-- Определение операций -->
  </portType>
  <binding>
    <!-- Определение привязок -->
  </binding>
  <service>
    <!-- Определение сервиса -->
  </service>
</definitions>
```

[К содержанию](#content)

---

### 72. Брокер сообщений <a id="брокер-сообщений"></a>

Посредник для передачи сообщений между различными системами. Обеспечивает асинхронную передачу данных, что позволяет системам взаимодействовать независимо и эффективно.

[К содержанию](#content)

---

### 73. Известные брокеры сообщений <a id="известные-брокеры-сообщений"></a>

- **Apache Kafka**: распределенная платформа для потоковой обработки данных, обеспечивает высокую пропускную способность и устойчивость.
- **RabbitMQ**: брокер сообщений с поддержкой множества протоколов, обеспечивает гибкость и масштабируемость.
- **Amazon SQS**: облачный брокер сообщений, предлагает простой и надежный способ обмена сообщениями между сервисами.

[К содержанию](#content)

---

### 74. Монолит и микросервисная архитектура <a id="монолит-и-микросервисная-архитектура"></a>

- **Монолит**: цельное приложение, где все компоненты тесно связаны и разрабатываются вместе. Преимущества: простота разработки и деплоя. Недостатки: сложность масштабирования и обновлений.
- **Микросервисная архитектура**: приложение состоит из независимых сервисов, каждый выполняет отдельные функции. Преимущества: легкость масштабирования и независимые обновления. Недостатки: сложность управления и координации.

[К содержанию](#content)


## 75. Связь микросервисов <a id="связь-микросервисов"></a>

Микросервисы взаимодействуют друг с другом через API, используя различные протоколы связи:

- **HTTP (REST, gRPC)** — для синхронного взаимодействия
- **Сообщения (Message Broker)** — для асинхронного взаимодействия
- **WebSockets** — для двустороннего общения в реальном времени
- **Event-Driven Architecture** — через публикацию событий в шине сообщений (Kafka, RabbitMQ)

[К содержанию](#content)

---

## 76. Синхронные и асинхронные процессы <a id="синхронные-и-асинхронные-процессы"></a>

| Тип процесса  | Описание |
|--------------|----------|
| **Синхронный** | Клиент ожидает ответ от сервера, блокируя выполнение до получения результата. Примеры: HTTP-запросы, JDBC-запросы к БД. |
| **Асинхронный** | Клиент не ожидает немедленного ответа, выполнение продолжается, а результат обрабатывается позже. Примеры: WebSockets, очереди сообщений. |

[К содержанию](#content)

---

## 77. Брокер сообщений — асинхронная передача <a id="брокер-сообщений-и-асинхронная-передача"></a>

Брокер сообщений используется для асинхронной передачи данных между микросервисами. Он позволяет уменьшить нагрузку на систему, обеспечивая надежную доставку сообщений.

Примеры брокеров сообщений:
- **RabbitMQ**
- **Apache Kafka**
- **ActiveMQ**
- **Amazon SQS**

Преимущества использования:
- Масштабируемость
- Децентрализация
- Устойчивость к отказам

Пример кода для отправки и получения сообщений в RabbitMQ (Java):

```java
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
try (Connection connection = factory.newConnection(); 
     Channel channel = connection.createChannel()) {
    channel.queueDeclare("queue_name", false, false, false, null);
    String message = "Hello, World!";
    channel.basicPublish("", "queue_name", null, message.getBytes());
}
```

[К содержанию](#content)

---

## 78. Микросервисы и синхронная передача данных <a id="микросервисы-и-синхронная-передача-данных"></a>

При синхронной передаче данных клиент ожидает ответ от сервиса. Используются:

- **REST API** (HTTP)
- **gRPC** (более производительный вариант REST, использующий Protocol Buffers)

Пример REST-запроса в Spring Boot:

```java
@RestController
@RequestMapping("/api")
public class MyController {
    @GetMapping("/data")
    public ResponseEntity<String> getData() {
        return ResponseEntity.ok("Response data");
    }
}
```

[К содержанию](#content)

---

## 79. Виды баз данных <a id="виды-баз-данных"></a>

| Тип | Описание | Примеры |
|------|----------|---------|
| **Реляционные (SQL)** | Используют таблицы и связи между ними. | MySQL, PostgreSQL, Oracle |
| **NoSQL (нереляционные)** | Хранят данные в виде документов, ключ-значение, графов. | MongoDB, Redis, Cassandra |
| **Графовые базы данных** | Представляют данные в виде графов. | Neo4j, ArangoDB |

[К содержанию](#content)

---

## 80. Первичный ключ <a id="первичный-ключ"></a>

Первичный ключ (Primary Key) — это уникальный идентификатор записи в таблице базы данных.

Пример в SQL:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);
```

[К содержанию](#content)

---

## 81. Внешний ключ <a id="внешний-ключ"></a>

Внешний ключ (Foreign Key) указывает на первичный ключ другой таблицы.

Пример:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id)
);
```

[К содержанию](#content)

---

## 82. Уникальность первичного и внешнего ключа <a id="уникальность-первичного-и-внешнего-ключа"></a>

| Ключ | Уникальность |
|------|-------------|
| **Первичный ключ** | Всегда уникален в таблице. |
| **Внешний ключ** | Может быть неуникальным, так как несколько записей могут ссылаться на одну. |

[К содержанию](#content)

---

## 83. Виды операторов в SQL <a id="виды-операторов-в-sql"></a>

Основные операторы SQL:

- **SELECT** — получение данных
- **INSERT** — добавление данных
- **UPDATE** — обновление данных
- **DELETE** — удаление данных

Пример:

```sql
SELECT * FROM users;
INSERT INTO users (name) VALUES ('John Doe');
UPDATE users SET name = 'Jane Doe' WHERE id = 1;
DELETE FROM users WHERE id = 1;
```

[К содержанию](#content)

---

## 84. Виды мобильных приложений <a id="виды-мобильных-приложений"></a>

| Тип | Описание |
|------|----------|
| **Нативные** | Разрабатываются для конкретной платформы (iOS, Android). |
| **Веб-приложения** | Открываются через браузер, не требуют установки. |
| **Гибридные** | Комбинируют нативные и веб-технологии. |

[К содержанию](#content)

---

## 85. Примеры гибридных приложений <a id="примеры-гибридных-приложений"></a>

Популярные гибридные приложения:

- **Instagram**
- **Uber**
- **Twitter**

Они используют такие технологии, как **Flutter, React Native, Ionic, Cordova**.

[К содержанию](#content)

---
