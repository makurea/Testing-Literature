# Общая классификация тестирования программного обеспечения

Тестирование программного обеспечения — это процесс проверки соответствия программного продукта ожидаемым требованиям и выявления дефектов. Оно может быть классифицировано по различным критериям, таким как уровень тестирования, тип тестирования и степень автоматизации. Рассмотрим каждый из этих критериев более подробно.

---

## 1. **По уровню тестирования**

Уровень тестирования определяет, на каком этапе разработки и для каких компонентов системы проводится тестирование.

### 1.1. **Модульное тестирование (Unit Testing)**
- **Определение**: Тестирование отдельных компонентов или модулей программы (например, функций, методов, классов) на корректность их работы.
- **Цель**: Проверить, что каждый модуль работает изолированно и соответствует техническим требованиям.
- **Инструменты**: JUnit (Java), NUnit (.NET), pytest (Python), Mocha (JavaScript).
- **Пример**: Проверка функции сложения двух чисел на корректность результата.

### 1.2. **Интеграционное тестирование (Integration Testing)**
- **Определение**: Тестирование взаимодействия между несколькими модулями или компонентами системы.
- **Цель**: Убедиться, что модули корректно взаимодействуют друг с другом и обмениваются данными.
- **Типы**:
  - **Снизу вверх (Bottom-Up)**: Тестирование начинается с нижних уровней системы.
  - **Сверху вниз (Top-Down)**: Тестирование начинается с верхних уровней системы.
  - **Сэндвич (Sandwich)**: Комбинация подходов снизу вверх и сверху вниз.
- **Пример**: Проверка взаимодействия между базой данных и веб-сервером.

### 1.3. **Системное тестирование (System Testing)**
- **Определение**: Тестирование всей системы в целом на соответствие функциональным и нефункциональным требованиям.
- **Цель**: Проверить, что система работает как единое целое и удовлетворяет всем требованиям.
- **Пример**: Проверка работы веб-приложения, включая интерфейс, логику и базу данных.

### 1.4. **Приемочное тестирование (Acceptance Testing)**
- **Определение**: Тестирование, проводимое для подтверждения готовности системы к использованию заказчиком или конечным пользователем.
- **Цель**: Убедиться, что система соответствует бизнес-требованиям и готова к эксплуатации.
- **Типы**:
  - **Альфа-тестирование**: Проводится внутри организации разработчиками или тестировщиками.
  - **Бета-тестирование**: Проводится реальными пользователями в реальной среде.
- **Пример**: Проверка заказчиком функциональности системы перед ее внедрением.

---

## 2. **По типу тестирования**

Тип тестирования определяет, какие аспекты системы проверяются.

### 2.1. **Функциональное тестирование**
- **Определение**: Тестирование, направленное на проверку соответствия функциональных требований системы.
- **Цель**: Убедиться, что система выполняет заявленные функции.
- **Примеры**:
  - Проверка работы формы регистрации.
  - Тестирование корректности расчетов в финансовом приложении.

### 2.2. **Нефункциональное тестирование**
- **Определение**: Тестирование, направленное на проверку нефункциональных аспектов системы, таких как производительность, безопасность, удобство использования и т.д.
- **Типы**:
  - **Тестирование производительности (Performance Testing)**: Проверка скорости работы системы под нагрузкой.
  - **Тестирование безопасности (Security Testing)**: Проверка уязвимостей системы.
  - **Тестирование удобства использования (Usability Testing)**: Проверка удобства интерфейса для пользователя.
  - **Тестирование надежности (Reliability Testing)**: Проверка стабильности системы в течение длительного времени.
- **Пример**: Проверка времени отклика системы при одновременной работе 1000 пользователей.

### 2.3. **Регрессионное тестирование (Regression Testing)**
- **Определение**: Тестирование, направленное на проверку того, что изменения в коде не повлияли на уже существующую функциональность.
- **Цель**: Убедиться, что новые изменения не внесли ошибок в ранее работающие части системы.
- **Пример**: Повторное тестирование всех функций после добавления новой фичи.

### 2.4. **Дымовое тестирование (Smoke Testing)**
- **Определение**: Быстрая проверка основных функций системы для подтверждения ее работоспособности.
- **Цель**: Убедиться, что критически важные функции работают после сборки или внесения изменений.
- **Пример**: Проверка запуска приложения и авторизации пользователя.

---

## 3. **По степени автоматизации**

Степень автоматизации определяет, выполняется ли тестирование вручную или с использованием автоматизированных инструментов.

### 3.1. **Ручное тестирование (Manual Testing)**
- **Определение**: Тестирование, выполняемое вручную без использования автоматизированных инструментов.
- **Преимущества**:
  - Подходит для exploratory testing (исследовательского тестирования).
  - Не требует навыков программирования.
- **Недостатки**:
  - Трудоемкость и высокая вероятность человеческой ошибки.
- **Пример**: Ручная проверка интерфейса на соответствие макету.

### 3.2. **Автоматизированное тестирование (Automated Testing)**
- **Определение**: Тестирование, выполняемое с использованием специальных инструментов и скриптов.
- **Преимущества**:
  - Высокая скорость выполнения тестов.
  - Возможность многократного использования тестов.
- **Недостатки**:
  - Требует навыков программирования и времени на написание тестов.
- **Инструменты**: Selenium, Appium, Cypress, TestNG, Robot Framework.
- **Пример**: Автоматическая проверка всех форм на сайте с использованием Selenium.

---

# Что такое автоматизация тестирования

Автоматизация тестирования — это процесс использования специализированных инструментов и скриптов для выполнения тестовых сценариев без участия человека. Это позволяет ускорить процесс тестирования, повысить его точность и снизить затраты на ручное тестирование.

---

# Какие задачи решает автоматизация тестирования, зачем нужна автоматизация

Автоматизация тестирования решает следующие задачи:

- **Ускорение процесса тестирования**: Автоматизация позволяет выполнять тесты быстрее, чем вручную.
- **Повторяемость**: Автоматизированные тесты можно запускать многократно без изменений.
- **Увеличение покрытия тестами**: Автоматизация позволяет охватить больше сценариев, чем при ручном тестировании.
- **Снижение человеческого фактора**: Исключаются ошибки, связанные с человеческим фактором.
- **Интеграция с CI/CD**: Автоматизированные тесты легко интегрируются в процессы непрерывной интеграции и доставки.

---

# Цели автоматизации тестирования

- Повышение качества продукта.
- Снижение времени на тестирование.
- Увеличение покрытия тестами.
- Упрощение процесса тестирования.
- Интеграция с процессами разработки.

---

# Преимущества и недостатки автоматизации тестирования

| Преимущества | Недостатки |
|--------------|------------|
| Ускорение процесса тестирования | Высокие начальные затраты на настройку |
| Повторяемость тестов | Необходимость поддержки тестовых скриптов |
| Увеличение покрытия тестами | Ограниченная применимость для некоторых типов тестирования (например, usability) |
| Снижение человеческого фактора | Требуются квалифицированные специалисты |
| Интеграция с CI/CD | Не всегда окупается для небольших проектов |

---

# Ко всем ли проектам применима автоматизация?

Автоматизация тестирования не всегда применима. Ее целесообразность зависит от:

- **Сложности проекта**: Для простых проектов автоматизация может быть избыточной.
- **Длительности проекта**: Для краткосрочных проектов автоматизация может не окупиться.
- **Частоты изменений**: Если код часто меняется, автоматизация может быть полезна.
- **Бюджета**: Автоматизация требует значительных начальных вложений.

---

# Классическая пирамида тестирования

Классическая пирамида тестирования состоит из трех уровней:

1. **Unit Testing (Модульное тестирование)**: Тестирование отдельных компонентов или модулей кода.
2. **Integration Testing (Интеграционное тестирование)**: Тестирование взаимодействия между модулями.
3. **UI Testing (Тестирование пользовательского интерфейса)**: Тестирование интерфейса пользователя.

---

# Перевернутая пирамида тестирования

Перевернутая пирамида тестирования предполагает больший акцент на UI-тестирование и меньшее внимание к unit-тестам. Это может быть полезно для проектов с высокой сложностью пользовательского интерфейса.

| Преимущества | Недостатки |
|--------------|------------|
| Больший акцент на UI-тестирование | Меньшее внимание к unit-тестам |
| Подходит для сложных интерфейсов | Может привести к увеличению времени тестирования |

---

# E2E Testing

End-to-End (E2E) тестирование — это метод тестирования, при котором проверяется работоспособность всего приложения от начала до конца. Это включает в себя тестирование всех компонентов системы, включая базы данных, сети и пользовательские интерфейсы.

---

# Система контроля версий (что это такое и для чего нужна)

Система контроля версий (Version Control System, VCS) — это инструмент, который помогает управлять изменениями в исходном коде. Она позволяет:

- Отслеживать изменения в коде.
- Восстанавливать предыдущие версии.
- Совместно работать над проектом.

---

# Команды Git

| Команда          | Описание                                                                 |
|------------------|-------------------------------------------------------------------------|
| `git clone <URL>`| Склонировать удаленный репозиторий на локальную машину.                 |
| `git pull`       | Получить изменения из удаленного репозитория и объединить их с локальной версией. |
| `git push`       | Отправить изменения из локального репозитория в удаленный.               |
| `git commit`     | Сохранить изменения в локальном репозитории.                            |
| `git branch`     | Управление ветками (создание, удаление, переименование).                |
| `git rebase`     | Перебазирование ветки на другую ветку.                                  |
| `git merge`      | Объединение веток.                                                     |
| `git config`     | Настройка параметров Git (например, имени и email).                     |
| `git cherry-pick`| Выборочное применение коммитов из одной ветки в другую.                 |
| `git stash`      | Временное сохранение изменений без коммита.                             |
| `git revert`     | Отмена изменений, внесенных конкретным коммитом.                        |
| `git reset`      | Сброс текущего состояния к определенному коммиту.                       |
| `git status`     | Показать текущее состояние рабочей директории и индекса.                |
| `git log`        | Показать историю коммитов.                                             |
| `git diff`       | Показать изменения между коммитами, ветками или рабочим каталогом.     |
| `git fetch`      | Загрузить изменения из удаленного репозитория без слияния.              |
| `git remote`     | Управление удаленными репозиториями.                                    |
| `git tag`        | Создание, просмотр и управление тегами.                                 |
| `git checkout`   | Переключение между ветками или восстановление файлов из коммитов.       |
| `git init`       | Инициализация нового локального репозитория.                            |
| `git add`        | Добавить изменения в индекс (подготовить к коммиту).                    |
| `git rm`         | Удалить файлы из индекса и рабочей директории.                          |
| `git mv`         | Переименовать или переместить файлы.                                    |
| `git show`       | Показать информацию о конкретном коммите.                               |
| `git blame`      | Показать, кто и когда внес изменения в конкретный файл.                 |
| `git clean`      | Удалить неотслеживаемые файлы из рабочей директории.                    |
| `git reflog`     | Показать историю изменений ссылок (например, HEAD).                     |
| `git bisect`     | Поиск коммита, который внес ошибку, с помощью бинарного поиска.         |
| `git grep`       | Поиск текста в файлах репозитория.                                      |
| `git archive`    | Создать архив файлов из репозитория.                                    |
| `git submodule`  | Управление подмодулями в репозитории.                                   |
| `git worktree`   | Управление несколькими рабочими директориями для одного репозитория.    |

---

# Как сделать Pull Request (Merge Request)

1. Создайте новую ветку и внесите изменения.
2. Зафиксируйте изменения с помощью `git commit`.
3. Отправьте изменения в удаленный репозиторий с помощью `git push`.
4. Перейдите в интерфейс GitHub/GitLab и создайте Pull Request (Merge Request).
5. Дождитесь ревью и одобрения изменений.

---

# Git Flow

Git Flow — это модель ветвления для Git, которая помогает организовать процесс разработки. Основные ветки:

- **main (или master)**: Ветка для стабильного кода, готового к выпуску.
- **develop**: Ветка для текущей разработки.
- **feature/***: Ветки для разработки новых функций.
- **release/***: Ветки для подготовки к выпуску.
- **hotfix/***: Ветки для срочных исправлений.

---

# Что такое CI/CD

## Continuous Integration (CI)
Continuous Integration (CI) — это практика автоматической сборки и тестирования кода при каждом изменении. Это позволяет быстро выявлять и устранять ошибки.

## Continuous Delivery (CD)
Continuous Delivery (CD) — это процесс автоматической доставки кода в среду, где он может быть развернут вручную.

## Continuous Deployment (CD)
Continuous Deployment (CD) — это процесс автоматического развертывания кода в продакшн после успешного прохождения всех тестов.

---

# Инструменты CI/CD

- **Jenkins**: Открытый инструмент для автоматизации сборки и тестирования.
- **GitLab CI**: Встроенный CI/CD инструмент в GitLab.
- **GitHub Actions**: Инструмент для автоматизации workflows в GitHub.
- **CircleCI**: Облачный CI/CD сервис.
- **TeamCity**: CI/CD инструмент от JetBrains.
- **TFS**: Team Foundation Server, инструмент от Microsoft.

---

# Пример использования CI/CD

1. Разработчик вносит изменения в код и отправляет их в репозиторий.
2. CI-система автоматически запускает сборку и тесты.
3. Если тесты проходят успешно, код автоматически доставляется в staging-среду (Continuous Delivery).
4. После ручного подтверждения код автоматически развертывается в продакшн (Continuous Deployment).

---

# Виртуализация и контейнеризация

## Виртуализация
Виртуализация — это создание виртуальных машин (VM), которые эмулируют физическое оборудование. Примеры: VMware, VirtualBox.

## Контейнеризация
Контейнеризация — это изоляция приложений в легковесных контейнерах, которые используют общее ядро ОС. Примеры: Docker, Kubernetes.

---

# Docker

Docker — это платформа для разработки, доставки и запуска приложений в контейнерах.

## Основные команды Docker

- `docker build`: Создание образа из Dockerfile.
- `docker run`: Запуск контейнера из образа.
- `docker ps`: Просмотр запущенных контейнеров.
- `docker stop`: Остановка контейнера.
- `docker rm`: Удаление контейнера.
- `docker images`: Просмотр доступных образов.

---

# Пример использования Docker с Java-приложением

В этом примере мы создадим простое Java-приложение, упакуем его в Docker-контейнер и запустим.

## Шаг 1: Создание Java-приложения

Создадим простое Java-приложение, которое выводит "Hello, Docker!" на экран.

1. Создайте файл `HelloDocker.java`:
   ```java
   public class HelloDocker {
       public static void main(String[] args) {
           System.out.println("Hello, Docker!");
       }
   }
   ```

2. Скомпилируйте Java-файл:
   ```bash
   javac HelloDocker.java
   ```

3. Запустите скомпилированный класс:
   ```bash
   java HelloDocker
   ```

   Вывод:
   ```
   Hello, Docker!
   ```

---

## Шаг 2: Создание Dockerfile

Теперь создадим `Dockerfile`, чтобы упаковать наше Java-приложение в Docker-контейнер.

1. Создайте файл `Dockerfile`:
   ```Dockerfile
   # Используем официальный образ OpenJDK
   FROM openjdk:11-jre-slim

   # Устанавливаем рабочую директорию
   WORKDIR /app

   # Копируем скомпилированный Java-класс в контейнер
   COPY HelloDocker.class .

   # Команда для запуска приложения
   CMD ["java", "HelloDocker"]
   ```

---

## Шаг 3: Сборка Docker-образа

Соберите Docker-образ с помощью команды `docker build`:
```bash
docker build -t hello-docker .
```

---

## Шаг 4: Запуск Docker-контейнера

Запустите контейнер с помощью команды `docker run`:
```bash
docker run hello-docker
```

Вывод:
```
Hello, Docker!
```

---

## Шаг 5: Улучшение Dockerfile для сборки Java-приложения

Если вы хотите, чтобы сборка Java-приложения происходила внутри контейнера, можно использовать следующий `Dockerfile`:

```Dockerfile
# Используем официальный образ OpenJDK с JDK для компиляции
FROM openjdk:11-jdk-slim AS build

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем исходный код в контейнер
COPY HelloDocker.java .

# Компилируем Java-файл
RUN javac HelloDocker.java

# Используем другой образ для запуска приложения (без JDK)
FROM openjdk:11-jre-slim

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем скомпилированный класс из этапа сборки
COPY --from=build /app/HelloDocker.class .

# Команда для запуска приложения
CMD ["java", "HelloDocker"]
```

---

## Шаг 6: Сборка и запуск улучшенного Docker-образа

1. Соберите Docker-образ:
   ```bash
   docker build -t hello-docker-improved .
   ```

2. Запустите контейнер:
   ```bash
   docker run hello-docker-improved
   ```

Вывод:
```
Hello, Docker!
```

---

