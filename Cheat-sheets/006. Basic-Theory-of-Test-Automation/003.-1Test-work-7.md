# Общая классификация тестирования

Тестирование программного обеспечения можно классифицировать по различным критериям:

- **По уровню тестирования**:
  - Модульное тестирование (Unit Testing)
  - Интеграционное тестирование (Integration Testing)
  - Системное тестирование (System Testing)
  - Приемочное тестирование (Acceptance Testing)

- **По типу тестирования**:
  - Функциональное тестирование
  - Нефункциональное тестирование (производительность, безопасность, usability и т.д.)
  - Регрессионное тестирование
  - Дымовое тестирование (Smoke Testing)

- **По степени автоматизации**:
  - Ручное тестирование
  - Автоматизированное тестирование

---

# Что такое автоматизация тестирования

Автоматизация тестирования — это процесс использования специализированных инструментов и скриптов для выполнения тестовых сценариев без участия человека. Это позволяет ускорить процесс тестирования, повысить его точность и снизить затраты на ручное тестирование.

---

# Какие задачи решает автоматизация тестирования, зачем нужна автоматизация

Автоматизация тестирования решает следующие задачи:

- **Ускорение процесса тестирования**: Автоматизация позволяет выполнять тесты быстрее, чем вручную.
- **Повторяемость**: Автоматизированные тесты можно запускать многократно без изменений.
- **Увеличение покрытия тестами**: Автоматизация позволяет охватить больше сценариев, чем при ручном тестировании.
- **Снижение человеческого фактора**: Исключаются ошибки, связанные с человеческим фактором.
- **Интеграция с CI/CD**: Автоматизированные тесты легко интегрируются в процессы непрерывной интеграции и доставки.

---

# Цели автоматизации тестирования

- Повышение качества продукта.
- Снижение времени на тестирование.
- Увеличение покрытия тестами.
- Упрощение процесса тестирования.
- Интеграция с процессами разработки.

---

# Преимущества и недостатки автоматизации тестирования

| Преимущества | Недостатки |
|--------------|------------|
| Ускорение процесса тестирования | Высокие начальные затраты на настройку |
| Повторяемость тестов | Необходимость поддержки тестовых скриптов |
| Увеличение покрытия тестами | Ограниченная применимость для некоторых типов тестирования (например, usability) |
| Снижение человеческого фактора | Требуются квалифицированные специалисты |
| Интеграция с CI/CD | Не всегда окупается для небольших проектов |

---

# Ко всем ли проектам применима автоматизация?

Автоматизация тестирования не всегда применима. Ее целесообразность зависит от:

- **Сложности проекта**: Для простых проектов автоматизация может быть избыточной.
- **Длительности проекта**: Для краткосрочных проектов автоматизация может не окупиться.
- **Частоты изменений**: Если код часто меняется, автоматизация может быть полезна.
- **Бюджета**: Автоматизация требует значительных начальных вложений.

---

# Классическая пирамида тестирования

Классическая пирамида тестирования состоит из трех уровней:

1. **Unit Testing (Модульное тестирование)**: Тестирование отдельных компонентов или модулей кода.
2. **Integration Testing (Интеграционное тестирование)**: Тестирование взаимодействия между модулями.
3. **UI Testing (Тестирование пользовательского интерфейса)**: Тестирование интерфейса пользователя.

---

# Перевернутая пирамида тестирования

Перевернутая пирамида тестирования предполагает больший акцент на UI-тестирование и меньшее внимание к unit-тестам. Это может быть полезно для проектов с высокой сложностью пользовательского интерфейса.

| Преимущества | Недостатки |
|--------------|------------|
| Больший акцент на UI-тестирование | Меньшее внимание к unit-тестам |
| Подходит для сложных интерфейсов | Может привести к увеличению времени тестирования |

---

# E2E Testing

End-to-End (E2E) тестирование — это метод тестирования, при котором проверяется работоспособность всего приложения от начала до конца. Это включает в себя тестирование всех компонентов системы, включая базы данных, сети и пользовательские интерфейсы.

---

# Система контроля версий (что это такое и для чего нужна)

Система контроля версий (Version Control System, VCS) — это инструмент, который помогает управлять изменениями в исходном коде. Она позволяет:

- Отслеживать изменения в коде.
- Восстанавливать предыдущие версии.
- Совместно работать над проектом.

---

# Команды Git

| Команда          | Описание                                                                 |
|------------------|-------------------------------------------------------------------------|
| `git clone <URL>`| Склонировать удаленный репозиторий на локальную машину.                 |
| `git pull`       | Получить изменения из удаленного репозитория и объединить их с локальной версией. |
| `git push`       | Отправить изменения из локального репозитория в удаленный.               |
| `git commit`     | Сохранить изменения в локальном репозитории.                            |
| `git branch`     | Управление ветками (создание, удаление, переименование).                |
| `git rebase`     | Перебазирование ветки на другую ветку.                                  |
| `git merge`      | Объединение веток.                                                     |
| `git config`     | Настройка параметров Git (например, имени и email).                     |
| `git cherry-pick`| Выборочное применение коммитов из одной ветки в другую.                 |
| `git stash`      | Временное сохранение изменений без коммита.                             |
| `git revert`     | Отмена изменений, внесенных конкретным коммитом.                        |
| `git reset`      | Сброс текущего состояния к определенному коммиту.                       |
| `git status`     | Показать текущее состояние рабочей директории и индекса.                |
| `git log`        | Показать историю коммитов.                                             |
| `git diff`       | Показать изменения между коммитами, ветками или рабочим каталогом.     |
| `git fetch`      | Загрузить изменения из удаленного репозитория без слияния.              |
| `git remote`     | Управление удаленными репозиториями.                                    |
| `git tag`        | Создание, просмотр и управление тегами.                                 |
| `git checkout`   | Переключение между ветками или восстановление файлов из коммитов.       |
| `git init`       | Инициализация нового локального репозитория.                            |
| `git add`        | Добавить изменения в индекс (подготовить к коммиту).                    |
| `git rm`         | Удалить файлы из индекса и рабочей директории.                          |
| `git mv`         | Переименовать или переместить файлы.                                    |
| `git show`       | Показать информацию о конкретном коммите.                               |
| `git blame`      | Показать, кто и когда внес изменения в конкретный файл.                 |
| `git clean`      | Удалить неотслеживаемые файлы из рабочей директории.                    |
| `git reflog`     | Показать историю изменений ссылок (например, HEAD).                     |
| `git bisect`     | Поиск коммита, который внес ошибку, с помощью бинарного поиска.         |
| `git grep`       | Поиск текста в файлах репозитория.                                      |
| `git archive`    | Создать архив файлов из репозитория.                                    |
| `git submodule`  | Управление подмодулями в репозитории.                                   |
| `git worktree`   | Управление несколькими рабочими директориями для одного репозитория.    |

---

# Как сделать Pull Request (Merge Request)

1. Создайте новую ветку и внесите изменения.
2. Зафиксируйте изменения с помощью `git commit`.
3. Отправьте изменения в удаленный репозиторий с помощью `git push`.
4. Перейдите в интерфейс GitHub/GitLab и создайте Pull Request (Merge Request).
5. Дождитесь ревью и одобрения изменений.

---

# Git Flow

Git Flow — это модель ветвления для Git, которая помогает организовать процесс разработки. Основные ветки:

- **main (или master)**: Ветка для стабильного кода, готового к выпуску.
- **develop**: Ветка для текущей разработки.
- **feature/***: Ветки для разработки новых функций.
- **release/***: Ветки для подготовки к выпуску.
- **hotfix/***: Ветки для срочных исправлений.

---

# Что такое CI/CD

## Continuous Integration (CI)
Continuous Integration (CI) — это практика автоматической сборки и тестирования кода при каждом изменении. Это позволяет быстро выявлять и устранять ошибки.

## Continuous Delivery (CD)
Continuous Delivery (CD) — это процесс автоматической доставки кода в среду, где он может быть развернут вручную.

## Continuous Deployment (CD)
Continuous Deployment (CD) — это процесс автоматического развертывания кода в продакшн после успешного прохождения всех тестов.

---

# Инструменты CI/CD

- **Jenkins**: Открытый инструмент для автоматизации сборки и тестирования.
- **GitLab CI**: Встроенный CI/CD инструмент в GitLab.
- **GitHub Actions**: Инструмент для автоматизации workflows в GitHub.
- **CircleCI**: Облачный CI/CD сервис.
- **TeamCity**: CI/CD инструмент от JetBrains.
- **TFS**: Team Foundation Server, инструмент от Microsoft.

---

# Пример использования CI/CD

1. Разработчик вносит изменения в код и отправляет их в репозиторий.
2. CI-система автоматически запускает сборку и тесты.
3. Если тесты проходят успешно, код автоматически доставляется в staging-среду (Continuous Delivery).
4. После ручного подтверждения код автоматически развертывается в продакшн (Continuous Deployment).

---

# Виртуализация и контейнеризация

## Виртуализация
Виртуализация — это создание виртуальных машин (VM), которые эмулируют физическое оборудование. Примеры: VMware, VirtualBox.

## Контейнеризация
Контейнеризация — это изоляция приложений в легковесных контейнерах, которые используют общее ядро ОС. Примеры: Docker, Kubernetes.

---

# Docker

Docker — это платформа для разработки, доставки и запуска приложений в контейнерах.

## Основные команды Docker

- `docker build`: Создание образа из Dockerfile.
- `docker run`: Запуск контейнера из образа.
- `docker ps`: Просмотр запущенных контейнеров.
- `docker stop`: Остановка контейнера.
- `docker rm`: Удаление контейнера.
- `docker images`: Просмотр доступных образов.

---

# Пример использования Docker с Java-приложением

В этом примере мы создадим простое Java-приложение, упакуем его в Docker-контейнер и запустим.

## Шаг 1: Создание Java-приложения

Создадим простое Java-приложение, которое выводит "Hello, Docker!" на экран.

1. Создайте файл `HelloDocker.java`:
   ```java
   public class HelloDocker {
       public static void main(String[] args) {
           System.out.println("Hello, Docker!");
       }
   }
   ```

2. Скомпилируйте Java-файл:
   ```bash
   javac HelloDocker.java
   ```

3. Запустите скомпилированный класс:
   ```bash
   java HelloDocker
   ```

   Вывод:
   ```
   Hello, Docker!
   ```

---

## Шаг 2: Создание Dockerfile

Теперь создадим `Dockerfile`, чтобы упаковать наше Java-приложение в Docker-контейнер.

1. Создайте файл `Dockerfile`:
   ```Dockerfile
   # Используем официальный образ OpenJDK
   FROM openjdk:11-jre-slim

   # Устанавливаем рабочую директорию
   WORKDIR /app

   # Копируем скомпилированный Java-класс в контейнер
   COPY HelloDocker.class .

   # Команда для запуска приложения
   CMD ["java", "HelloDocker"]
   ```

---

## Шаг 3: Сборка Docker-образа

Соберите Docker-образ с помощью команды `docker build`:
```bash
docker build -t hello-docker .
```

---

## Шаг 4: Запуск Docker-контейнера

Запустите контейнер с помощью команды `docker run`:
```bash
docker run hello-docker
```

Вывод:
```
Hello, Docker!
```

---

## Шаг 5: Улучшение Dockerfile для сборки Java-приложения

Если вы хотите, чтобы сборка Java-приложения происходила внутри контейнера, можно использовать следующий `Dockerfile`:

```Dockerfile
# Используем официальный образ OpenJDK с JDK для компиляции
FROM openjdk:11-jdk-slim AS build

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем исходный код в контейнер
COPY HelloDocker.java .

# Компилируем Java-файл
RUN javac HelloDocker.java

# Используем другой образ для запуска приложения (без JDK)
FROM openjdk:11-jre-slim

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем скомпилированный класс из этапа сборки
COPY --from=build /app/HelloDocker.class .

# Команда для запуска приложения
CMD ["java", "HelloDocker"]
```

---

## Шаг 6: Сборка и запуск улучшенного Docker-образа

1. Соберите Docker-образ:
   ```bash
   docker build -t hello-docker-improved .
   ```

2. Запустите контейнер:
   ```bash
   docker run hello-docker-improved
   ```

Вывод:
```
Hello, Docker!
```

---

