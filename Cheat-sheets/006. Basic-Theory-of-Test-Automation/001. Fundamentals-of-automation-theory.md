# Базовая теория автоматизации тестирования

## Что такое автоматизация тестирования? 
Автоматизация тестирования — это процесс использования специализированного программного обеспечения для выполнения тестов, проверки результатов и сравнения ожидаемых результатов с фактическими. Это позволяет сократить время выполнения тестов, повысить их точность и уменьшить влияние человеческого фактора. Автоматизация тестирования особенно полезна в Agile и DevOps-средах, где требуется быстрая и частая доставка качественного кода.

## Основные принципы и цели автоматизации тестирования
### Принципы:
1. **Повторяемость:** Тесты должны давать одинаковые результаты при каждом запуске. Это обеспечивает стабильность и предсказуемость.
2. **Независимость:** Тесты не должны зависеть друг от друга. Это позволяет запускать их в любом порядке и изолированно.
3. **Поддержка:** Тесты должны легко поддерживаться и обновляться. Хорошо написанные тесты имеют понятную структуру и документацию.
4. **Регрессионное тестирование:** Автоматизация помогает быстро проверять, не сломались ли существующие функции после внесения изменений.
5. **Раннее тестирование:** Автоматизация позволяет начинать тестирование на ранних этапах разработки, что снижает стоимость исправления ошибок.

### Цели:
- **Ускорение процесса тестирования:** Автоматизация позволяет выполнять тесты быстрее, чем вручную.
- **Повышение качества продукта:** Автоматизированные тесты помогают находить больше ошибок, особенно в сложных сценариях.
- **Снижение затрат на ручное тестирование:** Хотя начальные инвестиции в автоматизацию могут быть высокими, в долгосрочной перспективе это окупается.
- **Увеличение покрытия тестами:** Автоматизация позволяет тестировать больше сценариев, включая edge cases.
- **Интеграция в CI/CD:** Автоматизированные тесты легко интегрируются в процессы непрерывной интеграции и доставки.

## Зачем нужна автоматизация?
1. **Для выполнения повторяющихся задач:** Например, проверка формы входа на сайт при каждом новом билде.
2. **Для тестирования в различных окружениях:** Автоматизация позволяет тестировать приложение на разных браузерах, операционных системах и устройствах.
3. **Для выполнения сложных сценариев:** Например, тестирование многошаговых процессов, таких как оформление заказа в интернет-магазине.
4. **Для интеграции в CI/CD:** Автоматизированные тесты могут быть частью пайплайна, что позволяет быстро находить и исправлять ошибки.
5. **Для нагрузочного тестирования:** Автоматизация позволяет имитировать тысячи пользователей, чтобы проверить, как система справляется с нагрузкой.

## Что следует автоматизировать?
1. **Регрессионные тесты:** Проверка, что новые изменения не сломали существующий функционал.
2. **Дымовые тесты:** Базовые проверки работоспособности приложения после каждого билда.
3. **Критические сценарии:** Ключевые функции, которые должны работать всегда (например, оплата в интернет-магазине).
4. **Тесты с большим объемом данных:** Например, проверка обработки больших файлов или импорта данных.
5. **Тесты, требующие многократного выполнения:** Например, нагрузочное тестирование или тестирование на разных устройствах.

## Тесты, которые не должны быть автоматизированы
1. **Исследовательское тестирование:** Требует творческого подхода и не поддается автоматизации.
2. **Тесты, которые часто меняются:** Если требования постоянно изменяются, автоматизация будет неэффективной.
3. **Тесты, которые выполняются один раз:** Автоматизация таких тестов не окупится.
4. **UI-тесты с высокой изменчивостью:** Если интерфейс часто меняется, поддержка автоматизированных тестов будет сложной.
5. **Тесты, требующие человеческого восприятия:** Например, проверка дизайна или удобства интерфейса.

## Пирамида тестирования с примерами на проектах
Пирамида тестирования — это модель, которая показывает, какие типы тестов должны быть в проекте и в каком соотношении. Она состоит из трех уровней:

<img src="https://habrastorage.org/webt/qz/lv/xu/qzlvxuwxpf5cocp0ryev46w7ax8.png" alt="Пирамида тестирования" style="width: 70%; height: auto;">

1. **Unit-тесты (нижний уровень):**
   - **Описание:** Тестирование отдельных функций или методов.
   - **Инструменты:** JUnit, NUnit, pytest.
   - **Пример на проекте:** Проверка функции сложения двух чисел.
   - **Преимущества:** Быстрые, дешевые, легко поддерживаемые.

2. **Интеграционные тесты (средний уровень):**
   - **Описание:** Тестирование взаимодействия между модулями.
   - **Инструменты:** Postman, SoapUI.
   - **Пример на проекте:** Проверка взаимодействия между базой данных и API.
   - **Преимущества:** Позволяют находить ошибки на стыке модулей.

3. **E2E-тесты (верхний уровень):**
   - **Описание:** Тестирование всего приложения от начала до конца.
   - **Инструменты:** Selenium, Cypress, Playwright.
   - **Пример на проекте:** Проверка процесса регистрации пользователя на сайте.
   - **Преимущества:** Позволяют убедиться, что все компоненты работают вместе.

### Пример распределения тестов в пирамиде:
- **Unit-тесты:** 70%
- **Интеграционные тесты:** 20%
- **E2E-тесты:** 10%

## Общая классификация тестирования
### По уровню:
1. **Unit-тесты:** Тестирование отдельных компонентов.
2. **Интеграционные тесты:** Тестирование взаимодействия между компонентами.
3. **Системные тесты:** Тестирование всей системы в целом.
4. **Приемочные тесты:** Тестирование на соответствие требованиям заказчика.

### По типу:
1. **Функциональное тестирование:** Проверка функциональности приложения.
2. **Нагрузочное тестирование:** Проверка производительности под нагрузкой.
3. **Регрессионное тестирование:** Проверка, что новые изменения не сломали существующий функционал.
4. **Тестирование безопасности:** Проверка уязвимостей и защищенности системы.

### По степени автоматизации:
1. **Ручное тестирование:** Выполняется вручную тестировщиком.
2. **Автоматизированное тестирование:** Выполняется с использованием специализированных инструментов.

## Практические примеры применения фигур и E2E-тестов

### Тестовая фигура для frontend-проекта
```javascript
describe('Login Page', () => {
  it('should login with valid credentials', () => {
    cy.visit('/login');
    cy.get('#username').type('testuser');
    cy.get('#password').type('password123');
    cy.get('#login-button').click();
    cy.url().should('include', '/dashboard');
  });

  it('should show error message with invalid credentials', () => {
    cy.visit('/login');
    cy.get('#username').type('wronguser');
    cy.get('#password').type('wrongpassword');
    cy.get('#login-button').click();
    cy.get('.error-message').should('be.visible');
  });
});
```


## Тестовая фигура для backend-проекта на Java

Ниже приведен пример тестовой фигуры для backend-проекта на Java с использованием фреймворка **JUnit** и библиотеки **RestAssured** для тестирования REST API. Этот код тестирует два эндпоинта: получение списка пользователей и создание нового пользователя.

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static io.restassured.RestAssured.given;

public class ApiTest {

    // Устанавливаем базовый URL API перед выполнением тестов
    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "http://localhost:8080"; // Замените на ваш базовый URL
    }

    // Тест для проверки GET-запроса на получение списка пользователей
    @Test
    public void testGetUsers() {
        // Выполняем GET-запрос к эндпоинту /api/users
        Response response = given()
                .when()
                .get("/api/users")
                .then()
                .extract()
                .response();

        // Проверяем, что статус код ответа равен 200 (OK)
        assertEquals(200, response.getStatusCode());

        // Проверяем, что в ответе есть ключевое поле "users"
        assertEquals(true, response.jsonPath().getList("users").size() > 0);
    }

    // Тест для проверки POST-запроса на создание нового пользователя
    @Test
    public void testCreateUser() {
        // Тело запроса в формате JSON
        String requestBody = "{ \"username\": \"testuser\", \"password\": \"testpass\" }";

        // Выполняем POST-запрос к эндпоинту /api/users
        Response response = given()
                .header("Content-Type", "application/json")
                .body(requestBody)
                .when()
                .post("/api/users")
                .then()
                .extract()
                .response();

        // Проверяем, что статус код ответа равен 201 (Created)
        assertEquals(201, response.getStatusCode());

        // Проверяем, что в ответе есть сообщение об успешном создании пользователя
        assertEquals("user created", response.jsonPath().getString("message"));
    }
}
```

## Описание кода

### Основные элементы кода:
1. **`RestAssured.baseURI`**:  
   Устанавливает базовый URL для всех запросов. Это позволяет не указывать полный URL в каждом тесте, а использовать относительные пути.

2. **`@BeforeAll`**:  
   Метод, который выполняется перед всеми тестами. Используется для настройки окружения, например, для инициализации базового URL или других глобальных параметров.

3. **`@Test`**:  
   Аннотация, обозначающая тестовый метод. Каждый метод, помеченный этой аннотацией, будет выполнен как отдельный тест.

4. **`given().when().then()`**:  
   Синтаксис библиотеки **RestAssured** для создания и выполнения HTTP-запросов.  
   - **`given()`**: Настройка запроса (заголовки, тело запроса и т.д.).  
   - **`when()`**: Выполнение запроса (GET, POST, PUT, DELETE и т.д.).  
   - **`then()`**: Проверка ответа (статус код, тело ответа и т.д.).

5. **`assertEquals`**:  
   Метод из библиотеки **JUnit**, который сравнивает ожидаемое значение с фактическим. Если значения не совпадают, тест завершается с ошибкой.

6. **`response.jsonPath()`**:  
   Метод библиотеки **RestAssured**, который позволяет извлекать данные из JSON-ответа. Например, можно получить значение конкретного поля или проверить наличие элемента в массиве.

---

## Зависимости для Maven

Чтобы использовать **RestAssured** и **JUnit**, добавьте следующие зависимости в ваш `pom.xml`:

```xml
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>

    <!-- RestAssured -->
    <dependency>
        <groupId>io.rest-assured</groupId>
        <artifactId>rest-assured</artifactId>
        <version>5.3.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```
